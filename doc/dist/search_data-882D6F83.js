searchData={"items":[{"type":"module","title":":shards","doc":"A minimal replacement for the :shards library for testing.\nUses ETS tables for storage with matching functions.","ref":":shards.html"},{"type":"function","title":":shards.delete/1","doc":"Delete an entire table.","ref":":shards.html#delete/1"},{"type":"function","title":":shards.delete/2","doc":"Delete a record from a table.","ref":":shards.html#delete/2"},{"type":"function","title":":shards.insert/2","doc":"Insert a record into a table.","ref":":shards.html#insert/2"},{"type":"function","title":":shards.lookup/2","doc":"Lookup a record in a table.","ref":":shards.html#lookup/2"},{"type":"function","title":":shards.match_object/2","doc":"Match objects in a table.","ref":":shards.html#match_object/2"},{"type":"function","title":":shards.new/2","doc":"Create a new table.","ref":":shards.html#new/2"},{"type":"function","title":":shards.update_counter/4","doc":"Update a counter in a table.","ref":":shards.html#update_counter/4"},{"type":"module","title":"Bardo.API","doc":"A simplified API layer for Bardo, providing beginner-friendly functions \nfor common tasks while abstracting away implementation complexity.\n\nThis module serves as the main entry point for new users to interact with Bardo\nwithout needing to understand the underlying architecture.","ref":"Bardo.API.html"},{"type":"function","title":"Bardo.API.create_flatland/1","doc":"Create a flatland environment for agent navigation.","ref":"Bardo.API.html#create_flatland/1"},{"type":"function","title":"Options - Bardo.API.create_flatland/1","doc":"* `:id` - the ID for the agent (default: random UUID)\n  * `:hidden_neurons` - number of hidden neurons (default: 5)\n  * `:world_size` - size of the flatland world (default: {10, 10})","ref":"Bardo.API.html#create_flatland/1-options"},{"type":"function","title":"Examples - Bardo.API.create_flatland/1","doc":"iex> Bardo.API.create_flatland()\n    {:ok, agent_id}","ref":"Bardo.API.html#create_flatland/1-examples"},{"type":"function","title":"Bardo.API.create_trading_agent/1","doc":"Create and configure an agent for algorithmic trading.","ref":"Bardo.API.html#create_trading_agent/1"},{"type":"function","title":"Options - Bardo.API.create_trading_agent/1","doc":"* `:id` - the ID for the agent (default: random UUID)\n  * `:instrument` - trading instrument (default: \"EUR_USD\")\n  * `:timeframe` - trading timeframe (default: \"M15\")\n  * `:hidden_neurons` - number of hidden neurons (default: 10)","ref":"Bardo.API.html#create_trading_agent/1-options"},{"type":"function","title":"Examples - Bardo.API.create_trading_agent/1","doc":"iex> Bardo.API.create_trading_agent(instrument: \"BTC_USD\")\n    {:ok, agent_id}","ref":"Bardo.API.html#create_trading_agent/1-examples"},{"type":"function","title":"Bardo.API.create_xor/1","doc":"Create and setup a simple XOR neural network.","ref":"Bardo.API.html#create_xor/1"},{"type":"function","title":"Options - Bardo.API.create_xor/1","doc":"* `:id` - the ID for the agent (default: random UUID)\n  * `:hidden_neurons` - number of hidden neurons (default: 2)\n  * `:bias` - whether to use bias neurons (default: true)\n  * `:activation` - activation function to use (default: :tanh)","ref":"Bardo.API.html#create_xor/1-options"},{"type":"function","title":"Examples - Bardo.API.create_xor/1","doc":"iex> Bardo.API.create_xor()\n    {:ok, agent_id}","ref":"Bardo.API.html#create_xor/1-examples"},{"type":"function","title":"Bardo.API.deploy_trading_agent/2","doc":"Deploy an agent for live trading.","ref":"Bardo.API.html#deploy_trading_agent/2"},{"type":"function","title":"Options - Bardo.API.deploy_trading_agent/2","doc":"* `:broker` - the broker to use (default: :oanda)\n  * `:config` - broker-specific configuration","ref":"Bardo.API.html#deploy_trading_agent/2-options"},{"type":"function","title":"Examples - Bardo.API.deploy_trading_agent/2","doc":"iex> config = %{api_key: \"your_api_key\", account_id: \"your_account_id\"}\n    iex> Bardo.API.deploy_trading_agent(agent_id, broker: :oanda, config: config)\n    {:ok, deployment_id}","ref":"Bardo.API.html#deploy_trading_agent/2-examples"},{"type":"function","title":"Bardo.API.get_agent_metrics/1","doc":"Get performance metrics for an agent.","ref":"Bardo.API.html#get_agent_metrics/1"},{"type":"function","title":"Examples - Bardo.API.get_agent_metrics/1","doc":"iex> Bardo.API.get_agent_metrics(agent_id)\n    {:ok, %{\n      sharpe_ratio: 1.2,\n      max_drawdown: 0.15,\n      total_return: 0.25,\n      win_rate: 0.55\n    }}","ref":"Bardo.API.html#get_agent_metrics/1-examples"},{"type":"function","title":"Bardo.API.init/0","doc":"Initialize a new Bardo environment with sensible defaults.","ref":"Bardo.API.html#init/0"},{"type":"function","title":"Examples - Bardo.API.init/0","doc":"iex> Bardo.API.init()\n    :ok","ref":"Bardo.API.html#init/0-examples"},{"type":"function","title":"Bardo.API.load_trading_agent/1","doc":"Load a pre-trained trading agent from a file.","ref":"Bardo.API.html#load_trading_agent/1"},{"type":"function","title":"Examples - Bardo.API.load_trading_agent/1","doc":"iex> Bardo.API.load_trading_agent(\"/path/to/agent.json\")\n    {:ok, agent_id}","ref":"Bardo.API.html#load_trading_agent/1-examples"},{"type":"function","title":"Bardo.API.run_standalone_training/1","doc":"Run a standalone training session for a trading agent.","ref":"Bardo.API.html#run_standalone_training/1"},{"type":"function","title":"Options - Bardo.API.run_standalone_training/1","doc":"* `:instrument` - trading instrument (default: \"EUR_USD\")\n  * `:timeframe` - trading timeframe (default: \"M15\")\n  * `:start_date` - historical data start date (default: one year ago)\n  * `:end_date` - historical data end date (default: current date)\n  * `:generations` - number of generations to train (default: 100)\n  * `:population_size` - size of the population (default: 50)","ref":"Bardo.API.html#run_standalone_training/1-options"},{"type":"function","title":"Examples - Bardo.API.run_standalone_training/1","doc":"iex> Bardo.API.run_standalone_training(instrument: \"BTC_USD\")\n    {:ok, %{agent_id: agent_id, fitness: 0.85}}","ref":"Bardo.API.html#run_standalone_training/1-examples"},{"type":"function","title":"Bardo.API.save_agent/2","doc":"Save a trained agent to a file.","ref":"Bardo.API.html#save_agent/2"},{"type":"function","title":"Examples - Bardo.API.save_agent/2","doc":"iex> Bardo.API.save_agent(agent_id, \"/path/to/save/agent.json\")\n    :ok","ref":"Bardo.API.html#save_agent/2-examples"},{"type":"function","title":"Bardo.API.setup_distributed_training/1","doc":"Set up distributed training across multiple nodes.","ref":"Bardo.API.html#setup_distributed_training/1"},{"type":"function","title":"Options - Bardo.API.setup_distributed_training/1","doc":"* `:nodes` - list of node names to use for training\n  * `:coordinator` - node to use as coordinator","ref":"Bardo.API.html#setup_distributed_training/1-options"},{"type":"function","title":"Examples - Bardo.API.setup_distributed_training/1","doc":"iex> nodes = [:\"node1@192.168.1.10\", :\"node2@192.168.1.11\"]\n    iex> Bardo.API.setup_distributed_training(nodes: nodes)\n    {:ok, training_id}","ref":"Bardo.API.html#setup_distributed_training/1-examples"},{"type":"function","title":"Bardo.API.stop_trading_agent/1","doc":"Stop a deployed trading agent.","ref":"Bardo.API.html#stop_trading_agent/1"},{"type":"function","title":"Examples - Bardo.API.stop_trading_agent/1","doc":"iex> Bardo.API.stop_trading_agent(deployment_id)\n    :ok","ref":"Bardo.API.html#stop_trading_agent/1-examples"},{"type":"function","title":"Bardo.API.test_xor/1","doc":"Test the agent on the XOR problem.","ref":"Bardo.API.html#test_xor/1"},{"type":"function","title":"Examples - Bardo.API.test_xor/1","doc":"iex> {:ok, agent_id} = Bardo.API.create_xor()\n    iex> Bardo.API.train_xor(agent_id)\n    iex> Bardo.API.test_xor(agent_id)\n    {:ok, %{\n      inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],\n      outputs: [[0.02], [0.98], [0.97], [0.03]],\n      expected: [[0], [1], [1], [0]]\n    }}","ref":"Bardo.API.html#test_xor/1-examples"},{"type":"function","title":"Bardo.API.train_flatland/2","doc":"Train a flatland agent to navigate and avoid obstacles.","ref":"Bardo.API.html#train_flatland/2"},{"type":"function","title":"Options - Bardo.API.train_flatland/2","doc":"* `:generations` - number of generations to train (default: 500)\n  * `:population_size` - size of the population (default: 50)\n  * `:fitness_target` - target fitness to reach (default: 800)\n  * `:simulation_steps` - steps per evaluation (default: 100)","ref":"Bardo.API.html#train_flatland/2-options"},{"type":"function","title":"Examples - Bardo.API.train_flatland/2","doc":"iex> {:ok, agent_id} = Bardo.API.create_flatland()\n    iex> Bardo.API.train_flatland(agent_id)\n    {:ok, %{best_fitness: 825, generations: 320}}","ref":"Bardo.API.html#train_flatland/2-examples"},{"type":"function","title":"Bardo.API.train_xor/2","doc":"Train an agent on the XOR problem.","ref":"Bardo.API.html#train_xor/2"},{"type":"function","title":"Options - Bardo.API.train_xor/2","doc":"* `:generations` - number of generations to train (default: 100)\n  * `:population_size` - size of the population (default: 20)\n  * `:fitness_target` - target fitness to reach (default: 3.9)","ref":"Bardo.API.html#train_xor/2-options"},{"type":"function","title":"Examples - Bardo.API.train_xor/2","doc":"iex> {:ok, agent_id} = Bardo.API.create_xor()\n    iex> Bardo.API.train_xor(agent_id)\n    {:ok, %{best_fitness: 3.95, generations: 42}}","ref":"Bardo.API.html#train_xor/2-examples"},{"type":"module","title":"Bardo.AgentManager.AgentManagerClient","doc":"Client module for interacting with the Agent Manager.\n\nThis module provides a simplified API for interacting with agent-related processes.","ref":"Bardo.AgentManager.AgentManagerClient.html"},{"type":"function","title":"Bardo.AgentManager.AgentManagerClient.fitness/3","doc":"Sends a fitness score to an actuator.","ref":"Bardo.AgentManager.AgentManagerClient.html#fitness/3"},{"type":"function","title":"Bardo.AgentManager.AgentManagerClient.percept/2","doc":"Sends a perception to a sensor.","ref":"Bardo.AgentManager.AgentManagerClient.html#percept/2"},{"type":"function","title":"Bardo.AgentManager.AgentManagerClient.start_agent/2","doc":"Starts an agent with the specified ID and operation mode.","ref":"Bardo.AgentManager.AgentManagerClient.html#start_agent/2"},{"type":"function","title":"Bardo.AgentManager.AgentManagerClient.stop_agent/1","doc":"Stops an agent with the specified ID.","ref":"Bardo.AgentManager.AgentManagerClient.html#stop_agent/1"},{"type":"module","title":"Bardo.AgentManager.AgentWorker","doc":"The AgentWorker is responsible for spawning the Exoself process\n(genotype) which in turn spawns the Cortex, Sensors, Neurons, Actuator\n(phenotype) and maybe the private scape.","ref":"Bardo.AgentManager.AgentWorker.html"},{"type":"function","title":"Bardo.AgentManager.AgentWorker.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.AgentManager.AgentWorker.html#child_spec/1"},{"type":"function","title":"Bardo.AgentManager.AgentWorker.start_link/2","doc":"The start_link function spawns the AgentWorker server.","ref":"Bardo.AgentManager.AgentWorker.html#start_link/2"},{"type":"module","title":"Bardo.AgentManager.AgentWorkerSupervisor","doc":"Dynamic supervisor for agent workers.\n\nThis module is a simple alias for the DynamicSupervisor used to manage\nindividual agent worker processes. It provides helper functions for\nstarting, stopping, and managing agents.","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html"},{"type":"function","title":"Bardo.AgentManager.AgentWorkerSupervisor.child_spec/1","doc":"Child spec for supervisor.\n\nThis allows this module to be used directly in a supervision tree.","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#child_spec/1"},{"type":"function","title":"Bardo.AgentManager.AgentWorkerSupervisor.count_agents/0","doc":"Get the count of running agents.","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#count_agents/0"},{"type":"function","title":"Returns - Bardo.AgentManager.AgentWorkerSupervisor.count_agents/0","doc":"* `{:ok, count}` - The number of running agent workers","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#count_agents/0-returns"},{"type":"function","title":"Bardo.AgentManager.AgentWorkerSupervisor.list_agents/0","doc":"List all running agent IDs.","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#list_agents/0"},{"type":"function","title":"Returns - Bardo.AgentManager.AgentWorkerSupervisor.list_agents/0","doc":"* `{:ok, [atom()]}` - List of running agent IDs","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#list_agents/0-returns"},{"type":"function","title":"Bardo.AgentManager.AgentWorkerSupervisor.start_agent/2","doc":"Start a new agent worker under the dynamic supervisor.","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#start_agent/2"},{"type":"function","title":"Parameters - Bardo.AgentManager.AgentWorkerSupervisor.start_agent/2","doc":"* `agent_id` - Unique identifier for the agent\n  * `params` - Parameters for the agent, including morphology, id, etc.","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#start_agent/2-parameters"},{"type":"function","title":"Returns - Bardo.AgentManager.AgentWorkerSupervisor.start_agent/2","doc":"* `{:ok, pid}` - If the worker was started successfully\n  * `{:error, reason}` - If there was an error starting the worker","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#start_agent/2-returns"},{"type":"function","title":"Bardo.AgentManager.AgentWorkerSupervisor.start_link/1","doc":"Starts the dynamic supervisor for agent workers.","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#start_link/1"},{"type":"function","title":"Bardo.AgentManager.AgentWorkerSupervisor.stop_agent/1","doc":"Stop an agent worker.","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#stop_agent/1"},{"type":"function","title":"Parameters - Bardo.AgentManager.AgentWorkerSupervisor.stop_agent/1","doc":"* `agent_id` - Unique identifier for the agent","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#stop_agent/1-parameters"},{"type":"function","title":"Returns - Bardo.AgentManager.AgentWorkerSupervisor.stop_agent/1","doc":"* `:ok` - If the worker was stopped successfully\n  * `{:error, :not_found}` - If the worker was not found","ref":"Bardo.AgentManager.AgentWorkerSupervisor.html#stop_agent/1-returns"},{"type":"module","title":"Bardo.AgentManager.Exoself","doc":"The Exoself is responsible for reading a genotype, spawning the corresponding phenotype,\nand then shutting itself down. The phenotype consists of a Cortex, Sensors, Actuators and Neurons.","ref":"Bardo.AgentManager.Exoself.html"},{"type":"function","title":"Bardo.AgentManager.Exoself.init/0","doc":"Initialization function for the spawned process.","ref":"Bardo.AgentManager.Exoself.html#init/0"},{"type":"function","title":"Bardo.AgentManager.Exoself.init_phase2/3","doc":"Initializes the exoself process with the given agent ID and operation mode.","ref":"Bardo.AgentManager.Exoself.html#init_phase2/3"},{"type":"function","title":"Bardo.AgentManager.Exoself.start/1","doc":"Starts an Exoself process on the specified node.","ref":"Bardo.AgentManager.Exoself.html#start/1"},{"type":"module","title":"Bardo.AgentManager.Neuron.State","doc":"Struct representing the internal state of a neuron.","ref":"Bardo.AgentManager.Neuron.State.html"},{"type":"behaviour","title":"Bardo.AgentManager.PrivateScape","doc":"Defines generic private scape behavior.\n\nScapes are self contained simulated worlds or virtual environments,\nthat is, they are not necessarily physical. They can be thought of as\na way of interfacing with the problem in question. Scapes are composed\nof two parts, a simulation of an environment or a problem we are\napplying the NN to, and a function that can keep track of the NN's\nperformance. Scapes run outside the NN systems, as independent\nprocesses with which the NNs interact using their sensors and\nactuators. There are two types of scapes. One type of scape, private,\nis spawned for each NN during the NN's creation, and destroyed when\nthat NN is taken offline. Another type of scape, public, is\npersistent, they exist regardless of the NNs, and allow multiple NNs\nto interact with them at the same time, and thus they can allow those\nNNs to interact with each other too. This module defines the private\nscape.","ref":"Bardo.AgentManager.PrivateScape.html"},{"type":"callback","title":"Bardo.AgentManager.PrivateScape.actuate/4","doc":"Callback to actuate on the environment.","ref":"Bardo.AgentManager.PrivateScape.html#c:actuate/4"},{"type":"function","title":"Bardo.AgentManager.PrivateScape.actuate/5","doc":"Performs various PrivateScape functions e.g. move, push, etc. The scape\nAPI is problem dependent. This function provides an interface\nto call various functions defined by the PrivateScape in question.","ref":"Bardo.AgentManager.PrivateScape.html#actuate/5"},{"type":"function","title":"Bardo.AgentManager.PrivateScape.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.AgentManager.PrivateScape.html#child_spec/1"},{"type":"callback","title":"Bardo.AgentManager.PrivateScape.init/1","doc":"Callback to initialize the private scape module state.","ref":"Bardo.AgentManager.PrivateScape.html#c:init/1"},{"type":"callback","title":"Bardo.AgentManager.PrivateScape.sense/2","doc":"Callback to sense input from the environment.","ref":"Bardo.AgentManager.PrivateScape.html#c:sense/2"},{"type":"function","title":"Bardo.AgentManager.PrivateScape.sense/4","doc":"Gathers sensory inputs from the environment.","ref":"Bardo.AgentManager.PrivateScape.html#sense/4"},{"type":"function","title":"Bardo.AgentManager.PrivateScape.start_link/2","doc":"Spawns the PrivateScape process.","ref":"Bardo.AgentManager.PrivateScape.html#start_link/2"},{"type":"callback","title":"Bardo.AgentManager.PrivateScape.terminate/2","doc":"Optional callback for cleanup when terminating.","ref":"Bardo.AgentManager.PrivateScape.html#c:terminate/2"},{"type":"module","title":"Bardo.AgentManager.SignalAggregator","doc":"The SignalAggregator module contains various aggregation functions.\n\nAn aggregation function is a function that in some manner gathers the input signal \nvectors, does something with it and the synaptic weights, and then produces a scalar \nvalue. For example, consider the dot product. The dot_product aggregation function\ncomposes the scalar value by aggregating the input vectors, and then calculating the \ndot product of the input vectors and the synaptic weights.\n\nAnother way to calculate a scalar value from the input and weight vectors is by \nmultiplying the corresponding input signals by their weights, but instead of adding \nthe resulting multiplied values, we multiply them. The are many other types of \naggregation functions that could be created. We can also add normalizer functions, \nwhich could normalize the input signals.","ref":"Bardo.AgentManager.SignalAggregator.html"},{"type":"function","title":"Bardo.AgentManager.SignalAggregator.apply/3","doc":"Apply the appropriate aggregation function to the input.\n\nThis is a dispatcher that routes to the appropriate aggregation function based\non the function name provided.","ref":"Bardo.AgentManager.SignalAggregator.html#apply/3"},{"type":"function","title":"Bardo.AgentManager.SignalAggregator.diff_product/2","doc":"The diff_product can be thought of as a neuron that looks not at the\nactual signal amplitudes, but the temporal difference in signal\namplitudes. If the input signals have stabilized, then the neuron's\ninput is calculated as a 0, if there is a sudden change in the signal,\nthe neuron will see it.","ref":"Bardo.AgentManager.SignalAggregator.html#diff_product/2"},{"type":"function","title":"Bardo.AgentManager.SignalAggregator.dot_product/2","doc":"The dot_product aggregation function is used in almost all artificial\nneural network implementations. It can be considered stable/proven.","ref":"Bardo.AgentManager.SignalAggregator.html#dot_product/2"},{"type":"function","title":"Bardo.AgentManager.SignalAggregator.mult_product/2","doc":"The worth of the mult_product aggregation function is questionable, and\nshould be further studied through benchmarking and testing. If there is\nany worth to this type of signal aggregator, evolution will find it!","ref":"Bardo.AgentManager.SignalAggregator.html#mult_product/2"},{"type":"module","title":"Bardo.AgentManager.SubstrateCEP","doc":"The substrate polls the substrate_cpps (Substrate Coordinate PreProcessor), and then waits for the signals from the\nsubstrate_ceps (Substrate Connectivity Expression Producer) process, which tells it what the synaptic weight is between\nthe two neurodes with which the substrate_cpps were called with, and whether the connection between these neurodes is\nexpressed or not.\n\nThe substrate_cpp and substrate_cep processes are analogous to the sensors and actuators respectively, but\ndriven and polled by the substrate when it wishes to calculate the synaptic weights and connectivity expression\nbetween its various neurodes.\n\nThe substrate will forward to its one or more substrate_cpps the coordinates of the two connected neurodes in question,\nthe called substrate_cpp will process those coordinates based on its type and forward the processed vector to the NN. The\nsubstrate will then wait for the signals from its one or more substrate_ceps, which will provide it with the various signals\nwhich the substrate will then use to set its synaptic weights, connectivity expressions, or even plasticity based synaptic\nweight updates.\n\nThe substrate uses its substrate_cpps and substrate_ceps for every synaptic weight/expression it wishes to set or update. Unlike the\nsensors and actuators, the substrate_cpps and substrate_ceps do not need to sync up with the cortex because the substrate_cpps are\nnot be triggered by the cortex, and because the signals from substrate_ceps are awaited by the substrate, and since the substrate\nitself only processes signals once it has received all the sensory signals from the sensors which themselves are triggered by the cortex,\nthe whole system is synchronized.","ref":"Bardo.AgentManager.SubstrateCEP.html"},{"type":"function","title":"Bardo.AgentManager.SubstrateCEP.forward/3","doc":"The neurons in the output layer of the NN produce output signals,\nwhich are then sent to the CEPs they are connected to.\nThe CEPs wait and gather the signals from all the neurons with whom\nthey have presynaptic links. The CEPs process the accumulated signals.\nThe CEPs forward the vector signals to the substrate.","ref":"Bardo.AgentManager.SubstrateCEP.html#forward/3"},{"type":"function","title":"Bardo.AgentManager.SubstrateCEP.init/1","doc":"Whenever a SubstrateCEP process is started via the start function this\nfunction is called by the new process to initialize.","ref":"Bardo.AgentManager.SubstrateCEP.html#init/1"},{"type":"function","title":"Bardo.AgentManager.SubstrateCEP.init_phase2/8","doc":"Initializes the substrate_cep.","ref":"Bardo.AgentManager.SubstrateCEP.html#init_phase2/8"},{"type":"function","title":"Bardo.AgentManager.SubstrateCEP.loop/1","doc":"Receive and handle messages.","ref":"Bardo.AgentManager.SubstrateCEP.html#loop/1"},{"type":"function","title":"Bardo.AgentManager.SubstrateCEP.loop/8","doc":"The substrate_cep process gathers the control signals from the\nneurons, appending them to the accumulator. The order in which the\nsignals are accumulated into a vector is in the same order that the\nneuron ids are stored within NIds. Once all the signals have been\ngathered, the substrate_cep executes its function, forwards the\nprocessed signal to the substrate, and then again begins to wait\nfor the neural signals from the output layer by reseting the\nFaninPids from the second copy of the list.","ref":"Bardo.AgentManager.SubstrateCEP.html#loop/8"},{"type":"function","title":"Bardo.AgentManager.SubstrateCEP.start/2","doc":"Spawns a SubstrateCEP process belonging to the exoself process that\nspawned it and calls init to initialize.","ref":"Bardo.AgentManager.SubstrateCEP.html#start/2"},{"type":"function","title":"Bardo.AgentManager.SubstrateCEP.stop/2","doc":"Terminates the SubstrateCEP.","ref":"Bardo.AgentManager.SubstrateCEP.html#stop/2"},{"type":"function","title":"Bardo.AgentManager.SubstrateCEP.terminate/1","doc":"This function is called to terminate the process. It performs\nany necessary cleaning up before exiting with the reason\nparameter that it was called with.","ref":"Bardo.AgentManager.SubstrateCEP.html#terminate/1"},{"type":"module","title":"Bardo.AgentManager.SubstrateCPP","doc":"The substrate polls the substrate_cpps (Substrate Coordinate PreProcessor), and then waits for the signals from the\nsubstrate_ceps (Substrate Connectivity Expression Producer) process, which tells it what the synaptic weight is between\nthe two neurodes with which the substrate_cpps were called with, and whether the connection between these neurodes is\nexpressed or not.\n\nThe substrate_cpp and substrate_cep processes are analogous to the sensors and actuators respectively, but\ndriven and polled by the substrate when it wishes to calculate the synaptic weights and connectivity expression\nbetween its various neurodes.\n\nThe substrate will forward to its one or more substrate_cpps the coordinates of the two connected neurodes in question,\nthe called substrate_cpp will process those coordinates based on its type and forward the processed vector to the NN. The\nsubstrate will then wait for the signals from its one or more substrate_ceps, which will provide it with the various signals\nwhich the substrate will then use to set its synaptic weights, connectivity expressions, or even plasticity based synaptic\nweight updates.\n\nThe substrate uses its substrate_cpps and substrate_ceps for every synaptic weight/expression it wishes to set or update. Unlike the\nsensors and actuators, the substrate_cpps and substrate_ceps do not need to sync up with the cortex because the substrate_cpps are\nnot be triggered by the cortex, and because the signals from substrate_ceps are awaited by the substrate, and since the substrate\nitself only processes signals once it has received all the sensory signals from the sensors which themselves are triggered by the cortex,\nthe whole system is synchronized.","ref":"Bardo.AgentManager.SubstrateCPP.html"},{"type":"function","title":"Bardo.AgentManager.SubstrateCPP.init/1","doc":"Whenever a SubstrateCPP process is started via the start function this\nfunction is called by the new process to initialize.","ref":"Bardo.AgentManager.SubstrateCPP.html#init/1"},{"type":"function","title":"Bardo.AgentManager.SubstrateCPP.init_phase2/9","doc":"Initializes substrate_cpp.","ref":"Bardo.AgentManager.SubstrateCPP.html#init_phase2/9"},{"type":"function","title":"Bardo.AgentManager.SubstrateCPP.loop/1","doc":"Receive and handle messages.","ref":"Bardo.AgentManager.SubstrateCPP.html#loop/1"},{"type":"function","title":"Bardo.AgentManager.SubstrateCPP.loop/8","doc":"Receive and handle messages.","ref":"Bardo.AgentManager.SubstrateCPP.html#loop/8"},{"type":"function","title":"Bardo.AgentManager.SubstrateCPP.neurode_coordinates/4","doc":"The substrate sends the coordinates of the connected neurodes to the\nsubstrate_cpps it is connected to. The CPPs process the coordinates.\nThe CPPs forward the processed coordinate vectors to the neurons they\nare connected to in the NN. The NN processes the coordinate signals.","ref":"Bardo.AgentManager.SubstrateCPP.html#neurode_coordinates/4"},{"type":"function","title":"Bardo.AgentManager.SubstrateCPP.neurode_coordinates_iow/5","doc":"IOW = Input, Output and Weight.\nThe substrate sends the coordinates of the connected neurodes to the\nsubstrate_cpps it is connected to. The CPPs process the coordinates.\nThe CPPs forward the processed coordinate vectors to the neurons they\nare connected to in the NN. The NN processes the coordinate signals.","ref":"Bardo.AgentManager.SubstrateCPP.html#neurode_coordinates_iow/5"},{"type":"function","title":"Bardo.AgentManager.SubstrateCPP.start/2","doc":"Spawns a SubstrateCPP process belonging to the exoself process that\nspawned it and calls init to initialize.","ref":"Bardo.AgentManager.SubstrateCPP.html#start/2"},{"type":"function","title":"Bardo.AgentManager.SubstrateCPP.stop/2","doc":"Terminates substrate_cpp.","ref":"Bardo.AgentManager.SubstrateCPP.html#stop/2"},{"type":"function","title":"Bardo.AgentManager.SubstrateCPP.terminate/1","doc":"This function is called to terminate the process. It performs\nany necessary cleaning up before exiting with the reason\nparameter that it was called with.","ref":"Bardo.AgentManager.SubstrateCPP.html#terminate/1"},{"type":"module","title":"Bardo.AgentManager.Supervisor","doc":"Supervisor for the AgentManager subsystem.\n\nThis supervisor manages the various components of the AgentManager subsystem,\nincluding the AgentManager itself and the dynamic supervisor for agent workers.","ref":"Bardo.AgentManager.Supervisor.html"},{"type":"function","title":"Bardo.AgentManager.Supervisor.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.AgentManager.Supervisor.html#child_spec/1"},{"type":"function","title":"Bardo.AgentManager.Supervisor.start_link/1","doc":"Starts the supervisor.","ref":"Bardo.AgentManager.Supervisor.html#start_link/1"},{"type":"module","title":"Bardo.AgentManager.TuningDuration","doc":"The TuningDuration module contains all the tuning duration functions,\nfunctions which calculate how long the tuning phase must run. The\ntuning duration function sets the max_attempts value, with the\nfunction format being as follows: - Input: Neuron_Ids,\nAgentGeneration - Output: Max_Attempts. The tuning duration\nfunction can output a constant, which is what we used thus far.\nIt can output a value that is proportional to the number of neurons\ncomposing the NN, or it can produce a value based on the number of\nall neurons in the population.\n\nNOTE: When creating tuning duration functions that take into account\nNN's size, we must ensure that this factor skews the fitness towards\nproducing smaller NN systems, not larger. We do not want to reward\nneural bloating. For example, if we create a tuning duration function\nwhich uses the following equation: MaxAttempts = 100 * TotNeurons, we\nwill be giving an incentive for the NNs to bloat. Since just be adding\none extra neuron, the NN has 100 extra tries to improve its fitness,\nchances are that it will be a bit more fit than its better counterparts\nwhich did not get as many attempts.\n\nThe nsize_proportional and wsize_proportional functions have their\nexponential power parameters set to 0.5, and thus take the\nsquare root of the number of neurons and weights respectively. Thus,\nthe NN systems which have a larger number of weights or neurons to\noptimize, will have a larger number of chances, but just barely.\n\nHopefully, this approach will not overwrite and undermine the fitness\nfunction, still push towards more concise topologies, while at the same\ntime provide for a few more optimization attempts to the larger\nNN based agents, which need them due to having that many more synaptic\nweight permutations which can be explored.","ref":"Bardo.AgentManager.TuningDuration.html"},{"type":"function","title":"Bardo.AgentManager.TuningDuration.const/3","doc":"Returns the preset const max_attempts value.","ref":"Bardo.AgentManager.TuningDuration.html#const/3"},{"type":"function","title":"Bardo.AgentManager.TuningDuration.nsize_proportional/3","doc":"Calculates the max_attempts to be proportional to the number of neurons\nwhich were within the last 3 generations mutated or added to the NN.","ref":"Bardo.AgentManager.TuningDuration.html#nsize_proportional/3"},{"type":"function","title":"Bardo.AgentManager.TuningDuration.wsize_proportional/3","doc":"Calculates the max_attempts value based on the individual agent's parameters,\nin this case the max_attempts is proportional to the agent's number of weights\nbelonging to the neurons which were added or mutated within the last 3 generations.","ref":"Bardo.AgentManager.TuningDuration.html#wsize_proportional/3"},{"type":"module","title":"Bardo.AgentManager.TuningSelection","doc":"The TuningSelection module contains all the tuning selection functions,\nwhich accept as input four parameters:\n1. All NIds belonging to the NN.\n2. The agent's generation, which is the number of topological\n   mutation phases that it has undergone.\n3. The perturbation range, the multiplier of math:pi(), which when\n   used produces the spread value.\n4. The annealing parameter, which is used to indicate how the\n   perturbation range decays with the age of the neuron to which synaptic\n   weight perturbation is applied.\n   \nIt makes less sense to perturb the more stable elements of the NN system, \nless so than those elements which have just recently been added to the NN system, \nand which still need to be tuned and modified to work well with the already existing\nlarger system. The concept is that of simulated annealing.\n\nWe gather all these selection functions in their own module because there\nare many ways to select neurons which should be perturbed in local\nsearch during the tuning phase. This makes it easier for us to add new\nselection functions later on, and see if a new function can improve\nthe performance.\n\nThe tuning selection function must not only select the neuron ids for\nsynaptic perturbation, but also compute the perturbation intensity,\nthe available range of the perturbation intensity, from which the\nneuron will then randomly generate a weight perturbation value. Thus,\nthe selection_function creates a list of tuples rather than simply a\nlist of neuron ids. The selection_function outputs a list of the\nfollowing form: [{NId, Spread},...], where NId is the neuron id, and\nSpread is the spread above and below 0, the value within which the\nneuron generates the actual perturbation. The Spread equals the\nperturbation_range value if there is no annealing, if annealing is\npresent (annealing_parameter =< 1), then the Spread is further\nmodified. The annealing factor must scale the Spread, proportional to\nthe age of the neuron whose synaptic weights are to be perturbed. In\ntuning selection algorithms, the spread value is calculated as follows:\n\n`Spread = PerurbationRange * math:pi() * math:pow(AnnealingParam, NAge)`\n\nWhen AnnealingParameter = 1, there is no annealing. But when the\nAnnealingParameter is set to a number lower than 1, then annealing is\nexponentially proportional to the neuron's age.","ref":"Bardo.AgentManager.TuningSelection.html"},{"type":"function","title":"Bardo.AgentManager.TuningSelection.active/4","doc":"active selection algorithm composes a neuron id pool from all\nneurons who are younger than 3 generations.","ref":"Bardo.AgentManager.TuningSelection.html#active/4"},{"type":"function","title":"Bardo.AgentManager.TuningSelection.active_random/4","doc":"active_random is a selection algorithm that composes an id pool by\nfirst creating a list of all neurons who are younger than 3\ngenerations, and then composing a sub list from it by randomly\nchoosing elements from this list with a probability of\n1/math:sqrt(Tot_Neurons).","ref":"Bardo.AgentManager.TuningSelection.html#active_random/4"},{"type":"function","title":"Bardo.AgentManager.TuningSelection.all/4","doc":"all returns a list of tuples composed of all ids (and their spread\nvalues) belonging to the NN, to the caller.","ref":"Bardo.AgentManager.TuningSelection.html#all/4"},{"type":"function","title":"Bardo.AgentManager.TuningSelection.all_random/4","doc":"all_random first composes a list of tuples from NIds and their\nspreads, and then creates a sublist by choosing each element with a\nprobability of 1/math:sqrt(Tot_neurons).","ref":"Bardo.AgentManager.TuningSelection.html#all_random/4"},{"type":"function","title":"Bardo.AgentManager.TuningSelection.current/4","doc":"current is a selection algorithm that returns a list of all neurons\nwhich have been added to the NN, or affected by mutation, during the\nlast generation.","ref":"Bardo.AgentManager.TuningSelection.html#current/4"},{"type":"function","title":"Bardo.AgentManager.TuningSelection.current_random/4","doc":"current_random composes the list of tuples in the same way as\ncurrent does, but then composes a sublist by randomly selecting\nelements from that list with a probability of\n1/math:sqrt(Tot_Neurons), and returning that to the caller.","ref":"Bardo.AgentManager.TuningSelection.html#current_random/4"},{"type":"function","title":"Bardo.AgentManager.TuningSelection.dynamic/4","doc":"The dynamic selection function randomly selects an age limit for\nits neuron id pool. The age limit is chosen by executing\nmath:sqrt(1/rand:uniform()), which creates a value between 1 and\ninfinity. Using this function there is 75% that the number will be\n=< 2, 25% that it will be >= 2, 11% that it will be >= 3...Every time\nthis selection function is executed, the AgeLimit is generated anew,\nthus different times it will produce different neuron id pools for\ntuning.","ref":"Bardo.AgentManager.TuningSelection.html#dynamic/4"},{"type":"function","title":"Bardo.AgentManager.TuningSelection.dynamic_random/4","doc":"dyanimic_random selection function composes the neuron id pool the\nsame way as the dynamic/4 selection function, but after this id pool\nis generated, this selection function extracts ids from it randomly\nwith a probability of 1/math:sqrt(Tot_Neurons). Thus the probability\nof a neuron being selected from this pool is proportional to the\nnumber of ids in that pool. If through chance no ids are selected,\nthen the first element in the id pool is automatically selected, and\ngiven the highest spread.","ref":"Bardo.AgentManager.TuningSelection.html#dynamic_random/4"},{"type":"module","title":"Bardo.Core","doc":"Core API for Bardo neuroevolution library.\n\nThis module serves as the main entry point for users who are importing Bardo\nas a dependency. It provides a clean, well-documented API that focuses on the\nessential neuroevolution functionality while hiding implementation details.","ref":"Bardo.Core.html"},{"type":"module","title":"Key Features - Bardo.Core","doc":"* **Neural Network Creation** - Define neural network architectures with sensors and actuators\n* **Evolutionary Training** - Train neural networks through evolutionary algorithms\n* **Agent Management** - Create and manage neuroevolutionary agents\n* **Experiment Control** - Run controlled experiments with multiple populations","ref":"Bardo.Core.html#module-key-features"},{"type":"module","title":"Usage Example - Bardo.Core","doc":"```elixir\n# Define a simple neural network morphology\nmorphology = Bardo.Core.create_morphology(%{\n  name: \"XOR Network\",\n  dimensions: 2,\n  inputs: 2,\n  outputs: 1,\n  hidden_layers: [3]\n})\n\n# Create an experiment\n{:ok, experiment_id} = Bardo.Core.create_experiment(\"XOR Experiment\")\n\n# Configure the experiment with our morphology\n:ok = Bardo.Core.configure_experiment(experiment_id, %{\n  morphology: morphology,\n  population_size: 50,\n  generations: 100\n})\n\n# Define a fitness function for XOR\nfitness_fn = fn agent ->\n  accuracy = Bardo.Core.evaluate_agent(agent, [\n    {[0.0, 0.0], [0.0]},\n    {[0.0, 1.0], [1.0]},\n    {[1.0, 0.0], [1.0]},\n    {[1.0, 1.0], [0.0]}\n  ])\n  1.0 - accuracy  # Convert accuracy to error (lower is better)\nend\n\n# Set the fitness function and run the experiment\n:ok = Bardo.Core.set_fitness_function(experiment_id, fitness_fn)\n:ok = Bardo.Core.run_experiment(experiment_id)\n\n# Get the best solution when the experiment completes\n{:ok, solution} = Bardo.Core.get_best_solution(experiment_id)\n```","ref":"Bardo.Core.html#module-usage-example"},{"type":"function","title":"Bardo.Core.activate_agent/2","doc":"Activates a neural network agent with the given inputs.\n\nThis function passes input values through the neural network and returns\nthe resulting output values.","ref":"Bardo.Core.html#activate_agent/2"},{"type":"function","title":"Parameters - Bardo.Core.activate_agent/2","doc":"* `agent` - The agent (neural network) to activate\n  * `inputs` - List of input values for the network","ref":"Bardo.Core.html#activate_agent/2-parameters"},{"type":"function","title":"Returns - Bardo.Core.activate_agent/2","doc":"* List of output values from the network","ref":"Bardo.Core.html#activate_agent/2-returns"},{"type":"function","title":"Examples - Bardo.Core.activate_agent/2","doc":"outputs = Bardo.Core.activate_agent(agent, [0.0, 1.0])\n    # For an XOR network with one output, this might return [1.0]","ref":"Bardo.Core.html#activate_agent/2-examples"},{"type":"function","title":"Bardo.Core.add_actuator/2","doc":"Adds an actuator to a morphology.","ref":"Bardo.Core.html#add_actuator/2"},{"type":"function","title":"Parameters - Bardo.Core.add_actuator/2","doc":"* `morphology` - The morphology to add the actuator to\n  * `actuator_opts` - Options for the actuator","ref":"Bardo.Core.html#add_actuator/2-parameters"},{"type":"function","title":"Actuator Options - Bardo.Core.add_actuator/2","doc":"* `:name` - The name of the actuator (required, as atom)\n  * `:type` - The type of actuator (default: :standard)\n  * `:vl` - Vector length, number of inputs to this actuator (required)\n  * `:parameters` - Additional parameters for the actuator","ref":"Bardo.Core.html#add_actuator/2-actuator-options"},{"type":"function","title":"Returns - Bardo.Core.add_actuator/2","doc":"* An updated morphology with the new actuator","ref":"Bardo.Core.html#add_actuator/2-returns"},{"type":"function","title":"Examples - Bardo.Core.add_actuator/2","doc":"# Add a motor actuator to a morphology\n    morphology = Bardo.Core.create_morphology()\n    updated_morphology = Bardo.Core.add_actuator(morphology, %{\n      name: :motor,\n      vl: 2,\n      parameters: %{max_speed: 10.0}\n    })","ref":"Bardo.Core.html#add_actuator/2-examples"},{"type":"function","title":"Bardo.Core.add_agent_to_scape/4","doc":"Adds an agent to a scape.","ref":"Bardo.Core.html#add_agent_to_scape/4"},{"type":"function","title":"Parameters - Bardo.Core.add_agent_to_scape/4","doc":"* `scape_id` - ID of the scape\n  * `agent_id` - ID of the agent to add\n  * `agent` - The agent to add\n  * `position` - Position to place the agent at","ref":"Bardo.Core.html#add_agent_to_scape/4-parameters"},{"type":"function","title":"Returns - Bardo.Core.add_agent_to_scape/4","doc":"* `:ok` - If the agent was added successfully\n  * `{:error, reason}` - If there was an error adding the agent","ref":"Bardo.Core.html#add_agent_to_scape/4-returns"},{"type":"function","title":"Examples - Bardo.Core.add_agent_to_scape/4","doc":":ok = Bardo.Core.add_agent_to_scape(\"flatland\", \"agent1\", agent, [50, 50])","ref":"Bardo.Core.html#add_agent_to_scape/4-examples"},{"type":"function","title":"Bardo.Core.add_sensor/2","doc":"Adds a sensor to a morphology.","ref":"Bardo.Core.html#add_sensor/2"},{"type":"function","title":"Parameters - Bardo.Core.add_sensor/2","doc":"* `morphology` - The morphology to add the sensor to\n  * `sensor_opts` - Options for the sensor","ref":"Bardo.Core.html#add_sensor/2-parameters"},{"type":"function","title":"Sensor Options - Bardo.Core.add_sensor/2","doc":"* `:name` - The name of the sensor (required, as atom)\n  * `:type` - The type of sensor (default: :standard)\n  * `:vl` - Vector length, number of outputs from this sensor (required)\n  * `:parameters` - Additional parameters for the sensor","ref":"Bardo.Core.html#add_sensor/2-sensor-options"},{"type":"function","title":"Returns - Bardo.Core.add_sensor/2","doc":"* An updated morphology with the new sensor","ref":"Bardo.Core.html#add_sensor/2-returns"},{"type":"function","title":"Examples - Bardo.Core.add_sensor/2","doc":"# Add a vision sensor to a morphology\n    morphology = Bardo.Core.create_morphology()\n    updated_morphology = Bardo.Core.add_sensor(morphology, %{\n      name: :vision,\n      vl: 100,\n      parameters: %{fov: 120}\n    })","ref":"Bardo.Core.html#add_sensor/2-examples"},{"type":"function","title":"Bardo.Core.configure_experiment/2","doc":"Configures an existing experiment with the given parameters.","ref":"Bardo.Core.html#configure_experiment/2"},{"type":"function","title":"Parameters - Bardo.Core.configure_experiment/2","doc":"* `experiment_id` - ID of the experiment to configure\n  * `config` - Configuration parameters for the experiment","ref":"Bardo.Core.html#configure_experiment/2-parameters"},{"type":"function","title":"Configuration Options - Bardo.Core.configure_experiment/2","doc":"* `:runs` - Number of separate evolutionary runs to perform (default: 1)\n  * `:generations` - Maximum number of generations per run (default: 100)\n  * `:population_size` - Number of individuals in the population (default: 50)\n  * `:morphology` - The morphology to use (either a morphology map or an ID)\n  * `:selection_method` - Method for selecting parents, one of: [:tournament, :roulette, :rank] (default: :tournament)\n  * `:crossover_rate` - Probability of crossover (default: 0.7)\n  * `:mutation_rate` - Probability of mutation (default: 0.3)\n  * `:elitism` - Fraction of top individuals to preserve unchanged (default: 0.1)\n  * `:backup_flag` - Whether to back up best solutions (default: true)\n  * `:visualize` - Whether to generate visualizations (default: false)\n  * `:distributed` - Whether to use distributed evolution (default: false)","ref":"Bardo.Core.html#configure_experiment/2-configuration-options"},{"type":"function","title":"Returns - Bardo.Core.configure_experiment/2","doc":"* `:ok` - If the experiment was configured successfully\n  * `{:error, reason}` - If there was an error configuring the experiment","ref":"Bardo.Core.html#configure_experiment/2-returns"},{"type":"function","title":"Examples - Bardo.Core.configure_experiment/2","doc":":ok = Bardo.Core.configure_experiment(experiment_id, %{\n      runs: 5,\n      generations: 50,\n      population_size: 100,\n      morphology: morphology,\n      selection_method: :tournament\n    })","ref":"Bardo.Core.html#configure_experiment/2-examples"},{"type":"function","title":"Bardo.Core.create_experiment/1","doc":"Creates a new experiment with the given name.\n\nExperiments are the top-level container for evolutionary runs. They manage:\n* Population configuration\n* Fitness evaluation\n* Running multiple evolutionary trials\n* Collecting and analyzing results","ref":"Bardo.Core.html#create_experiment/1"},{"type":"function","title":"Parameters - Bardo.Core.create_experiment/1","doc":"* `name` - Name of the experiment","ref":"Bardo.Core.html#create_experiment/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.create_experiment/1","doc":"* `{:ok, experiment_id}` - Experiment ID of the created experiment\n  * `{:error, reason}` - If there was an error creating the experiment","ref":"Bardo.Core.html#create_experiment/1-returns"},{"type":"function","title":"Examples - Bardo.Core.create_experiment/1","doc":"{:ok, experiment_id} = Bardo.Core.create_experiment(\"XOR Experiment\")","ref":"Bardo.Core.html#create_experiment/1-examples"},{"type":"function","title":"Bardo.Core.create_morphology/1","doc":"Creates a new neural network morphology with the given options.\n\nThis function defines the structure of the neural network, including:\n* Number of inputs and outputs\n* Hidden layer configuration\n* Sensor and actuator specifications\n* Substrate and connection patterns","ref":"Bardo.Core.html#create_morphology/1"},{"type":"function","title":"Parameters - Bardo.Core.create_morphology/1","doc":"* `opts` - A map of options for the morphology (see options below)","ref":"Bardo.Core.html#create_morphology/1-parameters"},{"type":"function","title":"Options - Bardo.Core.create_morphology/1","doc":"* `:name` - The name of the morphology (default: \"Generic Morphology\")\n  * `:description` - A description of the morphology\n  * `:dimensions` - Number of dimensions in the substrate (default: 2)\n  * `:inputs` - Number of input neurons (default: 1)\n  * `:outputs` - Number of output neurons (default: 1)\n  * `:hidden_layers` - List of hidden layer sizes (default: [3])\n  * `:activation_functions` - List of activation functions (default: [:sigmoid])\n  * `:substrate_type` - Type of substrate, one of: [:cartesian, :hypercube, :hypersphere, :custom] (default: :cartesian)\n  * `:connection_pattern` - Type of connection pattern, one of: [:feedforward, :recurrent, :dense, :custom] (default: :feedforward)\n  * `:plasticity` - Type of plasticity, one of: [:none, :hebbian, :stdp, :abcn, :iterative] (default: :none)\n  * `:sensors` - List of custom sensor specifications\n  * `:actuators` - List of custom actuator specifications\n  * `:parameters` - Additional parameters for the morphology","ref":"Bardo.Core.html#create_morphology/1-options"},{"type":"function","title":"Returns - Bardo.Core.create_morphology/1","doc":"* A morphology map with the specified configuration","ref":"Bardo.Core.html#create_morphology/1-returns"},{"type":"function","title":"Examples - Bardo.Core.create_morphology/1","doc":"# Create a simple XOR network morphology\n    morphology = Bardo.Core.create_morphology(%{\n      name: \"XOR Network\",\n      dimensions: 2,\n      inputs: 2,\n      outputs: 1,\n      hidden_layers: [3]\n    })","ref":"Bardo.Core.html#create_morphology/1-examples"},{"type":"function","title":"Bardo.Core.create_population/2","doc":"Creates a new population of neural network agents.","ref":"Bardo.Core.html#create_population/2"},{"type":"function","title":"Parameters - Bardo.Core.create_population/2","doc":"* `population_id` - Unique identifier for the population\n  * `config` - Configuration for the population","ref":"Bardo.Core.html#create_population/2-parameters"},{"type":"function","title":"Returns - Bardo.Core.create_population/2","doc":"* `{:ok, pid}` - If the population was created successfully\n  * `{:error, reason}` - If there was an error creating the population","ref":"Bardo.Core.html#create_population/2-returns"},{"type":"function","title":"Examples - Bardo.Core.create_population/2","doc":"{:ok, pid} = Bardo.Core.create_population(\"xor_population\", %{\n      morphology: morphology,\n      population_size: 50,\n      fitness_function: fn agent -> ... end\n    })","ref":"Bardo.Core.html#create_population/2-examples"},{"type":"function","title":"Bardo.Core.create_scape/2","doc":"Creates a new scape (virtual environment) for agents to interact with.","ref":"Bardo.Core.html#create_scape/2"},{"type":"function","title":"Parameters - Bardo.Core.create_scape/2","doc":"* `scape_id` - Unique identifier for the scape\n  * `config` - Configuration for the scape","ref":"Bardo.Core.html#create_scape/2-parameters"},{"type":"function","title":"Returns - Bardo.Core.create_scape/2","doc":"* `{:ok, pid}` - If the scape was created successfully\n  * `{:error, reason}` - If there was an error creating the scape","ref":"Bardo.Core.html#create_scape/2-returns"},{"type":"function","title":"Examples - Bardo.Core.create_scape/2","doc":"{:ok, pid} = Bardo.Core.create_scape(\"flatland\", %{\n      width: 100,\n      height: 100,\n      agents: 10\n    })","ref":"Bardo.Core.html#create_scape/2-examples"},{"type":"function","title":"Bardo.Core.evaluate_agent/2","doc":"Evaluates an agent's performance on a set of test cases.\n\nThis function runs the agent on multiple input/output pairs and returns\nan accuracy score between 0.0 and 1.0.","ref":"Bardo.Core.html#evaluate_agent/2"},{"type":"function","title":"Parameters - Bardo.Core.evaluate_agent/2","doc":"* `agent` - The agent (neural network) to evaluate\n  * `test_cases` - List of {input, expected_output} tuples","ref":"Bardo.Core.html#evaluate_agent/2-parameters"},{"type":"function","title":"Returns - Bardo.Core.evaluate_agent/2","doc":"* Accuracy score between 0.0 and 1.0","ref":"Bardo.Core.html#evaluate_agent/2-returns"},{"type":"function","title":"Examples - Bardo.Core.evaluate_agent/2","doc":"# Evaluate XOR test cases\n    test_cases = [\n      {[0.0, 0.0], [0.0]},\n      {[0.0, 1.0], [1.0]},\n      {[1.0, 0.0], [1.0]},\n      {[1.0, 1.0], [0.0]}\n    ]\n    \n    accuracy = Bardo.Core.evaluate_agent(agent, test_cases)\n    # A perfect XOR network would return 1.0","ref":"Bardo.Core.html#evaluate_agent/2-examples"},{"type":"function","title":"Bardo.Core.evolve_population/2","doc":"Evolves a population for the specified number of generations.","ref":"Bardo.Core.html#evolve_population/2"},{"type":"function","title":"Parameters - Bardo.Core.evolve_population/2","doc":"* `population_id` - ID of the population to evolve\n  * `generations` - Number of generations to evolve","ref":"Bardo.Core.html#evolve_population/2-parameters"},{"type":"function","title":"Returns - Bardo.Core.evolve_population/2","doc":"* `:ok` - If the population was evolved successfully\n  * `{:error, reason}` - If there was an error evolving the population","ref":"Bardo.Core.html#evolve_population/2-returns"},{"type":"function","title":"Examples - Bardo.Core.evolve_population/2","doc":":ok = Bardo.Core.evolve_population(\"xor_population\", 50)","ref":"Bardo.Core.html#evolve_population/2-examples"},{"type":"function","title":"Bardo.Core.experiment_status/1","doc":"Gets the status of an experiment.","ref":"Bardo.Core.html#experiment_status/1"},{"type":"function","title":"Parameters - Bardo.Core.experiment_status/1","doc":"* `experiment_id` - ID of the experiment to get status for","ref":"Bardo.Core.html#experiment_status/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.experiment_status/1","doc":"* `{:not_started, info}` - If the experiment has not started yet\n  * `{:in_progress, info}` - If the experiment is in progress, with status details\n  * `{:completed, info}` - If the experiment is completed, with results\n  * `{:stopped, info}` - If the experiment was stopped before completion\n  * `{:error, reason}` - If there was an error getting the status","ref":"Bardo.Core.html#experiment_status/1-returns"},{"type":"function","title":"Examples - Bardo.Core.experiment_status/1","doc":"# Check experiment status\n    Bardo.Core.experiment_status(experiment_id)","ref":"Bardo.Core.html#experiment_status/1-examples"},{"type":"function","title":"Bardo.Core.export_results/3","doc":"Exports experiment results to a file.","ref":"Bardo.Core.html#export_results/3"},{"type":"function","title":"Parameters - Bardo.Core.export_results/3","doc":"* `experiment_id` - ID of the experiment to export\n  * `file_path` - Path to save the results to\n  * `format` - Format to export in (:csv, :json, or :binary)","ref":"Bardo.Core.html#export_results/3-parameters"},{"type":"function","title":"Returns - Bardo.Core.export_results/3","doc":"* `:ok` - If the results were exported successfully\n  * `{:error, reason}` - If there was an error exporting the results","ref":"Bardo.Core.html#export_results/3-returns"},{"type":"function","title":"Examples - Bardo.Core.export_results/3","doc":":ok = Bardo.Core.export_results(experiment_id, \"results.json\", :json)","ref":"Bardo.Core.html#export_results/3-examples"},{"type":"function","title":"Bardo.Core.get_best_agent/1","doc":"Gets the best agent from a population.","ref":"Bardo.Core.html#get_best_agent/1"},{"type":"function","title":"Parameters - Bardo.Core.get_best_agent/1","doc":"* `population_id` - ID of the population","ref":"Bardo.Core.html#get_best_agent/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.get_best_agent/1","doc":"* `{:ok, agent}` - The best agent in the population\n  * `{:error, reason}` - If there was an error getting the agent","ref":"Bardo.Core.html#get_best_agent/1-returns"},{"type":"function","title":"Examples - Bardo.Core.get_best_agent/1","doc":"{:ok, best_agent} = Bardo.Core.get_best_agent(\"xor_population\")","ref":"Bardo.Core.html#get_best_agent/1-examples"},{"type":"function","title":"Bardo.Core.get_best_solution/1","doc":"Gets the best solution from a completed experiment.","ref":"Bardo.Core.html#get_best_solution/1"},{"type":"function","title":"Parameters - Bardo.Core.get_best_solution/1","doc":"* `experiment_id` - ID of the experiment to get the best solution from","ref":"Bardo.Core.html#get_best_solution/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.get_best_solution/1","doc":"* `{:ok, solution}` - Best solution found in the experiment\n  * `{:error, reason}` - If there was an error getting the best solution","ref":"Bardo.Core.html#get_best_solution/1-returns"},{"type":"function","title":"Examples - Bardo.Core.get_best_solution/1","doc":"{:ok, solution} = Bardo.Core.get_best_solution(experiment_id)\n    # Use the solution for inference\n    output = Bardo.Core.activate_agent(solution, [0.5, 0.5])","ref":"Bardo.Core.html#get_best_solution/1-examples"},{"type":"function","title":"Bardo.Core.list_experiments/0","doc":"Lists all experiments.","ref":"Bardo.Core.html#list_experiments/0"},{"type":"function","title":"Returns - Bardo.Core.list_experiments/0","doc":"* `{:ok, [experiment]}` - List of all experiments with their basic information\n  * `{:error, reason}` - If there was an error getting the experiments","ref":"Bardo.Core.html#list_experiments/0-returns"},{"type":"function","title":"Examples - Bardo.Core.list_experiments/0","doc":"# Get all experiments\n    Bardo.Core.list_experiments()","ref":"Bardo.Core.html#list_experiments/0-examples"},{"type":"function","title":"Bardo.Core.list_morphologies/0","doc":"Lists all saved morphologies.","ref":"Bardo.Core.html#list_morphologies/0"},{"type":"function","title":"Returns - Bardo.Core.list_morphologies/0","doc":"* `{:ok, [morphology]}` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Core.html#list_morphologies/0-returns"},{"type":"function","title":"Examples - Bardo.Core.list_morphologies/0","doc":"{:ok, morphologies} = Bardo.Core.list_morphologies()","ref":"Bardo.Core.html#list_morphologies/0-examples"},{"type":"function","title":"Bardo.Core.load_agent/1","doc":"Loads an agent from a file.","ref":"Bardo.Core.html#load_agent/1"},{"type":"function","title":"Parameters - Bardo.Core.load_agent/1","doc":"* `file_path` - Path to load the agent from","ref":"Bardo.Core.html#load_agent/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.load_agent/1","doc":"* `{:ok, agent}` - If the agent was loaded successfully\n  * `{:error, reason}` - If there was an error loading the agent","ref":"Bardo.Core.html#load_agent/1-returns"},{"type":"function","title":"Examples - Bardo.Core.load_agent/1","doc":"{:ok, agent} = Bardo.Core.load_agent(\"xor_agent.bin\")","ref":"Bardo.Core.html#load_agent/1-examples"},{"type":"function","title":"Bardo.Core.load_morphology/1","doc":"Loads a morphology from persistent storage.","ref":"Bardo.Core.html#load_morphology/1"},{"type":"function","title":"Parameters - Bardo.Core.load_morphology/1","doc":"* `id` - The ID of the morphology to load","ref":"Bardo.Core.html#load_morphology/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.load_morphology/1","doc":"* `{:ok, morphology}` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Core.html#load_morphology/1-returns"},{"type":"function","title":"Examples - Bardo.Core.load_morphology/1","doc":"Bardo.Core.load_morphology(\"morph_123456789\")","ref":"Bardo.Core.html#load_morphology/1-examples"},{"type":"function","title":"Bardo.Core.quick_experiment/4","doc":"Runs a complete experiment with minimal setup.\n\nThis is a convenience function that creates an experiment, sets it up,\nand runs it with common default parameters.","ref":"Bardo.Core.html#quick_experiment/4"},{"type":"function","title":"Parameters - Bardo.Core.quick_experiment/4","doc":"* `name` - Name of the experiment\n  * `morphology` - The morphology to use\n  * `fitness_function` - Function to evaluate fitness\n  * `opts` - Additional options to override defaults","ref":"Bardo.Core.html#quick_experiment/4-parameters"},{"type":"function","title":"Returns - Bardo.Core.quick_experiment/4","doc":"* `{:ok, experiment_id}` - ID of the created experiment\n  * `{:error, reason}` - If there was an error","ref":"Bardo.Core.html#quick_experiment/4-returns"},{"type":"function","title":"Examples - Bardo.Core.quick_experiment/4","doc":"# Create and run an XOR experiment\n    {:ok, experiment_id} = Bardo.Core.quick_experiment(\n      \"XOR Experiment\",\n      morphology,\n      fn agent -> \n        # Fitness function implementation\n      end,\n      %{population_size: 100, generations: 50}\n    )","ref":"Bardo.Core.html#quick_experiment/4-examples"},{"type":"function","title":"Bardo.Core.run_experiment/1","doc":"Starts an experiment with the given ID.\n\nThis begins the evolutionary process according to the experiment configuration.\nThe function returns immediately, but the experiment continues to run in the\nbackground until completion.","ref":"Bardo.Core.html#run_experiment/1"},{"type":"function","title":"Parameters - Bardo.Core.run_experiment/1","doc":"* `experiment_id` - ID of the experiment to start","ref":"Bardo.Core.html#run_experiment/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.run_experiment/1","doc":"* `:ok` - If the experiment was started successfully\n  * `{:error, reason}` - If there was an error starting the experiment","ref":"Bardo.Core.html#run_experiment/1-returns"},{"type":"function","title":"Examples - Bardo.Core.run_experiment/1","doc":":ok = Bardo.Core.run_experiment(experiment_id)","ref":"Bardo.Core.html#run_experiment/1-examples"},{"type":"function","title":"Bardo.Core.save_agent/2","doc":"Saves an agent to a file for later use.","ref":"Bardo.Core.html#save_agent/2"},{"type":"function","title":"Parameters - Bardo.Core.save_agent/2","doc":"* `agent` - The agent (neural network) to save\n  * `file_path` - Path to save the agent to","ref":"Bardo.Core.html#save_agent/2-parameters"},{"type":"function","title":"Returns - Bardo.Core.save_agent/2","doc":"* `:ok` - If the agent was saved successfully\n  * `{:error, reason}` - If there was an error saving the agent","ref":"Bardo.Core.html#save_agent/2-returns"},{"type":"function","title":"Examples - Bardo.Core.save_agent/2","doc":":ok = Bardo.Core.save_agent(agent, \"xor_agent.bin\")","ref":"Bardo.Core.html#save_agent/2-examples"},{"type":"function","title":"Bardo.Core.save_morphology/1","doc":"Saves a morphology to persistent storage for later use.","ref":"Bardo.Core.html#save_morphology/1"},{"type":"function","title":"Parameters - Bardo.Core.save_morphology/1","doc":"* `morphology` - The morphology to save","ref":"Bardo.Core.html#save_morphology/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.save_morphology/1","doc":"* `:ok` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Core.html#save_morphology/1-returns"},{"type":"function","title":"Examples - Bardo.Core.save_morphology/1","doc":"morphology = Bardo.Core.create_morphology(%{name: \"XOR\"})\n    Bardo.Core.save_morphology(morphology)","ref":"Bardo.Core.html#save_morphology/1-examples"},{"type":"function","title":"Bardo.Core.set_fitness_function/2","doc":"Sets the fitness function for evaluating solutions in an experiment.\n\nThe fitness function receives an agent (neural network) and must return a numerical\nfitness score. Higher values indicate better fitness.","ref":"Bardo.Core.html#set_fitness_function/2"},{"type":"function","title":"Parameters - Bardo.Core.set_fitness_function/2","doc":"* `experiment_id` - ID of the experiment\n  * `fitness_function` - Function to evaluate fitness of solutions","ref":"Bardo.Core.html#set_fitness_function/2-parameters"},{"type":"function","title":"Returns - Bardo.Core.set_fitness_function/2","doc":"* `:ok` - If the fitness function was set successfully\n  * `{:error, reason}` - If there was an error setting the fitness function","ref":"Bardo.Core.html#set_fitness_function/2-returns"},{"type":"function","title":"Examples - Bardo.Core.set_fitness_function/2","doc":"# Define a fitness function for XOR\n    fitness_fn = fn agent ->\n      inputs = [[0,0], [0,1], [1,0], [1,1]]\n      expected = [[0], [1], [1], [0]]\n      \n      # Calculate error across all cases\n      errors = Enum.zip(inputs, expected)\n      |> Enum.map(fn {input, output} ->\n        actual = Bardo.Core.activate_agent(agent, input)\n        Enum.zip(actual, output)\n        |> Enum.map(fn {a, e} -> :math.pow(a - e, 2) end)\n        |> Enum.sum()\n      end)\n      \n      # Return fitness (1 / (1 + error)) so higher is better\n      1.0 / (1.0 + Enum.sum(errors))\n    end\n    \n    :ok = Bardo.Core.set_fitness_function(experiment_id, fitness_fn)","ref":"Bardo.Core.html#set_fitness_function/2-examples"},{"type":"function","title":"Bardo.Core.solve_xor/1","doc":"Solves the XOR problem as a simple demonstration.\n\nThis is a convenience function that creates and runs an experiment\nto solve the XOR problem, a classic benchmark in neural networks.","ref":"Bardo.Core.html#solve_xor/1"},{"type":"function","title":"Parameters - Bardo.Core.solve_xor/1","doc":"* `opts` - Options to override defaults","ref":"Bardo.Core.html#solve_xor/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.solve_xor/1","doc":"* `{:ok, agent}` - The best solution found\n  * `{:error, reason}` - If there was an error","ref":"Bardo.Core.html#solve_xor/1-returns"},{"type":"function","title":"Examples - Bardo.Core.solve_xor/1","doc":"{:ok, xor_agent} = Bardo.Core.solve_xor()\n    outputs = Bardo.Core.activate_agent(xor_agent, [1.0, 0.0])\n    # Should return approximately [1.0]","ref":"Bardo.Core.html#solve_xor/1-examples"},{"type":"function","title":"Bardo.Core.step_scape/2","doc":"Steps a scape forward in time, updating all agents.","ref":"Bardo.Core.html#step_scape/2"},{"type":"function","title":"Parameters - Bardo.Core.step_scape/2","doc":"* `scape_id` - ID of the scape\n  * `steps` - Number of time steps to advance","ref":"Bardo.Core.html#step_scape/2-parameters"},{"type":"function","title":"Returns - Bardo.Core.step_scape/2","doc":"* `:ok` - If the scape was stepped successfully\n  * `{:error, reason}` - If there was an error stepping the scape","ref":"Bardo.Core.html#step_scape/2-returns"},{"type":"function","title":"Examples - Bardo.Core.step_scape/2","doc":":ok = Bardo.Core.step_scape(\"flatland\", 10)","ref":"Bardo.Core.html#step_scape/2-examples"},{"type":"function","title":"Bardo.Core.stop_experiment/1","doc":"Stops an ongoing experiment.","ref":"Bardo.Core.html#stop_experiment/1"},{"type":"function","title":"Parameters - Bardo.Core.stop_experiment/1","doc":"* `experiment_id` - ID of the experiment to stop","ref":"Bardo.Core.html#stop_experiment/1-parameters"},{"type":"function","title":"Returns - Bardo.Core.stop_experiment/1","doc":"* `:ok` - If the experiment was stopped successfully\n  * `{:error, reason}` - If there was an error stopping the experiment","ref":"Bardo.Core.html#stop_experiment/1-returns"},{"type":"function","title":"Examples - Bardo.Core.stop_experiment/1","doc":":ok = Bardo.Core.stop_experiment(experiment_id)","ref":"Bardo.Core.html#stop_experiment/1-examples"},{"type":"module","title":"Bardo.DBETS","doc":"ETS-based implementation of the DB module for testing.\nThis replaces the RocksDB-based implementation with a simple in-memory ETS table.","ref":"Bardo.DBETS.html"},{"type":"function","title":"Bardo.DBETS.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.DBETS.html#child_spec/1"},{"type":"function","title":"Bardo.DBETS.delete/2","doc":"","ref":"Bardo.DBETS.html#delete/2"},{"type":"function","title":"Bardo.DBETS.init/1","doc":"Callback implementation for  GenServer.init/1 .","ref":"Bardo.DBETS.html#init/1"},{"type":"function","title":"Bardo.DBETS.read/2","doc":"","ref":"Bardo.DBETS.html#read/2"},{"type":"function","title":"Bardo.DBETS.start_link/1","doc":"","ref":"Bardo.DBETS.html#start_link/1"},{"type":"function","title":"Bardo.DBETS.write/3","doc":"","ref":"Bardo.DBETS.html#write/3"},{"type":"module","title":"Bardo.DBInterface","doc":"Database interface for Bardo.\n\nThis module provides a wrapper around the configured database adapter,\nallowing for seamless switching between different storage backends.","ref":"Bardo.DBInterface.html"},{"type":"module","title":"Usage - Bardo.DBInterface","doc":"In your code, instead of directly calling `Bardo.DB` or `Bardo.DBPostgres`,\nuse this module, which will automatically route calls to the configured adapter:\n\n```elixir\n# Read a value\nvalue = Bardo.DBInterface.read(id, :experiment)\n\n# Write a value\n:ok = Bardo.DBInterface.write(value, :experiment)\n```","ref":"Bardo.DBInterface.html#module-usage"},{"type":"module","title":"Configuration - Bardo.DBInterface","doc":"In your config/config.exs:\n\n```elixir\n# For ETS storage:\nconfig :bardo, :db, adapter: Bardo.DB\n\n# For PostgreSQL storage:\nconfig :bardo, :db, adapter: Bardo.DBPostgres\n```","ref":"Bardo.DBInterface.html#module-configuration"},{"type":"function","title":"Bardo.DBInterface.adapter/0","doc":"Get the configured database adapter.","ref":"Bardo.DBInterface.html#adapter/0"},{"type":"function","title":"Bardo.DBInterface.backup/1","doc":"Create a backup of the database.","ref":"Bardo.DBInterface.html#backup/1"},{"type":"function","title":"Parameters - Bardo.DBInterface.backup/1","doc":"- backup_path: Directory to store the backup (default: \"backups\")","ref":"Bardo.DBInterface.html#backup/1-parameters"},{"type":"function","title":"Returns - Bardo.DBInterface.backup/1","doc":"{:ok, backup_file} on success, {:error, reason} on failure.","ref":"Bardo.DBInterface.html#backup/1-returns"},{"type":"function","title":"Bardo.DBInterface.delete/2","doc":"Delete a value from the database.","ref":"Bardo.DBInterface.html#delete/2"},{"type":"function","title":"Parameters - Bardo.DBInterface.delete/2","doc":"- id: Unique identifier for the data\n- type: Type of data to delete (e.g., :experiment, :population, :genotype)","ref":"Bardo.DBInterface.html#delete/2-parameters"},{"type":"function","title":"Returns - Bardo.DBInterface.delete/2","doc":":ok on success, {:error, reason} on failure.","ref":"Bardo.DBInterface.html#delete/2-returns"},{"type":"function","title":"Bardo.DBInterface.fetch/2","doc":"Fetch a value from the database.","ref":"Bardo.DBInterface.html#fetch/2"},{"type":"function","title":"Parameters - Bardo.DBInterface.fetch/2","doc":"- id: Unique identifier for the data\n- type: Type of data to read (e.g., :experiment, :population, :genotype)","ref":"Bardo.DBInterface.html#fetch/2-parameters"},{"type":"function","title":"Returns - Bardo.DBInterface.fetch/2","doc":"{:ok, value} on success, {:error, reason} on failure.","ref":"Bardo.DBInterface.html#fetch/2-returns"},{"type":"function","title":"Bardo.DBInterface.list/1","doc":"List all values of a given type.","ref":"Bardo.DBInterface.html#list/1"},{"type":"function","title":"Parameters - Bardo.DBInterface.list/1","doc":"- type: Type of data to list (e.g., :experiment, :population, :genotype)","ref":"Bardo.DBInterface.html#list/1-parameters"},{"type":"function","title":"Returns - Bardo.DBInterface.list/1","doc":"List of values on success, [] on failure.","ref":"Bardo.DBInterface.html#list/1-returns"},{"type":"function","title":"Bardo.DBInterface.read/2","doc":"Read a value from the database.","ref":"Bardo.DBInterface.html#read/2"},{"type":"function","title":"Parameters - Bardo.DBInterface.read/2","doc":"- id: Unique identifier for the data\n- type: Type of data to read (e.g., :experiment, :population, :genotype)","ref":"Bardo.DBInterface.html#read/2-parameters"},{"type":"function","title":"Returns - Bardo.DBInterface.read/2","doc":"The value if found, nil otherwise.","ref":"Bardo.DBInterface.html#read/2-returns"},{"type":"function","title":"Bardo.DBInterface.store/3","doc":"Store a value in the database.","ref":"Bardo.DBInterface.html#store/3"},{"type":"function","title":"Parameters - Bardo.DBInterface.store/3","doc":"- type: Type of data being stored (e.g., :experiment, :population, :genotype)\n- id: Unique identifier for the data\n- value: The data to store","ref":"Bardo.DBInterface.html#store/3-parameters"},{"type":"function","title":"Returns - Bardo.DBInterface.store/3","doc":":ok on success, {:error, reason} on failure.","ref":"Bardo.DBInterface.html#store/3-returns"},{"type":"function","title":"Bardo.DBInterface.write/2","doc":"Write a value to the database.","ref":"Bardo.DBInterface.html#write/2"},{"type":"function","title":"Parameters - Bardo.DBInterface.write/2","doc":"- value: The value to store (must have an :id field in its data map)\n- table: The table/type to write to","ref":"Bardo.DBInterface.html#write/2-parameters"},{"type":"function","title":"Returns - Bardo.DBInterface.write/2","doc":":ok on success, {:error, reason} on failure.","ref":"Bardo.DBInterface.html#write/2-returns"},{"type":"module","title":"Bardo.Examples.Applications.Flatland","doc":"Main setup module for the Flatland experiment.\n\nThis module provides functions to configure and run\nFlatland simulations with evolving predator and prey agents.","ref":"Bardo.Examples.Applications.Flatland.html"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.configure/6","doc":"Configure a basic Flatland experiment with predator and prey.\n\nParameters:\n- experiment_id: Unique identifier for the experiment\n- predator_population_size: Number of predator agents\n- prey_population_size: Number of prey agents\n- plant_quantity: Number of plants in the environment\n- simulation_steps: Number of simulation steps per evaluation\n- generations: Number of generations to evolve (defaults to 50)\n\nReturns the experiment configuration map.","ref":"Bardo.Examples.Applications.Flatland.html#configure/6"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.run/6","doc":"Run a Flatland experiment with the given configuration.\n\nParameters:\n- experiment_id: Unique identifier for the experiment\n- predator_population_size: Number of predator agents (default: 20)\n- prey_population_size: Number of prey agents (default: 20)\n- plant_quantity: Number of plants in the environment (default: 40)\n- simulation_steps: Number of simulation steps per evaluation (default: 1000)\n- generations: Number of generations to evolve (default: 50)\n\nReturns :ok if the experiment was started successfully.","ref":"Bardo.Examples.Applications.Flatland.html#run/6"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.visualize/1","doc":"Load and visualize the best agents from a completed Flatland experiment.\n\nParameters:\n- experiment_id: ID of the completed experiment\n\nReturns :ok if visualization was started successfully.","ref":"Bardo.Examples.Applications.Flatland.html#visualize/1"},{"type":"module","title":"Bardo.Examples.Applications.Flatland.Flatland","doc":"Flatland simulation environment.\n\nThis module implements a 2D world where predators and prey interact.\nIt behaves as a sector in the Bardo scape system.","ref":"Bardo.Examples.Applications.Flatland.Flatland.html"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Flatland.actuate/3","doc":"Handles an actuator operation from an agent.","ref":"Bardo.Examples.Applications.Flatland.Flatland.html#actuate/3"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Flatland.enter/3","doc":"Handles a new agent entering the Flatland environment.","ref":"Bardo.Examples.Applications.Flatland.Flatland.html#enter/3"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Flatland.init/2","doc":"Initializes the Flatland sector with the given parameters.","ref":"Bardo.Examples.Applications.Flatland.Flatland.html#init/2"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Flatland.leave/3","doc":"Handles an agent leaving the Flatland environment.","ref":"Bardo.Examples.Applications.Flatland.Flatland.html#leave/3"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Flatland.sense/3","doc":"Handles a sensor operation from an agent.","ref":"Bardo.Examples.Applications.Flatland.Flatland.html#sense/3"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Flatland.step/2","doc":"Handles the step operation for the Flatland environment.","ref":"Bardo.Examples.Applications.Flatland.Flatland.html#step/2"},{"type":"module","title":"Bardo.Examples.Applications.Flatland.Flatland.Avatar","doc":"Represents an entity in the Flatland world","ref":"Bardo.Examples.Applications.Flatland.Flatland.Avatar.html"},{"type":"module","title":"Bardo.Examples.Applications.Flatland.FlatlandActuator","doc":"Actuator implementation for the Flatland simulation.\n\nThis module provides actuators that agents can use to interact\nwith the Flatland environment, primarily for movement control.","ref":"Bardo.Examples.Applications.Flatland.FlatlandActuator.html"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandActuator.actuate/2","doc":"Handle a list of incoming signals from the neural network.\n\nThis function:\n1. Activates the actuator with signals from the neural network\n2. Sends commands to the scape (simulated world)\n3. Processes responses (fitness, etc.)","ref":"Bardo.Examples.Applications.Flatland.FlatlandActuator.html#actuate/2"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandActuator.handle/2","doc":"","ref":"Bardo.Examples.Applications.Flatland.FlatlandActuator.html#handle/2"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandActuator.init/1","doc":"Initialize a new actuator for Flatland.\n\nParameters:\n- id: Actuator ID\n- actuator_type: :two_wheels\n- fanin: Number of input elements\n- cortex_pid: PID of the cortex process\n- scape_pid: PID of the scape process\n- agent_id: ID of the agent","ref":"Bardo.Examples.Applications.Flatland.FlatlandActuator.html#init/1"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandActuator.init/6","doc":"","ref":"Bardo.Examples.Applications.Flatland.FlatlandActuator.html#init/6"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandActuator.two_wheels/4","doc":"Create a two-wheel actuator configuration.\n\nParameters:\n- id: Actuator ID\n- fanin: Number of input elements from the neural network\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns an actuator specification map.","ref":"Bardo.Examples.Applications.Flatland.FlatlandActuator.html#two_wheels/4"},{"type":"module","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor","doc":"Sensor implementation for the Flatland simulation.\n\nThis module provides sensors that agents can use to perceive\nthe Flatland environment, including vision, smell, and energy sensors.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.color_scanner/5","doc":"Create a color scanner sensor configuration.\n\nParameters:\n- id: Sensor ID\n- n: Number of rays (angles) to scan\n- fanout: Number of output elements\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns a sensor specification map.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#color_scanner/5"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.distance_scanner/5","doc":"Create a distance scanner sensor configuration.\n\nParameters:\n- id: Sensor ID\n- n: Number of rays (angles) to scan\n- fanout: Number of output elements\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns a sensor specification map.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#distance_scanner/5"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.energy/3","doc":"Creates an energy sensor configuration.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#energy/3"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Flatland.FlatlandSensor.energy/3","doc":"* `resolution` - The number of energy level ranges to detect\n  * `cortex_id` - The ID of the cortex this sensor is connected to\n  * `scape_name` - The name of the scape this sensor will read from","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#energy/3-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Flatland.FlatlandSensor.energy/3","doc":"* A sensor specification map","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#energy/3-returns"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.init/1","doc":"Initialize the sensor with provided parameters.\n\nRequired by the Sensor behavior.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#init/1"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.init/7","doc":"Initialize a new sensor for Flatland (deprecated version).\n\nThis function is kept for backward compatibility.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#init/7"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.percept/2","doc":"Process sensor data to generate output signals.\n\nRequired by the Sensor behavior.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#percept/2"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.read/1","doc":"Read data from the sensor.\n\nThis function sends a sensing request to the scape and processes the response.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#read/1"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.sense/2","doc":"Sense the environment for the agent.\n\nRequired by the Sensor behavior.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#sense/2"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.smell/4","doc":"Creates a smell sensor configuration.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#smell/4"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Flatland.FlatlandSensor.smell/4","doc":"* `radius` - The radius of the smell detection area\n  * `types` - The number of different object types to detect\n  * `cortex_id` - The ID of the cortex this sensor is connected to\n  * `scape_name` - The name of the scape this sensor will read from","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#smell/4-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Flatland.FlatlandSensor.smell/4","doc":"* A sensor specification map","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#smell/4-returns"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.terminate/2","doc":"Terminate the sensor gracefully.\n\nCalled when the sensor is being stopped.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#terminate/2"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandSensor.vision/4","doc":"Creates a vision sensor configuration.","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#vision/4"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Flatland.FlatlandSensor.vision/4","doc":"* `angle_count` - The number of different angles to look in\n  * `range` - The maximum vision range\n  * `cortex_id` - The ID of the cortex this sensor is connected to\n  * `scape_name` - The name of the scape this sensor will read from","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#vision/4-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Flatland.FlatlandSensor.vision/4","doc":"* A sensor specification map","ref":"Bardo.Examples.Applications.Flatland.FlatlandSensor.html#vision/4-returns"},{"type":"module","title":"Bardo.Examples.Applications.Flatland.FlatlandUtils","doc":"Utility functions for the Flatland simulation.\n\nThis module provides utility functions for creating and managing the Flatland\nenvironment, including world creation, agent placement, and ray-object\nintersections for sensor calculations.","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandUtils.create_world/2","doc":"Creates a new Flatland world with the specified dimensions.","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#create_world/2"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Flatland.FlatlandUtils.create_world/2","doc":"* `width` - The width of the world\n  * `height` - The height of the world","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#create_world/2-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Flatland.FlatlandUtils.create_world/2","doc":"* A map representing the Flatland world with plants, predators, and prey","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#create_world/2-returns"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandUtils.normalize_vector/1","doc":"Normalizes a vector to a unit vector.","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#normalize_vector/1"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandUtils.object_color_value/1","doc":"Maps object type to color value.\n\nReturns:\n- -0.5 for plants (green)\n- 0.0 for prey (blue)\n- 0.5 for predators (red)","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#object_color_value/1"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandUtils.place_agents_randomly/3","doc":"Places a specified number of predators and prey randomly in the world.","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#place_agents_randomly/3"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Flatland.FlatlandUtils.place_agents_randomly/3","doc":"* `world` - The world map\n  * `predator_count` - The number of predators to place\n  * `prey_count` - The number of prey to place","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#place_agents_randomly/3-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Flatland.FlatlandUtils.place_agents_randomly/3","doc":"* The updated world map with predators and prey","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#place_agents_randomly/3-returns"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandUtils.place_plants_randomly/2","doc":"Places a specified number of plants randomly in the world.","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#place_plants_randomly/2"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Flatland.FlatlandUtils.place_plants_randomly/2","doc":"* `world` - The world map\n  * `plant_count` - The number of plants to place","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#place_plants_randomly/2-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Flatland.FlatlandUtils.place_plants_randomly/2","doc":"* The updated world map with plants","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#place_plants_randomly/2-returns"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandUtils.shortest_intr_line/3","doc":"Calculates the shortest intersection line between a ray and a circular object.\n\nParameters:\n- ray_origin: {x, y} coordinates of ray origin\n- ray_dir: {dx, dy} ray direction vector\n- object: {x, y, r} object position and radius\n\nReturns:\n- :no_intersection if there is no intersection\n- distance to the intersection point\n\nThis function is a direct port of the Erlang implementation, which uses\nvector math to calculate ray-circle intersections.","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#shortest_intr_line/3"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.FlatlandUtils.world_boundary_intersection/4","doc":"Calculates the intersection of a ray with the boundary of a rectangular world.\n\nThis is useful for determining how far a ray can travel before hitting a wall,\nwhich is important for sensors that need to detect world boundaries.","ref":"Bardo.Examples.Applications.Flatland.FlatlandUtils.html#world_boundary_intersection/4"},{"type":"module","title":"Bardo.Examples.Applications.Flatland.Predator","doc":"Predator morphology for the Flatland simulation.\n\nThis module defines the neural architecture and sensors/actuators\nfor predator agents in the Flatland environment.","ref":"Bardo.Examples.Applications.Flatland.Predator.html"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Predator.actuators/0","doc":"List of actuators available to the predator agent.","ref":"Bardo.Examples.Applications.Flatland.Predator.html#actuators/0"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Predator.get_phys_config/3","doc":"Initialize the predator morphology.\n\nReturns the sensor and actuator configuration for predator agents.","ref":"Bardo.Examples.Applications.Flatland.Predator.html#get_phys_config/3"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Predator.get_scape_params/4","doc":"Get the parameters required to enter the scape.\n\nFor predator agents, we specify the type as :predator.","ref":"Bardo.Examples.Applications.Flatland.Predator.html#get_scape_params/4"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Predator.neuron_pattern/4","doc":"Generate the initial neuron patterns for the predator.\n\nReturns a template for the neural network architecture.","ref":"Bardo.Examples.Applications.Flatland.Predator.html#neuron_pattern/4"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Predator.sensors/0","doc":"List of sensors available to the predator agent.","ref":"Bardo.Examples.Applications.Flatland.Predator.html#sensors/0"},{"type":"module","title":"Bardo.Examples.Applications.Flatland.Prey","doc":"Prey morphology for the Flatland simulation.\n\nThis module defines the neural architecture and sensors/actuators\nfor prey agents in the Flatland environment.","ref":"Bardo.Examples.Applications.Flatland.Prey.html"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Prey.actuators/0","doc":"Returns a list of actuators for the prey agents.\n\nRequired by the Morphology behaviour.","ref":"Bardo.Examples.Applications.Flatland.Prey.html#actuators/0"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Prey.get_phys_config/3","doc":"Initialize the prey morphology.\n\nReturns the sensor and actuator configuration for prey agents.","ref":"Bardo.Examples.Applications.Flatland.Prey.html#get_phys_config/3"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Prey.get_scape_params/4","doc":"Get the parameters required to enter the scape.\n\nFor prey agents, we specify the type as :prey.","ref":"Bardo.Examples.Applications.Flatland.Prey.html#get_scape_params/4"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Prey.neuron_pattern/4","doc":"Generate the initial neuron patterns for the prey.\n\nReturns a template for the neural network architecture.","ref":"Bardo.Examples.Applications.Flatland.Prey.html#neuron_pattern/4"},{"type":"function","title":"Bardo.Examples.Applications.Flatland.Prey.sensors/0","doc":"Returns a list of sensors for the prey agents.\n\nRequired by the Morphology behaviour.","ref":"Bardo.Examples.Applications.Flatland.Prey.html#sensors/0"},{"type":"module","title":"Bardo.Examples.Applications.Fx","doc":"Main setup module for the Forex (FX) trading experiment.\n\nThis module provides functions to configure and run\nFX trading simulations using neuroevolution to optimize trading strategies.","ref":"Bardo.Examples.Applications.Fx.html"},{"type":"function","title":"Bardo.Examples.Applications.Fx.configure/4","doc":"Configure a Forex trading experiment.\n\nParameters:\n- experiment_id: Unique identifier for the experiment\n- population_size: Number of trading agents (default: 50)\n- data_window: Size of the data window for training (default: 5000)\n- generations: Number of generations to evolve (default: 50)\n\nReturns the experiment configuration map.","ref":"Bardo.Examples.Applications.Fx.html#configure/4"},{"type":"function","title":"Bardo.Examples.Applications.Fx.run/4","doc":"Run a Forex trading experiment with the given configuration.\n\nParameters:\n- experiment_id: Unique identifier for the experiment\n- population_size: Number of trading agents (default: 50)\n- data_window: Size of the data window for training (default: 5000)\n- generations: Number of generations to evolve (default: 50)\n\nReturns :ok if the experiment was started successfully.","ref":"Bardo.Examples.Applications.Fx.html#run/4"},{"type":"function","title":"Bardo.Examples.Applications.Fx.test_best_agent/3","doc":"Test the best trading agent from a completed experiment on out-of-sample data.\n\nParameters:\n- experiment_id: ID of the completed experiment\n- test_window_start: Starting index for test data (default: 5000)\n- test_window_size: Size of the test data window (default: 1000)\n\nReturns a map with test results.","ref":"Bardo.Examples.Applications.Fx.html#test_best_agent/3"},{"type":"module","title":"Bardo.Examples.Applications.Fx.Fx","doc":"Forex (FX) trading simulation environment.\n\nThis module implements a forex trading simulator that allows\nagents to trade currency pairs based on historical price data.\nIt behaves as a private scape in the Bardo system.","ref":"Bardo.Examples.Applications.Fx.Fx.html"},{"type":"function","title":"Bardo.Examples.Applications.Fx.Fx.actuate/4","doc":"Handle an actuator request from an agent.\n\nRequired by the PrivateScape behavior.","ref":"Bardo.Examples.Applications.Fx.Fx.html#actuate/4"},{"type":"function","title":"Bardo.Examples.Applications.Fx.Fx.enter/3","doc":"Handle a new agent entering the private scape.\n\nCreates a new trading account for the agent.","ref":"Bardo.Examples.Applications.Fx.Fx.html#enter/3"},{"type":"function","title":"Bardo.Examples.Applications.Fx.Fx.init/1","doc":"Initialize the private scape for FX trading with provided parameters.\n\nRequired by the PrivateScape behavior.","ref":"Bardo.Examples.Applications.Fx.Fx.html#init/1"},{"type":"function","title":"Bardo.Examples.Applications.Fx.Fx.leave/3","doc":"Handle an agent leaving the private scape.\n\nCloses any open positions and removes the agent's account.","ref":"Bardo.Examples.Applications.Fx.Fx.html#leave/3"},{"type":"function","title":"Bardo.Examples.Applications.Fx.Fx.sense/2","doc":"Handle a sensor request from an agent.\n\nRequired by the PrivateScape behavior.","ref":"Bardo.Examples.Applications.Fx.Fx.html#sense/2"},{"type":"function","title":"Bardo.Examples.Applications.Fx.Fx.step/2","doc":"Advance the simulation by one step.\n\nUpdates all accounts and moves to the next price point.","ref":"Bardo.Examples.Applications.Fx.Fx.html#step/2"},{"type":"function","title":"Bardo.Examples.Applications.Fx.Fx.terminate/2","doc":"Clean up resources when terminating the scape.\n\nRequired by the PrivateScape behavior.","ref":"Bardo.Examples.Applications.Fx.Fx.html#terminate/2"},{"type":"module","title":"Bardo.Examples.Applications.Fx.Fx.Account","doc":"Account struct","ref":"Bardo.Examples.Applications.Fx.Fx.Account.html"},{"type":"module","title":"Bardo.Examples.Applications.Fx.Fx.Order","doc":"Order struct","ref":"Bardo.Examples.Applications.Fx.Fx.Order.html"},{"type":"module","title":"Bardo.Examples.Applications.Fx.Fx.PriceData","doc":"Technical data struct for price information","ref":"Bardo.Examples.Applications.Fx.Fx.PriceData.html"},{"type":"module","title":"Bardo.Examples.Applications.Fx.Fx.State","doc":"FX state struct","ref":"Bardo.Examples.Applications.Fx.Fx.State.html"},{"type":"module","title":"Bardo.Examples.Applications.Fx.FxActuator","doc":"Actuator implementation for the Forex (FX) trading application.\n\nThis module provides actuators that agents can use to interact\nwith the Forex trading environment, primarily for executing trades.","ref":"Bardo.Examples.Applications.Fx.FxActuator.html"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxActuator.actuate/2","doc":"Handle a list of incoming signals from the neural network.\n\nThis function:\n1. Converts neural network output to a trade decision\n2. Sends the trade decision to the FX simulator\n3. Processes responses (fitness, account updates)","ref":"Bardo.Examples.Applications.Fx.FxActuator.html#actuate/2"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxActuator.handle/2","doc":"","ref":"Bardo.Examples.Applications.Fx.FxActuator.html#handle/2"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxActuator.init/1","doc":"Initialize a new actuator for FX trading.\n\nParameters:\n- id: Actuator ID\n- actuator_type: :trade\n- fanin: Number of input elements\n- cortex_pid: PID of the cortex process\n- scape_pid: PID of the scape process\n- agent_id: ID of the agent","ref":"Bardo.Examples.Applications.Fx.FxActuator.html#init/1"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxActuator.init/6","doc":"","ref":"Bardo.Examples.Applications.Fx.FxActuator.html#init/6"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxActuator.terminate/2","doc":"Cleanup resources when terminating.","ref":"Bardo.Examples.Applications.Fx.FxActuator.html#terminate/2"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxActuator.trade/4","doc":"Creates a trade actuator configuration.","ref":"Bardo.Examples.Applications.Fx.FxActuator.html#trade/4"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Fx.FxActuator.trade/4","doc":"* `fanin` - The number of decision signal inputs (typically 1)\n  * `threshold` - The threshold for trade decision boundaries\n  * `cortex_id` - The ID of the cortex this actuator is connected to\n  * `scape_name` - The name of the scape this actuator will control","ref":"Bardo.Examples.Applications.Fx.FxActuator.html#trade/4-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Fx.FxActuator.trade/4","doc":"* An actuator specification map","ref":"Bardo.Examples.Applications.Fx.FxActuator.html#trade/4-returns"},{"type":"module","title":"Bardo.Examples.Applications.Fx.FxMorphology","doc":"Morphology for the Forex (FX) trading application.\n\nThis module defines the physical configuration for forex trading agents,\nincluding sensors for price data and actuators for executing trades.","ref":"Bardo.Examples.Applications.Fx.FxMorphology.html"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxMorphology.actuators/0","doc":"List of actuators available to the FX agents.\n\nReturns a list of actuator models for the FX application.","ref":"Bardo.Examples.Applications.Fx.FxMorphology.html#actuators/0"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxMorphology.actuators/2","doc":"Define the actuators for FX trading agents.\n\nReturns a list of actuator specifications.","ref":"Bardo.Examples.Applications.Fx.FxMorphology.html#actuators/2"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxMorphology.get_phys_config/3","doc":"Get the sensor and actuator configuration for an FX trading agent.\n\nReturns a map with :sensors and :actuators keys.","ref":"Bardo.Examples.Applications.Fx.FxMorphology.html#get_phys_config/3"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxMorphology.get_scape_params/4","doc":"Get the parameters required to enter the scape.\n\nReturns a map with parameters for connecting to the FX scape.","ref":"Bardo.Examples.Applications.Fx.FxMorphology.html#get_scape_params/4"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxMorphology.neuron_pattern/4","doc":"Define the neuron pattern for FX trading networks.\n\nThis function specifies how sensors and actuators connect to the neural network.","ref":"Bardo.Examples.Applications.Fx.FxMorphology.html#neuron_pattern/4"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxMorphology.sensors/0","doc":"List of sensors available to the FX agents.\n\nReturns a list of sensor models for the FX application.","ref":"Bardo.Examples.Applications.Fx.FxMorphology.html#sensors/0"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxMorphology.sensors/2","doc":"Define the sensors for FX trading agents.\n\nReturns a list of sensor specifications.","ref":"Bardo.Examples.Applications.Fx.FxMorphology.html#sensors/2"},{"type":"module","title":"Bardo.Examples.Applications.Fx.FxSensor","doc":"Sensor implementation for the Forex (FX) trading application.\n\nThis module provides sensors that agents can use to perceive\nforex market data, including:\n\n- Price Chart Image (PCI): 2D grid representation of price movement\n- Price List Information (PLI): Normalized vector of recent prices\n- Internals: Current trading position information","ref":"Bardo.Examples.Applications.Fx.FxSensor.html"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxSensor.init/1","doc":"Initialize a new sensor for FX trading.\n\nThis is the implementation of the Sensor behavior's init/1 callback.","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#init/1"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxSensor.init/7","doc":"Initialize a new sensor for FX trading.\n\nParameters:\n- id: Sensor ID\n- sensor_type: :pci, :pli, or :internals\n- params: Configuration parameters for the sensor\n- fanout: Number of output elements\n- cortex_pid: PID of the cortex process\n- scape_pid: PID of the scape process\n- agent_id: ID of the agent","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#init/7"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxSensor.internals/3","doc":"Creates an Internals sensor configuration for tracking account state.","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#internals/3"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Fx.FxSensor.internals/3","doc":"* `size` - The number of internal account state variables to track\n  * `cortex_id` - The ID of the cortex this sensor is connected to\n  * `scape_name` - The name of the scape this sensor will read from","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#internals/3-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Fx.FxSensor.internals/3","doc":"* A sensor specification map","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#internals/3-returns"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxSensor.pci/4","doc":"Creates a Price Chart Image (PCI) sensor configuration.","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#pci/4"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Fx.FxSensor.pci/4","doc":"* `dimension` - The dimension size of the price chart grid\n  * `timeframe` - The number of time periods to consider\n  * `cortex_id` - The ID of the cortex this sensor is connected to\n  * `scape_name` - The name of the scape this sensor will read from","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#pci/4-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Fx.FxSensor.pci/4","doc":"* A sensor specification map","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#pci/4-returns"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxSensor.percept/2","doc":"Process sensory data based on sensor type.\n\nThis is the implementation of the Sensor behavior's percept/2 callback.","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#percept/2"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxSensor.pli/4","doc":"Creates a Price List Information (PLI) sensor configuration.","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#pli/4"},{"type":"function","title":"Parameters - Bardo.Examples.Applications.Fx.FxSensor.pli/4","doc":"* `count` - The number of price points to consider\n  * `period` - The time period between price points\n  * `cortex_id` - The ID of the cortex this sensor is connected to\n  * `scape_name` - The name of the scape this sensor will read from","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#pli/4-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Applications.Fx.FxSensor.pli/4","doc":"* A sensor specification map","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#pli/4-returns"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxSensor.read/1","doc":"Read data from the sensor.\n\nThis function sends a sensing request to the scape and processes the response.","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#read/1"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxSensor.sense/2","doc":"Send a sensing request to the scape.\n\nThis is the implementation of the Sensor behavior's sense/2 callback.","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#sense/2"},{"type":"function","title":"Bardo.Examples.Applications.Fx.FxSensor.terminate/2","doc":"Cleanup resources when terminating.","ref":"Bardo.Examples.Applications.Fx.FxSensor.html#terminate/2"},{"type":"module","title":"Bardo.Examples.Benchmarks.Dpb.Dpb","doc":"Base sector module for the Double Pole Balancing task.\n\nThis is the interface module that handles the common aspects of\nthe double pole balancing task and delegates to specific implementations.","ref":"Bardo.Examples.Benchmarks.Dpb.Dpb.html"},{"type":"module","title":"Bardo.Examples.Benchmarks.Dpb.DpbActuator","doc":"Actuator implementation for the Double Pole Balancing (DPB) benchmark.\n\nThis module provides actuators that agents can use to control\nthe cart in the pole balancing simulation.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.html"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.actuate/2","doc":"Process signals from the neural network and apply forces to the cart.\n\nThis is the implementation of the Actuator behavior's actuate/2 callback.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.html#actuate/2"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.handle/2","doc":"Handle a list of incoming signals from the neural network.\n\nThis function:\n1. Converts neural network output to a force value\n2. Sends the force value to the DPB simulator\n3. Processes responses (fitness, simulation state)","ref":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.html#handle/2"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.init/1","doc":"Initialize a new actuator for the DPB simulation.\n\nThis is the implementation of the Actuator behavior's init/1 callback.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.html#init/1"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.init/7","doc":"Initialize a new actuator for the DPB simulation.\n\nParameters:\n- id: Actuator ID\n- actuator_type: :force\n- fanin: Number of input elements\n- cortex_pid: PID of the cortex process\n- scape_pid: PID of the scape process\n- agent_id: ID of the agent\n- parameters: Additional parameters (with_damping or without_damping)","ref":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.html#init/7"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.with_damping/4","doc":"Create a force actuator configuration for DPB with damping.\n\nParameters:\n- id: Actuator ID\n- fanin: Number of input elements from the neural network\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns an actuator specification map.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.html#with_damping/4"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.without_damping/4","doc":"Create a force actuator configuration for DPB without damping.\n\nParameters:\n- id: Actuator ID\n- fanin: Number of input elements from the neural network\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns an actuator specification map.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbActuator.html#without_damping/4"},{"type":"module","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor","doc":"Sensor implementation for the Double Pole Balancing (DPB) benchmark.\n\nThis module provides sensors that agents can use to perceive\nthe state of the cart and poles in the pole balancing simulation.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.cart_position/4","doc":"Create a cart position sensor configuration.\n\nParameters:\n- id: Sensor ID\n- fanout: Number of output elements (typically 1)\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns a sensor specification map.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#cart_position/4"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.cart_velocity/4","doc":"Create a cart velocity sensor configuration.\n\nParameters:\n- id: Sensor ID\n- fanout: Number of output elements (typically 1)\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns a sensor specification map.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#cart_velocity/4"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.init/1","doc":"Initialize a new sensor for the DPB simulation.\n\nThis is the implementation of the Sensor behavior's init/1 callback.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#init/1"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.init/6","doc":"Initialize a new sensor for the DPB simulation.\n\nParameters:\n- id: Sensor ID\n- sensor_type: :cart_position, :pole1_angle, :pole2_angle, :cart_velocity, \n              :pole1_angular_velocity, or :pole2_angular_velocity\n- fanout: Number of output elements (typically 1)\n- cortex_pid: PID of the cortex process\n- scape_pid: PID of the scape process\n- agent_id: ID of the agent","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#init/6"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.percept/2","doc":"Process sensory data based on sensor type.\n\nThis is the implementation of the Sensor behavior's percept/2 callback.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#percept/2"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.pole1_angle/4","doc":"Create a pole1 angle sensor configuration.\n\nParameters:\n- id: Sensor ID\n- fanout: Number of output elements (typically 1)\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns a sensor specification map.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#pole1_angle/4"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.pole1_angular_velocity/4","doc":"Create a pole1 angular velocity sensor configuration.\n\nParameters:\n- id: Sensor ID\n- fanout: Number of output elements (typically 1)\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns a sensor specification map.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#pole1_angular_velocity/4"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.pole2_angle/4","doc":"Create a pole2 angle sensor configuration.\n\nParameters:\n- id: Sensor ID\n- fanout: Number of output elements (typically 1)\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns a sensor specification map.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#pole2_angle/4"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.pole2_angular_velocity/4","doc":"Create a pole2 angular velocity sensor configuration.\n\nParameters:\n- id: Sensor ID\n- fanout: Number of output elements (typically 1)\n- cortex_id: ID of the cortex\n- scape_name: Name of the scape\n\nReturns a sensor specification map.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#pole2_angular_velocity/4"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.read/1","doc":"Read data from the sensor.\n\nThis function sends a sensing request to the scape and processes the response.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#read/1"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.sense/2","doc":"Send a sensing request to the scape.\n\nThis is the implementation of the Sensor behavior's sense/2 callback.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbSensor.html#sense/2"},{"type":"module","title":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping","doc":"Double Pole Balancing with Damping.\n\nThis variant of the DPB task provides the full state information including velocities.\nIt is an easier version typically used to verify that a neuroevolution algorithm works.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping.html"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping.get_phys_config/3","doc":"Returns the physical configuration for sensors and actuators\nrequired by the DPB with damping experiment.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping.html#get_phys_config/3"},{"type":"function","title":"Parameters - Bardo.Examples.Benchmarks.Dpb.DpbWDamping.get_phys_config/3","doc":"* `owner` - Owner ID\n  * `cortex_id` - Cortex ID\n  * `scape_id` - Scape ID","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping.html#get_phys_config/3-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Benchmarks.Dpb.DpbWDamping.get_phys_config/3","doc":"* Map with sensor and actuator definitions","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping.html#get_phys_config/3-returns"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping.neuron_pattern/4","doc":"Creates a neuron pattern for the DPB with damping experiment.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping.html#neuron_pattern/4"},{"type":"function","title":"Parameters - Bardo.Examples.Benchmarks.Dpb.DpbWDamping.neuron_pattern/4","doc":"* `owner` - Owner ID\n  * `agent_id` - Agent ID\n  * `cortex_id` - Cortex ID\n  * `_substrate` - Substrate (unused in this implementation)","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping.html#neuron_pattern/4-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Benchmarks.Dpb.DpbWDamping.neuron_pattern/4","doc":"* Neuron pattern with mappings between sensors/actuators and neurons","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWDamping.html#neuron_pattern/4-returns"},{"type":"module","title":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping","doc":"Double Pole Balancing without Damping.\n\nThis variant of the DPB task does not provide velocity information, making it a harder task.\nThe neural network needs to develop recurrent connections to compute velocity estimates.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.html"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.get_phys_config/3","doc":"Returns the physical configuration for sensors and actuators\nrequired by the DPB without damping experiment.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.html#get_phys_config/3"},{"type":"function","title":"Parameters - Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.get_phys_config/3","doc":"* `owner` - Owner ID\n  * `cortex_id` - Cortex ID\n  * `scape_id` - Scape ID","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.html#get_phys_config/3-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.get_phys_config/3","doc":"* Map with sensor and actuator definitions","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.html#get_phys_config/3-returns"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.neuron_pattern/4","doc":"Creates a neuron pattern for the DPB without damping experiment.","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.html#neuron_pattern/4"},{"type":"function","title":"Parameters - Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.neuron_pattern/4","doc":"* `owner` - Owner ID\n  * `agent_id` - Agent ID\n  * `cortex_id` - Cortex ID\n  * `_substrate` - Substrate (unused in this implementation)","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.html#neuron_pattern/4-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.neuron_pattern/4","doc":"* Neuron pattern with mappings between sensors/actuators and neurons","ref":"Bardo.Examples.Benchmarks.Dpb.DpbWoDamping.html#neuron_pattern/4-returns"},{"type":"module","title":"Bardo.Examples.ExamplesHelper","doc":"Helper module for running Bardo examples more reliably.\n\nThis module provides utility functions for running and testing\nthe complex examples in the Bardo framework. It ensures that\nexperiments are properly set up, tracked, and provides better\nvisibility into the progress of running experiments.","ref":"Bardo.Examples.ExamplesHelper.html"},{"type":"function","title":"Bardo.Examples.ExamplesHelper.run_experiment/2","doc":"Run an experiment with progress tracking and error handling.\n\nThis function sets up and runs an experiment with the given configuration,\nwhile providing regular progress updates. It ensures that experiments\ncan be properly tracked and visualized later.","ref":"Bardo.Examples.ExamplesHelper.html#run_experiment/2"},{"type":"function","title":"Parameters - Bardo.Examples.ExamplesHelper.run_experiment/2","doc":"- config: The complete experiment configuration\n- opts: Optional parameters\n  - timeout: Maximum time to wait for experiment completion (default: 300_000ms / 5 minutes)\n  - update_interval: How often to check/report progress (default: 5_000ms / 5 seconds)\n  - visualize: Whether to run visualization after completion (default: false)","ref":"Bardo.Examples.ExamplesHelper.html#run_experiment/2-parameters"},{"type":"function","title":"Returns - Bardo.Examples.ExamplesHelper.run_experiment/2","doc":"- {:ok, experiment_data} - If the experiment completed successfully\n- {:error, reason} - If there was an error during setup or execution","ref":"Bardo.Examples.ExamplesHelper.html#run_experiment/2-returns"},{"type":"function","title":"Bardo.Examples.ExamplesHelper.run_visualization/1","doc":"Run a visualization for a completed experiment.\n\nCreates a simplified visualization environment based on the experiment configuration.","ref":"Bardo.Examples.ExamplesHelper.html#run_visualization/1"},{"type":"module","title":"Bardo.ExperimentManager.ExperimentManager","doc":"The ExperimentManager is responsible for orchestrating neuroevolution experiments.\n\nIt handles the complete lifecycle of experiments:\n\n1. Creation and configuration of experiments with parameters\n2. Starting and coordinating evolutionary runs across populations\n3. Tracking experiment progress and collecting results\n4. Providing status updates and access to results\n5. Managing experiment persistence and reporting\n\nSpecifically, it has three main functionalities:\n\n1. Run the population_manager N number of times, waiting for the\n   population_manager's trace after every run.\n2. Create the experiment entry in the database, and keep\n   updating its trace_acc as it itself accumulates the traces from\n   spawned population_managers. This enables persistence across restarts.\n3. When the experiment_manager has finished performing N number of\n   evolutionary runs, it calculates statistics and produces reports\n   of the results for analysis.","ref":"Bardo.ExperimentManager.ExperimentManager.html"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.ExperimentManager.ExperimentManager.html#child_spec/1"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.configure/2","doc":"Configure an existing experiment with the given parameters.","ref":"Bardo.ExperimentManager.ExperimentManager.html#configure/2"},{"type":"function","title":"Parameters - Bardo.ExperimentManager.ExperimentManager.configure/2","doc":"* `experiment_id` - ID of the experiment to configure\n  * `config` - Configuration parameters for the experiment","ref":"Bardo.ExperimentManager.ExperimentManager.html#configure/2-parameters"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.configure/2","doc":"* `:ok` - If the experiment was configured successfully\n  * `{:error, reason}` - If there was an error configuring the experiment","ref":"Bardo.ExperimentManager.ExperimentManager.html#configure/2-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.configure/2","doc":"iex> config = %{\n    ...>   runs: 5,\n    ...>   generations: 50,\n    ...>   population_size: 100,\n    ...>   morphology: :xor,\n    ...>   selection_method: :tournament,\n    ...>   backup_flag: true\n    ...> }\n    iex> ExperimentManager.configure(\"experiment_1621234567890\", config)\n    :ok","ref":"Bardo.ExperimentManager.ExperimentManager.html#configure/2-examples"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.export_results/3","doc":"Export experiment results to a file.","ref":"Bardo.ExperimentManager.ExperimentManager.html#export_results/3"},{"type":"function","title":"Parameters - Bardo.ExperimentManager.ExperimentManager.export_results/3","doc":"* `experiment_id` - ID of the experiment to export\n  * `file_path` - Path to save the results to\n  * `format` - Format to export in (:csv, :json, or :binary)","ref":"Bardo.ExperimentManager.ExperimentManager.html#export_results/3-parameters"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.export_results/3","doc":"* `:ok` - If the results were exported successfully\n  * `{:error, reason}` - If there was an error exporting the results","ref":"Bardo.ExperimentManager.ExperimentManager.html#export_results/3-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.export_results/3","doc":"iex> ExperimentManager.export_results(\"experiment_1621234567890\", \"results.json\", :json)\n    :ok","ref":"Bardo.ExperimentManager.ExperimentManager.html#export_results/3-examples"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.get_best_solution/1","doc":"Get the best solution from an experiment.","ref":"Bardo.ExperimentManager.ExperimentManager.html#get_best_solution/1"},{"type":"function","title":"Parameters - Bardo.ExperimentManager.ExperimentManager.get_best_solution/1","doc":"* `experiment_id` - ID of the experiment to get the best solution from","ref":"Bardo.ExperimentManager.ExperimentManager.html#get_best_solution/1-parameters"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.get_best_solution/1","doc":"* `{:ok, solution}` - Best solution found in the experiment\n  * `{:error, reason}` - If there was an error getting the best solution","ref":"Bardo.ExperimentManager.ExperimentManager.html#get_best_solution/1-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.get_best_solution/1","doc":"iex> ExperimentManager.get_best_solution(\"experiment_1621234567890\")\n    {:ok, %{\n      fitness: 0.98,\n      genotype: %{...},\n      phenotype: %{...}\n    }}","ref":"Bardo.ExperimentManager.ExperimentManager.html#get_best_solution/1-examples"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.list_active/0","doc":"Get all active experiments.","ref":"Bardo.ExperimentManager.ExperimentManager.html#list_active/0"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.list_active/0","doc":"* `{:ok, [experiment_id]}` - List of active experiment IDs\n  * `{:error, reason}` - If there was an error getting the active experiments","ref":"Bardo.ExperimentManager.ExperimentManager.html#list_active/0-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.list_active/0","doc":"iex> ExperimentManager.list_active()\n    {:ok, [\"experiment_1621234567890\", \"experiment_1621234567891\"]}","ref":"Bardo.ExperimentManager.ExperimentManager.html#list_active/0-examples"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.list_all/0","doc":"Get a list of all experiments.","ref":"Bardo.ExperimentManager.ExperimentManager.html#list_all/0"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.list_all/0","doc":"* `{:ok, [experiment]}` - List of all experiments with their basic information\n  * `{:error, reason}` - If there was an error getting the experiments","ref":"Bardo.ExperimentManager.ExperimentManager.html#list_all/0-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.list_all/0","doc":"iex> ExperimentManager.list_all()\n    {:ok, [\n      %{id: \"experiment_1621234567890\", name: \"XOR Experiment\", status: :completed},\n      %{id: \"experiment_1621234567891\", name: \"FX Experiment\", status: :in_progress}\n    ]}","ref":"Bardo.ExperimentManager.ExperimentManager.html#list_all/0-examples"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.new_experiment/1","doc":"Create a new experiment with the given name.","ref":"Bardo.ExperimentManager.ExperimentManager.html#new_experiment/1"},{"type":"function","title":"Parameters - Bardo.ExperimentManager.ExperimentManager.new_experiment/1","doc":"* `name` - Name of the experiment","ref":"Bardo.ExperimentManager.ExperimentManager.html#new_experiment/1-parameters"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.new_experiment/1","doc":"* `{:ok, experiment_id}` - Experiment ID of the created experiment\n  * `{:error, reason}` - If there was an error creating the experiment","ref":"Bardo.ExperimentManager.ExperimentManager.html#new_experiment/1-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.new_experiment/1","doc":"iex> ExperimentManager.new_experiment(\"XOR Experiment\")\n    {:ok, \"experiment_1621234567890\"}","ref":"Bardo.ExperimentManager.ExperimentManager.html#new_experiment/1-examples"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.population_manager_module/0","doc":"Get the configured population manager module.\nThis is used primarily for testing to allow mocks.","ref":"Bardo.ExperimentManager.ExperimentManager.html#population_manager_module/0"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.run/0","doc":"Start a new experiment run with default parameters.\nThis creates a default experiment and starts it immediately.","ref":"Bardo.ExperimentManager.ExperimentManager.html#run/0"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.run/0","doc":"* `:ok` - If the run was started successfully\n  * `{:error, reason}` - If there was an error starting the run","ref":"Bardo.ExperimentManager.ExperimentManager.html#run/0-returns"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.set_population_manager_module/1","doc":"Set the population manager module.\nThis is used primarily for testing to allow mocks.","ref":"Bardo.ExperimentManager.ExperimentManager.html#set_population_manager_module/1"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.start/1","doc":"Start an experiment with the given ID.","ref":"Bardo.ExperimentManager.ExperimentManager.html#start/1"},{"type":"function","title":"Parameters - Bardo.ExperimentManager.ExperimentManager.start/1","doc":"* `experiment_id` - ID of the experiment to start","ref":"Bardo.ExperimentManager.ExperimentManager.html#start/1-parameters"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.start/1","doc":"* `:ok` - If the experiment was started successfully\n  * `{:error, reason}` - If there was an error starting the experiment","ref":"Bardo.ExperimentManager.ExperimentManager.html#start/1-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.start/1","doc":"iex> ExperimentManager.start(\"experiment_1621234567890\")\n    :ok","ref":"Bardo.ExperimentManager.ExperimentManager.html#start/1-examples"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.start_evaluation/2","doc":"Set the fitness function for evaluating solutions in an experiment.","ref":"Bardo.ExperimentManager.ExperimentManager.html#start_evaluation/2"},{"type":"function","title":"Parameters - Bardo.ExperimentManager.ExperimentManager.start_evaluation/2","doc":"* `experiment_id` - ID of the experiment\n  * `fitness_function` - Function to evaluate fitness of solutions","ref":"Bardo.ExperimentManager.ExperimentManager.html#start_evaluation/2-parameters"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.start_evaluation/2","doc":"* `:ok` - If the fitness function was set successfully\n  * `{:error, reason}` - If there was an error setting the fitness function","ref":"Bardo.ExperimentManager.ExperimentManager.html#start_evaluation/2-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.start_evaluation/2","doc":"iex> fitness_fn = fn solution -> solution.output == [0, 1, 1, 0] end\n    iex> ExperimentManager.start_evaluation(\"experiment_1621234567890\", fitness_fn)\n    :ok","ref":"Bardo.ExperimentManager.ExperimentManager.html#start_evaluation/2-examples"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.start_link/1","doc":"Start the ExperimentManager as a linked process.","ref":"Bardo.ExperimentManager.ExperimentManager.html#start_link/1"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.status/1","doc":"Get the status of an experiment.","ref":"Bardo.ExperimentManager.ExperimentManager.html#status/1"},{"type":"function","title":"Parameters - Bardo.ExperimentManager.ExperimentManager.status/1","doc":"* `experiment_id` - ID of the experiment to get status for","ref":"Bardo.ExperimentManager.ExperimentManager.html#status/1-parameters"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.status/1","doc":"* `{:in_progress, status}` - If the experiment is in progress, with status details\n  * `{:completed, results}` - If the experiment is completed, with results\n  * `{:error, reason}` - If there was an error getting the status","ref":"Bardo.ExperimentManager.ExperimentManager.html#status/1-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.status/1","doc":"iex> ExperimentManager.status(\"experiment_1621234567890\")\n    {:in_progress, %{\n      run: 2,\n      total_runs: 5,\n      generation: 45,\n      generations: 50,\n      best_fitness: 0.95,\n      avg_fitness: 0.72\n    }}","ref":"Bardo.ExperimentManager.ExperimentManager.html#status/1-examples"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManager.stop/1","doc":"Stop an experiment.","ref":"Bardo.ExperimentManager.ExperimentManager.html#stop/1"},{"type":"function","title":"Parameters - Bardo.ExperimentManager.ExperimentManager.stop/1","doc":"* `experiment_id` - ID of the experiment to stop","ref":"Bardo.ExperimentManager.ExperimentManager.html#stop/1-parameters"},{"type":"function","title":"Returns - Bardo.ExperimentManager.ExperimentManager.stop/1","doc":"* `:ok` - If the experiment was stopped successfully\n  * `{:error, reason}` - If there was an error stopping the experiment","ref":"Bardo.ExperimentManager.ExperimentManager.html#stop/1-returns"},{"type":"function","title":"Examples - Bardo.ExperimentManager.ExperimentManager.stop/1","doc":"iex> ExperimentManager.stop(\"experiment_1621234567890\")\n    :ok","ref":"Bardo.ExperimentManager.ExperimentManager.html#stop/1-examples"},{"type":"module","title":"Bardo.ExperimentManager.ExperimentManagerClient","doc":"Client module for interacting with the ExperimentManager.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManagerClient.configure/2","doc":"Configure an existing experiment.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html#configure/2"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManagerClient.get_best_solution/1","doc":"Get the best solution from an experiment.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html#get_best_solution/1"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManagerClient.new_experiment/1","doc":"Create a new experiment.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html#new_experiment/1"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManagerClient.run_complete/2","doc":"Notifies the experiment manager that a run has completed with the given results.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html#run_complete/2"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManagerClient.start/1","doc":"Start the experiment with the given ID.\n\nFor compatibility with older code.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html#start/1"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManagerClient.start_evaluation/2","doc":"Start evaluation with a fitness function.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html#start_evaluation/2"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManagerClient.start_run/0","doc":"Sends a message to start a new experiment run.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html#start_run/0"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManagerClient.status/1","doc":"Get the status of an experiment.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html#status/1"},{"type":"function","title":"Bardo.ExperimentManager.ExperimentManagerClient.stop/1","doc":"Stop an experiment.","ref":"Bardo.ExperimentManager.ExperimentManagerClient.html#stop/1"},{"type":"module","title":"Bardo.ExperimentManager.Supervisor","doc":"Supervisor for the ExperimentManager subsystem.","ref":"Bardo.ExperimentManager.Supervisor.html"},{"type":"function","title":"Bardo.ExperimentManager.Supervisor.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.ExperimentManager.Supervisor.html#child_spec/1"},{"type":"function","title":"Bardo.ExperimentManager.Supervisor.start_link/1","doc":"Starts the supervisor.","ref":"Bardo.ExperimentManager.Supervisor.html#start_link/1"},{"type":"module","title":"Bardo.LogR","doc":"A logging module for the Bardo system.\nThis is a simplified implementation for testing.","ref":"Bardo.LogR.html"},{"type":"function","title":"Bardo.LogR.debug/1","doc":"","ref":"Bardo.LogR.html#debug/1"},{"type":"function","title":"Bardo.LogR.error/1","doc":"","ref":"Bardo.LogR.html#error/1"},{"type":"function","title":"Bardo.LogR.info/1","doc":"","ref":"Bardo.LogR.html#info/1"},{"type":"function","title":"Bardo.LogR.notice/1","doc":"","ref":"Bardo.LogR.html#notice/1"},{"type":"function","title":"Bardo.LogR.warning/1","doc":"","ref":"Bardo.LogR.html#warning/1"},{"type":"module","title":"Bardo.Models.Champion","doc":"A module for creating and manipulating champion models.","ref":"Bardo.Models.Champion.html"},{"type":"function","title":"Bardo.Models.Champion.champion/1","doc":"Create a champion model.\nTakes a map with champion data and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.Champion.html#champion/1"},{"type":"module","title":"Bardo.Morphology","doc":"Morphology module for the Bardo neuroevolution system.\n\nThe Morphology module defines the structure and properties of neural networks\nin the Bardo system. It provides functions for creating, modifying, and querying\nneural network morphologies, including:\n\n- Sensors: Input mechanisms for receiving data from the environment\n- Actuators: Output mechanisms for interacting with the environment\n- Substrates: Spatial arrangements of neurons in n-dimensional space\n- Connections: Patterns and rules for connecting neurons\n\nThis module serves as the foundation for defining the physical structure of neural\nnetworks, which combined with learning rules and evolutionary algorithms, enables\nthe creation of complex, adaptive systems.","ref":"Bardo.Morphology.html"},{"type":"type","title":"Bardo.Morphology.actuator/0","doc":"Type definition for an actuator specification.","ref":"Bardo.Morphology.html#t:actuator/0"},{"type":"function","title":"Bardo.Morphology.add_actuator/2","doc":"Add an actuator to a morphology.","ref":"Bardo.Morphology.html#add_actuator/2"},{"type":"function","title":"Parameters - Bardo.Morphology.add_actuator/2","doc":"* `morphology` - The morphology to add the actuator to\n  * `actuator` - The actuator to add","ref":"Bardo.Morphology.html#add_actuator/2-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.add_actuator/2","doc":"* An updated morphology with the new actuator","ref":"Bardo.Morphology.html#add_actuator/2-returns"},{"type":"function","title":"Examples - Bardo.Morphology.add_actuator/2","doc":"iex> actuator = Models.actuator(%{name: :motor, type: :movement, vl: 2})\n    iex> morphology = Bardo.Morphology.new()\n    iex> Bardo.Morphology.add_actuator(morphology, actuator)\n    %{id: \"morph_xxxxxxxxxxx\", actuators: [%{name: :motor, type: :movement, vl: 2}, ...], ...}","ref":"Bardo.Morphology.html#add_actuator/2-examples"},{"type":"function","title":"Bardo.Morphology.add_sensor/2","doc":"Add a sensor to a morphology.","ref":"Bardo.Morphology.html#add_sensor/2"},{"type":"function","title":"Parameters - Bardo.Morphology.add_sensor/2","doc":"* `morphology` - The morphology to add the sensor to\n  * `sensor` - The sensor to add","ref":"Bardo.Morphology.html#add_sensor/2-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.add_sensor/2","doc":"* An updated morphology with the new sensor","ref":"Bardo.Morphology.html#add_sensor/2-returns"},{"type":"function","title":"Examples - Bardo.Morphology.add_sensor/2","doc":"iex> sensor = Models.sensor(%{name: :eye, type: :vision, vl: 100})\n    iex> morphology = Bardo.Morphology.new()\n    iex> Bardo.Morphology.add_sensor(morphology, sensor)\n    %{id: \"morph_xxxxxxxxxxx\", sensors: [%{name: :eye, type: :vision, vl: 100}, ...], ...}","ref":"Bardo.Morphology.html#add_sensor/2-examples"},{"type":"function","title":"Bardo.Morphology.delete/1","doc":"Delete a morphology from the database.","ref":"Bardo.Morphology.html#delete/1"},{"type":"function","title":"Parameters - Bardo.Morphology.delete/1","doc":"* `id` - The ID of the morphology to delete","ref":"Bardo.Morphology.html#delete/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.delete/1","doc":"* `:ok` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Morphology.html#delete/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.delete/1","doc":"iex> Bardo.Morphology.delete(\"morph_123456789\")\n    :ok","ref":"Bardo.Morphology.html#delete/1-examples"},{"type":"function","title":"Bardo.Morphology.get_actuators/1","doc":"Get all available actuators for a morphology.","ref":"Bardo.Morphology.html#get_actuators/1"},{"type":"function","title":"Parameters - Bardo.Morphology.get_actuators/1","doc":"* `morphology` - The morphology to get actuators for","ref":"Bardo.Morphology.html#get_actuators/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_actuators/1","doc":"* A list of all actuators","ref":"Bardo.Morphology.html#get_actuators/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.get_actuators/1","doc":"iex> morphology = Bardo.Morphology.new()\n    iex> Bardo.Morphology.get_actuators(morphology)\n    [%{name: :default_actuator, ...}]","ref":"Bardo.Morphology.html#get_actuators/1-examples"},{"type":"function","title":"Bardo.Morphology.get_init_actuators/1","doc":"Get the initial actuators for a morphology.","ref":"Bardo.Morphology.html#get_init_actuators/1"},{"type":"function","title":"Parameters - Bardo.Morphology.get_init_actuators/1","doc":"* `morphology` - The morphology to get actuators for","ref":"Bardo.Morphology.html#get_init_actuators/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_init_actuators/1","doc":"* A list of actuators","ref":"Bardo.Morphology.html#get_init_actuators/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.get_init_actuators/1","doc":"iex> morphology = Bardo.Morphology.new()\n    iex> Bardo.Morphology.get_init_actuators(morphology)\n    [%{name: :default_actuator, ...}]","ref":"Bardo.Morphology.html#get_init_actuators/1-examples"},{"type":"function","title":"Bardo.Morphology.get_init_sensors/1","doc":"Get the initial sensors for a morphology.","ref":"Bardo.Morphology.html#get_init_sensors/1"},{"type":"function","title":"Parameters - Bardo.Morphology.get_init_sensors/1","doc":"* `morphology` - The morphology to get sensors for","ref":"Bardo.Morphology.html#get_init_sensors/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_init_sensors/1","doc":"* A list of sensors","ref":"Bardo.Morphology.html#get_init_sensors/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.get_init_sensors/1","doc":"iex> morphology = Bardo.Morphology.new()\n    iex> Bardo.Morphology.get_init_sensors(morphology)\n    [%{name: :default_sensor, ...}]","ref":"Bardo.Morphology.html#get_init_sensors/1-examples"},{"type":"function","title":"Bardo.Morphology.get_init_substrate_ceps/1","doc":"Get the initial substrate connection expression producers (CEPs) for a morphology.","ref":"Bardo.Morphology.html#get_init_substrate_ceps/1"},{"type":"function","title":"Parameters - Bardo.Morphology.get_init_substrate_ceps/1","doc":"* `morphology` - The morphology to get substrate CEPs for\n  * `plasticity` - Optional plasticity type (overrides the morphology's plasticity)","ref":"Bardo.Morphology.html#get_init_substrate_ceps/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_init_substrate_ceps/1","doc":"* A list of substrate CEPs","ref":"Bardo.Morphology.html#get_init_substrate_ceps/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.get_init_substrate_ceps/1","doc":"iex> morphology = Bardo.Morphology.new(%{plasticity: :hebbian})\n    iex> Bardo.Morphology.get_init_substrate_ceps(morphology)\n    [%{name: :delta_weight, ...}]","ref":"Bardo.Morphology.html#get_init_substrate_ceps/1-examples"},{"type":"function","title":"Bardo.Morphology.get_init_substrate_ceps/2","doc":"","ref":"Bardo.Morphology.html#get_init_substrate_ceps/2"},{"type":"function","title":"Bardo.Morphology.get_init_substrate_cpps/1","doc":"Get the initial substrate connection pattern producers (CPPs) for a morphology.","ref":"Bardo.Morphology.html#get_init_substrate_cpps/1"},{"type":"function","title":"Parameters - Bardo.Morphology.get_init_substrate_cpps/1","doc":"* `morphology` - The morphology to get substrate CPPs for\n  * `plasticity` - Optional plasticity type (overrides the morphology's plasticity)","ref":"Bardo.Morphology.html#get_init_substrate_cpps/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_init_substrate_cpps/1","doc":"* A list of substrate CPPs","ref":"Bardo.Morphology.html#get_init_substrate_cpps/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.get_init_substrate_cpps/1","doc":"iex> morphology = Bardo.Morphology.new(%{plasticity: :hebbian})\n    iex> Bardo.Morphology.get_init_substrate_cpps(morphology)\n    [%{name: :cartesian, ...}]","ref":"Bardo.Morphology.html#get_init_substrate_cpps/1-examples"},{"type":"function","title":"Bardo.Morphology.get_init_substrate_cpps/2","doc":"","ref":"Bardo.Morphology.html#get_init_substrate_cpps/2"},{"type":"function","title":"Bardo.Morphology.get_phys_config/3","doc":"Create a physical configuration for an agent.","ref":"Bardo.Morphology.html#get_phys_config/3"},{"type":"function","title":"Parameters - Bardo.Morphology.get_phys_config/3","doc":"* `morphology` - The morphology to create a physical configuration for\n  * `cortex_id` - The ID of the cortex\n  * `scape_name` - The name of the scape","ref":"Bardo.Morphology.html#get_phys_config/3-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_phys_config/3","doc":"* A map with :sensors and :actuators keys","ref":"Bardo.Morphology.html#get_phys_config/3-returns"},{"type":"function","title":"Examples - Bardo.Morphology.get_phys_config/3","doc":"iex> morphology = Bardo.Morphology.new()\n    iex> Bardo.Morphology.get_phys_config(morphology, \"cx_123\", :test_scape)\n    %{sensors: [...], actuators: [...]}","ref":"Bardo.Morphology.html#get_phys_config/3-examples"},{"type":"function","title":"Bardo.Morphology.get_scape_params/4","doc":"Get the parameters required for an agent to enter a scape.","ref":"Bardo.Morphology.html#get_scape_params/4"},{"type":"function","title":"Parameters - Bardo.Morphology.get_scape_params/4","doc":"* `morphology` - The morphology to get scape parameters for\n  * `agent_id` - The ID of the agent\n  * `cortex_id` - The ID of the cortex\n  * `scape_name` - The name of the scape","ref":"Bardo.Morphology.html#get_scape_params/4-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_scape_params/4","doc":"* A map with scape parameters","ref":"Bardo.Morphology.html#get_scape_params/4-returns"},{"type":"function","title":"Bardo.Morphology.get_sensors/1","doc":"Get all available sensors for a morphology.","ref":"Bardo.Morphology.html#get_sensors/1"},{"type":"function","title":"Parameters - Bardo.Morphology.get_sensors/1","doc":"* `morphology` - The morphology to get sensors for","ref":"Bardo.Morphology.html#get_sensors/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_sensors/1","doc":"* A list of all sensors","ref":"Bardo.Morphology.html#get_sensors/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.get_sensors/1","doc":"iex> morphology = Bardo.Morphology.new()\n    iex> Bardo.Morphology.get_sensors(morphology)\n    [%{name: :default_sensor, ...}]","ref":"Bardo.Morphology.html#get_sensors/1-examples"},{"type":"function","title":"Bardo.Morphology.get_substrate_ceps/1","doc":"Get all available substrate connection expression producers (CEPs) for a morphology.","ref":"Bardo.Morphology.html#get_substrate_ceps/1"},{"type":"function","title":"Parameters - Bardo.Morphology.get_substrate_ceps/1","doc":"* `morphology` - The morphology to get substrate CEPs for\n  * `plasticity` - Optional plasticity type (overrides the morphology's plasticity)","ref":"Bardo.Morphology.html#get_substrate_ceps/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_substrate_ceps/1","doc":"* A list of all substrate CEPs","ref":"Bardo.Morphology.html#get_substrate_ceps/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.get_substrate_ceps/1","doc":"iex> morphology = Bardo.Morphology.new(%{plasticity: :hebbian})\n    iex> Bardo.Morphology.get_substrate_ceps(morphology)\n    [%{name: :delta_weight, ...}, %{name: :set_abcn, ...}, ...]","ref":"Bardo.Morphology.html#get_substrate_ceps/1-examples"},{"type":"function","title":"Bardo.Morphology.get_substrate_ceps/2","doc":"","ref":"Bardo.Morphology.html#get_substrate_ceps/2"},{"type":"function","title":"Bardo.Morphology.get_substrate_cpps/1","doc":"Get all available substrate connection pattern producers (CPPs) for a morphology.","ref":"Bardo.Morphology.html#get_substrate_cpps/1"},{"type":"function","title":"Parameters - Bardo.Morphology.get_substrate_cpps/1","doc":"* `morphology` - The morphology to get substrate CPPs for\n  * `plasticity` - Optional plasticity type (overrides the morphology's plasticity)","ref":"Bardo.Morphology.html#get_substrate_cpps/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.get_substrate_cpps/1","doc":"* A list of all substrate CPPs","ref":"Bardo.Morphology.html#get_substrate_cpps/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.get_substrate_cpps/1","doc":"iex> morphology = Bardo.Morphology.new(%{plasticity: :hebbian})\n    iex> Bardo.Morphology.get_substrate_cpps(morphology)\n    [%{name: :cartesian, ...}, %{name: :centripital_distances, ...}, ...]","ref":"Bardo.Morphology.html#get_substrate_cpps/1-examples"},{"type":"function","title":"Bardo.Morphology.get_substrate_cpps/2","doc":"","ref":"Bardo.Morphology.html#get_substrate_cpps/2"},{"type":"function","title":"Bardo.Morphology.list/0","doc":"List all morphologies in the database.","ref":"Bardo.Morphology.html#list/0"},{"type":"function","title":"Returns - Bardo.Morphology.list/0","doc":"* `{:ok, [morphology]}` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Morphology.html#list/0-returns"},{"type":"function","title":"Examples - Bardo.Morphology.list/0","doc":"iex> Bardo.Morphology.list()\n    {:ok, [%{id: \"morph_123456789\", name: \"Simple XOR\", ...}, ...]}","ref":"Bardo.Morphology.html#list/0-examples"},{"type":"function","title":"Bardo.Morphology.load/1","doc":"Load a morphology from the database.","ref":"Bardo.Morphology.html#load/1"},{"type":"function","title":"Parameters - Bardo.Morphology.load/1","doc":"* `id` - The ID of the morphology to load","ref":"Bardo.Morphology.html#load/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.load/1","doc":"* `{:ok, morphology}` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Morphology.html#load/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.load/1","doc":"iex> Bardo.Morphology.load(\"morph_123456789\")\n    {:ok, %{id: \"morph_123456789\", name: \"Simple XOR\", ...}}","ref":"Bardo.Morphology.html#load/1-examples"},{"type":"function","title":"Bardo.Morphology.neuron_count/1","doc":"Get the total number of neurons in a morphology.","ref":"Bardo.Morphology.html#neuron_count/1"},{"type":"function","title":"Parameters - Bardo.Morphology.neuron_count/1","doc":"* `morphology` - The morphology to get the neuron count for","ref":"Bardo.Morphology.html#neuron_count/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.neuron_count/1","doc":"* The total number of neurons","ref":"Bardo.Morphology.html#neuron_count/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.neuron_count/1","doc":"iex> morphology = Bardo.Morphology.new(%{inputs: 2, hidden_layers: [3], outputs: 1})\n    iex> Bardo.Morphology.neuron_count(morphology)\n    6","ref":"Bardo.Morphology.html#neuron_count/1-examples"},{"type":"function","title":"Bardo.Morphology.neuron_pattern/4","doc":"Define the neuron pattern for a neural network.","ref":"Bardo.Morphology.html#neuron_pattern/4"},{"type":"function","title":"Parameters - Bardo.Morphology.neuron_pattern/4","doc":"* `morphology` - The morphology to define the neuron pattern for\n  * `agent_id` - The ID of the agent\n  * `cortex_id` - The ID of the cortex\n  * `neural_interface` - A map with sensors and actuators data","ref":"Bardo.Morphology.html#neuron_pattern/4-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.neuron_pattern/4","doc":"* A map defining the neuron pattern","ref":"Bardo.Morphology.html#neuron_pattern/4-returns"},{"type":"function","title":"Bardo.Morphology.new/1","doc":"Create a new morphology with the given options.","ref":"Bardo.Morphology.html#new/1"},{"type":"function","title":"Parameters - Bardo.Morphology.new/1","doc":"* `opts` - A map of options for the morphology","ref":"Bardo.Morphology.html#new/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.new/1","doc":"* A new morphology struct","ref":"Bardo.Morphology.html#new/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.new/1","doc":"iex> Bardo.Morphology.new(%{name: \"Simple XOR\", dimensions: 2, inputs: 2, outputs: 1})\n    %{id: \"morph_xxxxxxxxxxx\", name: \"Simple XOR\", dimensions: 2, inputs: 2, outputs: 1, ...}","ref":"Bardo.Morphology.html#new/1-examples"},{"type":"function","title":"Bardo.Morphology.save/1","doc":"Save a morphology to the database.","ref":"Bardo.Morphology.html#save/1"},{"type":"function","title":"Parameters - Bardo.Morphology.save/1","doc":"* `morphology` - The morphology to save","ref":"Bardo.Morphology.html#save/1-parameters"},{"type":"function","title":"Returns - Bardo.Morphology.save/1","doc":"* `:ok` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Morphology.html#save/1-returns"},{"type":"function","title":"Examples - Bardo.Morphology.save/1","doc":"iex> morphology = Bardo.Morphology.new(%{name: \"Simple XOR\"})\n    iex> Bardo.Morphology.save(morphology)\n    :ok","ref":"Bardo.Morphology.html#save/1-examples"},{"type":"type","title":"Bardo.Morphology.sensor/0","doc":"Type definition for a sensor specification.","ref":"Bardo.Morphology.html#t:sensor/0"},{"type":"type","title":"Bardo.Morphology.substrate_cep/0","doc":"Type definition for a substrate connection expression producer.","ref":"Bardo.Morphology.html#t:substrate_cep/0"},{"type":"type","title":"Bardo.Morphology.substrate_cpp/0","doc":"Type definition for a substrate connection pattern producer.","ref":"Bardo.Morphology.html#t:substrate_cpp/0"},{"type":"type","title":"Bardo.Morphology.t/0","doc":"Type definition for a neural network morphology.","ref":"Bardo.Morphology.html#t:t/0"},{"type":"module","title":"Bardo.Persistence","doc":"Core persistence module for Bardo.\n\nThis module provides a high-level API for saving and loading models,\nsupporting both the default ETS-based storage and PostgreSQL storage\nfor distributed environments.\n\nIt handles serialization, compression, migrations, and provides a\nconsistent interface regardless of the underlying storage technology.","ref":"Bardo.Persistence.html"},{"type":"function","title":"Bardo.Persistence.backup/1","doc":"Create a backup of the database.","ref":"Bardo.Persistence.html#backup/1"},{"type":"function","title":"Parameters - Bardo.Persistence.backup/1","doc":"* `path` - Path to store the backup (default: \"backups\")","ref":"Bardo.Persistence.html#backup/1-parameters"},{"type":"function","title":"Returns - Bardo.Persistence.backup/1","doc":"* `{:ok, backup_file}` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Persistence.html#backup/1-returns"},{"type":"function","title":"Examples - Bardo.Persistence.backup/1","doc":"iex> Bardo.Persistence.backup(\"my_backups\")\n    {:ok, \"my_backups/bardo_backup_2025-05-07.db\"}","ref":"Bardo.Persistence.html#backup/1-examples"},{"type":"function","title":"Bardo.Persistence.delete/2","doc":"Delete a model from storage.","ref":"Bardo.Persistence.html#delete/2"},{"type":"function","title":"Parameters - Bardo.Persistence.delete/2","doc":"* `type` - The type of model to delete (e.g., :experiment, :population, :genotype)\n  * `id` - The ID of the model to delete","ref":"Bardo.Persistence.html#delete/2-parameters"},{"type":"function","title":"Returns - Bardo.Persistence.delete/2","doc":"* `:ok` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Persistence.html#delete/2-returns"},{"type":"function","title":"Examples - Bardo.Persistence.delete/2","doc":"iex> Bardo.Persistence.delete(:morphology, \"morph_123\")\n    :ok","ref":"Bardo.Persistence.html#delete/2-examples"},{"type":"function","title":"Bardo.Persistence.exists?/2","doc":"Check if a model exists in storage.","ref":"Bardo.Persistence.html#exists?/2"},{"type":"function","title":"Parameters - Bardo.Persistence.exists?/2","doc":"* `type` - The type of model to check (e.g., :experiment, :population, :genotype)\n  * `id` - The ID of the model to check","ref":"Bardo.Persistence.html#exists?/2-parameters"},{"type":"function","title":"Returns - Bardo.Persistence.exists?/2","doc":"* `true` if the model exists\n  * `false` if the model does not exist","ref":"Bardo.Persistence.html#exists?/2-returns"},{"type":"function","title":"Examples - Bardo.Persistence.exists?/2","doc":"iex> Bardo.Persistence.exists?(:morphology, \"morph_123\")\n    true\n    \n    iex> Bardo.Persistence.exists?(:experiment, \"nonexistent\")\n    false","ref":"Bardo.Persistence.html#exists?/2-examples"},{"type":"function","title":"Bardo.Persistence.export/3","doc":"Export a model to a file.","ref":"Bardo.Persistence.html#export/3"},{"type":"function","title":"Parameters - Bardo.Persistence.export/3","doc":"* `model` - The model to export\n  * `file_path` - Path to save the file\n  * `opts` - Additional options:\n    * `:format` - Format to export in (:erlang, :json, or :etf, default: :erlang)\n    * `:compress` - Whether to compress the file (default: false)","ref":"Bardo.Persistence.html#export/3-parameters"},{"type":"function","title":"Returns - Bardo.Persistence.export/3","doc":"* `:ok` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Persistence.html#export/3-returns"},{"type":"function","title":"Examples - Bardo.Persistence.export/3","doc":"iex> morphology = Bardo.Morphology.new(%{name: \"Test\"})\n    iex> Bardo.Persistence.export(morphology, \"test_morphology.etf\")\n    :ok","ref":"Bardo.Persistence.html#export/3-examples"},{"type":"function","title":"Bardo.Persistence.import/2","doc":"Import a model from a file.","ref":"Bardo.Persistence.html#import/2"},{"type":"function","title":"Parameters - Bardo.Persistence.import/2","doc":"* `file_path` - Path to the file to import\n  * `opts` - Additional options:\n    * `:format` - Format of the file (:erlang, :json, or :etf, default: auto-detect)\n    * `:decompress` - Whether to decompress the file (default: auto-detect)","ref":"Bardo.Persistence.html#import/2-parameters"},{"type":"function","title":"Returns - Bardo.Persistence.import/2","doc":"* `{:ok, model}` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Persistence.html#import/2-returns"},{"type":"function","title":"Examples - Bardo.Persistence.import/2","doc":"iex> Bardo.Persistence.import(\"test_morphology.etf\")\n    {:ok, %{id: \"morph_123\", name: \"Test\", ...}}","ref":"Bardo.Persistence.html#import/2-examples"},{"type":"function","title":"Bardo.Persistence.list/1","doc":"List all models of a given type.","ref":"Bardo.Persistence.html#list/1"},{"type":"function","title":"Parameters - Bardo.Persistence.list/1","doc":"* `type` - The type of models to list (e.g., :experiment, :population, :genotype)","ref":"Bardo.Persistence.html#list/1-parameters"},{"type":"function","title":"Returns - Bardo.Persistence.list/1","doc":"* `{:ok, [model]}` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Persistence.html#list/1-returns"},{"type":"function","title":"Examples - Bardo.Persistence.list/1","doc":"iex> Bardo.Persistence.list(:morphology)\n    {:ok, [%{id: \"morph_123\", name: \"Test\", ...}, ...]}","ref":"Bardo.Persistence.html#list/1-examples"},{"type":"function","title":"Bardo.Persistence.load/3","doc":"Load a model from storage.","ref":"Bardo.Persistence.html#load/3"},{"type":"function","title":"Parameters - Bardo.Persistence.load/3","doc":"* `type` - The type of model to load (e.g., :experiment, :population, :genotype)\n  * `id` - The ID of the model to load\n  * `opts` - Additional options:\n    * `:decompress` - Whether to decompress the model (default: auto-detect)\n    * `:format` - Expected format (:erlang or :json, default: auto-detect)","ref":"Bardo.Persistence.html#load/3-parameters"},{"type":"function","title":"Returns - Bardo.Persistence.load/3","doc":"* `{:ok, model}` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Persistence.html#load/3-returns"},{"type":"function","title":"Examples - Bardo.Persistence.load/3","doc":"iex> Bardo.Persistence.load(:morphology, \"morph_123\")\n    {:ok, %{id: \"morph_123\", name: \"Test\", ...}}\n    \n    iex> Bardo.Persistence.load(:experiment, \"exp_123\")\n    {:ok, %{id: \"exp_123\", data: %{name: \"Test Experiment\"}}}","ref":"Bardo.Persistence.html#load/3-examples"},{"type":"function","title":"Bardo.Persistence.restore/1","doc":"Restore from a backup.","ref":"Bardo.Persistence.html#restore/1"},{"type":"function","title":"Parameters - Bardo.Persistence.restore/1","doc":"* `backup_file` - Path to the backup file","ref":"Bardo.Persistence.html#restore/1-parameters"},{"type":"function","title":"Returns - Bardo.Persistence.restore/1","doc":"* `:ok` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Persistence.html#restore/1-returns"},{"type":"function","title":"Examples - Bardo.Persistence.restore/1","doc":"iex> Bardo.Persistence.restore(\"backups/bardo_backup_2025-05-07.db\")\n    :ok","ref":"Bardo.Persistence.html#restore/1-examples"},{"type":"function","title":"Bardo.Persistence.save/4","doc":"Save a model to storage.","ref":"Bardo.Persistence.html#save/4"},{"type":"function","title":"Parameters - Bardo.Persistence.save/4","doc":"* `model` - The model to save\n  * `type` - The type of model (e.g., :experiment, :population, :genotype)\n  * `id` - Optional ID for the model (if not provided, extracted from the model)\n  * `opts` - Additional options:\n    * `:compress` - Whether to compress the model (default: false)\n    * `:format` - Format to save in (:erlang or :json, default: :erlang)\n    * `:version` - Schema version for future migrations","ref":"Bardo.Persistence.html#save/4-parameters"},{"type":"function","title":"Returns - Bardo.Persistence.save/4","doc":"* `:ok` on success\n  * `{:error, reason}` on failure","ref":"Bardo.Persistence.html#save/4-returns"},{"type":"function","title":"Examples - Bardo.Persistence.save/4","doc":"iex> morphology = Bardo.Morphology.new(%{name: \"Test\"})\n    iex> Bardo.Persistence.save(morphology, :morphology)\n    :ok\n    \n    iex> experiment = %{id: \"exp_123\", data: %{name: \"Test Experiment\"}}\n    iex> Bardo.Persistence.save(experiment, :experiment)\n    :ok","ref":"Bardo.Persistence.html#save/4-examples"},{"type":"module","title":"Bardo.Plasticity","doc":"Contains plasticity functions for neural network learning.\n\nTrue learning is not achieved when a static NN is trained on some data set through \ndestruction and recreation by the exoself based on its performance, but instead is \nthe self organization of the NN, the self adaptation and changing of the NN based \non the information it is processing.\n\nThe learning rule, the way in which the neurons adapt independently, the way in which \ntheir synaptic weights change based on the neuron's experience, that is true learning, \nand that is neuroplasticity.\n\nThere are numerous plasticity rules, some more faithful to their biological counterparts \nthan others, and some more efficient than their biological counterparts.\n\nNote: The self_modulation_v1, self_modulation_v2, and self_modulation_v3 are all very \nsimilar, mainly differing in the parameter lists returned by the \nPlasticityFunctionName(neural_parameters) function. All three of these plasticity \nfunctions use the neuromodulation/5 function which accepts the H, A, B, C, and D \nlearning parameters, and updates the synaptic weights of the neuron using the general \nHebbian rule: Updated_Wi = Wi + H*(A*Ii*Output + B*Ii + C*Output + D).\n\nThe self_modulation_v4  v5 differ only in that the weight_parameters is a list of length 2, \nand the A parameter is no longer specified in the neural_parameters list, and is instead \ncalculated by the second dedicated modulatory neuron.\n\nThe self_modulation_v6 function specifies the neural_parameters as an empty list, and the\nweight_parameters list is of length 5, a single weight for every embedded modulatory neuron.","ref":"Bardo.Plasticity.html"},{"type":"function","title":"Bardo.Plasticity.apply/2","doc":"Apply a plasticity function by name to get parameters.\n\nThis is a convenience function that routes to the appropriate plasticity function\nbased on the provided name.","ref":"Bardo.Plasticity.html#apply/2"},{"type":"function","title":"Bardo.Plasticity.hebbian/1","doc":"Returns parameters for the hebbian learning rule.\n\nThe parameter list for the standard hebbian learning rule is a parameter list \ncomposed of a single parameter H: [H], used by the neuron for all its synaptic weights.","ref":"Bardo.Plasticity.html#hebbian/1"},{"type":"function","title":"Bardo.Plasticity.hebbian/4","doc":"Hebbian plasticity function with a global learning rate.\n\nThe function applies the hebbian learning rule to all weights using a single,\nneuron-wide learning rate.","ref":"Bardo.Plasticity.html#hebbian/4"},{"type":"function","title":"Bardo.Plasticity.hebbian_w/1","doc":"Returns parameters for the hebbian_w learning rule.\n\nThe parameter list for the simple hebbian_w learning rule is a parameter list \ncomposed of a single parameter H: [H], for every synaptic weight of the neuron.","ref":"Bardo.Plasticity.html#hebbian_w/1"},{"type":"function","title":"Bardo.Plasticity.hebbian_w/4","doc":"Hebbian plasticity function with weight-specific learning rates.\n\nThe function operates on each InputPidP, applying the hebbian learning rule to each\nweight using its own specific learning rate.","ref":"Bardo.Plasticity.html#hebbian_w/4"},{"type":"function","title":"Bardo.Plasticity.neuromodulation/1","doc":"Returns parameters for the neuromodulation learning rule.\n\nNeuromodulation is a form of heterosynaptic plasticity where the synaptic weights \nare changed due to the synaptic activity of other neurons.","ref":"Bardo.Plasticity.html#neuromodulation/1"},{"type":"function","title":"Bardo.Plasticity.neuromodulation/4","doc":"Neuromodulation plasticity function.\n\nUpdates the synaptic weights of the neuron using a modulated Hebbian learning rule.","ref":"Bardo.Plasticity.html#neuromodulation/4"},{"type":"function","title":"Bardo.Plasticity.none/1","doc":"Returns a set of learning parameters needed by the none/4 plasticity function.\n\nSince this function specifies that the neuron has no plasticity, the parameter lists are empty.\nWhen executed with the {neuron_id, :mutate} parameter, the function exits, since there is\nnothing to mutate. The exit allows for the neuroevolutionary system to try another mutation\noperator on the NN system.","ref":"Bardo.Plasticity.html#none/1"},{"type":"function","title":"Bardo.Plasticity.none/4","doc":"None plasticity function - no learning happens.\n\nReturns the original InputPidPs to the caller.","ref":"Bardo.Plasticity.html#none/4"},{"type":"function","title":"Bardo.Plasticity.ojas/1","doc":"Returns parameters for the ojas learning rule.\n\nThe parameter list for Oja's learning rule is a list composed of a single parameter \nH: [H], used by the neuron for all its synaptic weights.","ref":"Bardo.Plasticity.html#ojas/1"},{"type":"function","title":"Bardo.Plasticity.ojas/4","doc":"Oja's plasticity function with a global learning rate.\n\nThe function applies Oja's learning rule to all weights using a single,\nneuron-wide learning rate.","ref":"Bardo.Plasticity.html#ojas/4"},{"type":"function","title":"Bardo.Plasticity.ojas_w/1","doc":"Returns parameters for the ojas_w learning rule.\n\nThe parameter list for Oja's learning rule is a list composed of a single parameter \nH: [H] per synaptic weight.","ref":"Bardo.Plasticity.html#ojas_w/1"},{"type":"function","title":"Bardo.Plasticity.ojas_w/4","doc":"Oja's plasticity function with weight-specific learning rates.\n\nThe function operates on each InputPidP, applying Oja's learning rule to each\nweight using its own specific learning rate.","ref":"Bardo.Plasticity.html#ojas_w/4"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v1/1","doc":"Returns parameters for the self_modulation_v1 learning rule.\n\nVersion-1: where the secondary embedded neuron only outputs the H learning parameter, \nwith the parameter A set to some predetermined constant value within the neural_parameters \nlist, and B=C=D=0.","ref":"Bardo.Plasticity.html#self_modulation_v1/1"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v1/4","doc":"Self modulation plasticity function (version 1).\n\nUpdates the synaptic weights of the neuron using a modulated Hebbian learning rule.","ref":"Bardo.Plasticity.html#self_modulation_v1/4"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v2/1","doc":"Returns parameters for the self_modulation_v2 learning rule.\n\nVersion-2: where A is generated randomly when generating the neural_parameters list, \nand B=C=D=0.","ref":"Bardo.Plasticity.html#self_modulation_v2/1"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v2/4","doc":"Self modulation plasticity function (version 2).\n\nUpdates the synaptic weights of the neuron using a modulated Hebbian learning rule.","ref":"Bardo.Plasticity.html#self_modulation_v2/4"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v3/1","doc":"Returns parameters for the self_modulation_v3 learning rule.\n\nVersion-3: where B, C, and D are also generated randomly in the neural_parameters list.","ref":"Bardo.Plasticity.html#self_modulation_v3/1"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v3/4","doc":"Self modulation plasticity function (version 3).\n\nUpdates the synaptic weights of the neuron using a modulated Hebbian learning rule.","ref":"Bardo.Plasticity.html#self_modulation_v3/4"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v4/1","doc":"Returns parameters for the self_modulation_v4 learning rule.\n\nVersion-4: where the weight_parameters generates a list of length 2, thus allowing \nthe neuron to have 2 embedded modulatory neurons, one outputting a parameter we use \nfor H, and another outputting the value we can use as A, with B=C=D=0.","ref":"Bardo.Plasticity.html#self_modulation_v4/1"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v4/4","doc":"Self modulation plasticity function (version 4).\n\nUpdates the synaptic weights of the neuron using a modulated Hebbian learning rule.","ref":"Bardo.Plasticity.html#self_modulation_v4/4"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v5/1","doc":"Returns parameters for the self_modulation_v5 learning rule.\n\nVersion-5: Where B, C, and D are generated randomly by the \nPlasticityFunctionName(neural_parameters) function.","ref":"Bardo.Plasticity.html#self_modulation_v5/1"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v5/4","doc":"Self modulation plasticity function (version 5).\n\nUpdates the synaptic weights of the neuron using a modulated Hebbian learning rule.","ref":"Bardo.Plasticity.html#self_modulation_v5/4"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v6/1","doc":"Returns parameters for the self_modulation_v6 learning rule.\n\nVersion-6: Where the weight_parameters produces a list of length 5, allowing the neuron \nto have 5 embedded modulatory neurons, whose outputs are used for H, A, B, C, and D.","ref":"Bardo.Plasticity.html#self_modulation_v6/1"},{"type":"function","title":"Bardo.Plasticity.self_modulation_v6/4","doc":"Self modulation plasticity function (version 6).\n\nUpdates the synaptic weights of the neuron using a modulated Hebbian learning rule.","ref":"Bardo.Plasticity.html#self_modulation_v6/4"},{"type":"module","title":"Bardo.Polis.Manager","doc":"The PolisManager process represents an interfacing point with the\nneuroevolutionary platform infrastructure. The module contains the\nfunctions that perform general, global tasks. Because there should be\nonly a single polis_manager per node, representing\na single neuroevolutionary platform per node.\n\nThe following list summarizes the types of functions we want to be able to execute\nthrough the polis_manager module:\n 1. Start all the neuroevolutionary platform supporting processes\n 2. Stop and shut down the neuroevolutionary platform\n \nThe PolisManager is the infrastructure and the system within which the\nthe NN based agents, and the scapes they interface with,\nexist. It is for this reason that it was given the name 'polis', an\nindependent and self governing city state of intelligent agents.","ref":"Bardo.Polis.Manager.html"},{"type":"function","title":"Bardo.Polis.Manager.backup_and_shutdown/0","doc":"Backs up the DB and shuts down the application.","ref":"Bardo.Polis.Manager.html#backup_and_shutdown/0"},{"type":"function","title":"Bardo.Polis.Manager.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.Polis.Manager.html#child_spec/1"},{"type":"function","title":"Bardo.Polis.Manager.evolve_generation/1","doc":"Evolve the next generation for a polis instance.","ref":"Bardo.Polis.Manager.html#evolve_generation/1"},{"type":"function","title":"Bardo.Polis.Manager.prep/1","doc":"The prep function first checks whether a polis_manager process is online.\nIf there is an online polis_manager process running on the node, then the\nprep function preps the system. Otherwise, it returns an error.","ref":"Bardo.Polis.Manager.html#prep/1"},{"type":"function","title":"Bardo.Polis.Manager.send_command/2","doc":"Send a command to a polis instance.","ref":"Bardo.Polis.Manager.html#send_command/2"},{"type":"function","title":"Bardo.Polis.Manager.setup/1","doc":"The setup function first checks whether a polis_manager process is online.\nIf there is an online polis_manager process running on the node, then the\nsetup function configures the system and starts the public\nscape if any. Otherwise, it returns an error.","ref":"Bardo.Polis.Manager.html#setup/1"},{"type":"function","title":"Bardo.Polis.Manager.start_link/0","doc":"Starts the PolisManager process.\nThe start_link first checks whether a polis_manager process has already been\nspawned, by checking if one is registered. If it's not, then the\nGenServer.start_link function starts up the neuroevolutionary\nplatform. Otherwise, it returns an error.","ref":"Bardo.Polis.Manager.html#start_link/0"},{"type":"function","title":"Bardo.Polis.Manager.start_link/1","doc":"","ref":"Bardo.Polis.Manager.html#start_link/1"},{"type":"function","title":"Bardo.Polis.Manager.stop/0","doc":"All applications are taken down smoothly, all code is unloaded, and all\nports are closed before the system terminates by calling halt(Status).\nThe stop function first checks whether a polis_manager process is online.\nIf there is an online polis_manager process running on the node, then the\nstop function sends a signal to it requesting it to stop. Otherwise,\nit shutdowns immediately.","ref":"Bardo.Polis.Manager.html#stop/0"},{"type":"function","title":"Bardo.Polis.Manager.stop_instance/1","doc":"Stop a specific polis instance.","ref":"Bardo.Polis.Manager.html#stop_instance/1"},{"type":"function","title":"Bardo.Polis.Manager.update_population/2","doc":"Update the population for a polis instance.","ref":"Bardo.Polis.Manager.html#update_population/2"},{"type":"module","title":"Bardo.Polis.Supervisor","doc":"Supervisor for the Polis systems.\n\nThe Polis manages the core subsystems of Bardo:\n\n- AgentManager: Handles individual neural network agents\n- PopulationManager: Manages populations of evolving agents\n- ExperimentManager: Coordinates experiments across populations\n- ScapeManager: Provides evaluation environments for agents\n\nEach subsystem has its own supervisor hierarchy to ensure proper fault\ntolerance and lifecycle management.","ref":"Bardo.Polis.Supervisor.html"},{"type":"function","title":"Bardo.Polis.Supervisor.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.Polis.Supervisor.html#child_spec/1"},{"type":"function","title":"Bardo.Polis.Supervisor.start_link/1","doc":"Starts the supervisor.","ref":"Bardo.Polis.Supervisor.html#start_link/1"},{"type":"function","title":"Parameters - Bardo.Polis.Supervisor.start_link/1","doc":"* `args` - Optional arguments for the supervisor","ref":"Bardo.Polis.Supervisor.html#start_link/1-parameters"},{"type":"function","title":"Returns - Bardo.Polis.Supervisor.start_link/1","doc":"* `{:ok, pid}` - PID of the started supervisor process","ref":"Bardo.Polis.Supervisor.html#start_link/1-returns"},{"type":"behaviour","title":"Bardo.PopulationManager.ExtendedMorphology","doc":"Defines an extended morphology behavior that builds on the basic Morphology\nbehavior by adding additional callbacks needed for complex examples.\n\nThis behavior includes additional callbacks used by the DPB, Flatland, and FX examples\nthat were not in the basic Morphology behavior.","ref":"Bardo.PopulationManager.ExtendedMorphology.html"},{"type":"callback","title":"Bardo.PopulationManager.ExtendedMorphology.get_phys_config/3","doc":"The get_phys_config callback returns the physical configuration for an agent,\nincluding its sensors and actuators.","ref":"Bardo.PopulationManager.ExtendedMorphology.html#c:get_phys_config/3"},{"type":"callback","title":"Bardo.PopulationManager.ExtendedMorphology.get_scape_params/4","doc":"The get_scape_params callback returns the parameters required for an agent\nto enter a scape.","ref":"Bardo.PopulationManager.ExtendedMorphology.html#c:get_scape_params/4"},{"type":"callback","title":"Bardo.PopulationManager.ExtendedMorphology.neuron_pattern/4","doc":"The neuron_pattern callback defines how sensors and actuators connect to\nthe neural network.","ref":"Bardo.PopulationManager.ExtendedMorphology.html#c:neuron_pattern/4"},{"type":"module","title":"Bardo.PopulationManager.PopulationManager","doc":"The population_manager is a process that spawns a population of neural network\nsystems, monitors their performance, applies a selection algorithm to\nthe NNs in the population, and generates the mutant offspring from\nthe fit NNs, while removing the unfit. The population_manager module\nis the one responsible for mapping the genotypes to their phenotypes.\n\nA population is a group of agents, in a neuroevolutionary system\nthose agents are NN based systems. The genotypes of our NN's\nare represented as lists of structs. In our system, each\nNN genome is composed of a single cortex, one or more sensors, one or\nmore actuators, and one or more neurons. Each element of the NN system\nknows what other elements it is connected to through element ids.\n\nDuring one of our simulations we might want to start the experiment\nwith many different species. Since the NN's depend on their\nmorphologies, we can create a population with two different species,\neach with it own morphology. Then, when the NN's are created in those\nspecies, they would naturally start off with different sets available\nto them and belonging to the particular species they were seeded in.\n\nThe offspring are created through cloning and mutation. Not all fit\nagents are equal, some are more equal than others, some have a higher\nfitness level. Though all the fit agents will survive to the next\ngeneration, the number of offspring each agent creates will depend on\nthat agent's fitness. The population_manager will decide how many offspring\nto allocate to each agent. The offspring will be created by first\ncloning the fit agent, and then by mutating the clone to produce a\nvariation, a mutant, of it. The clone, with its own unique id, is\nassigned to the same specie that its parent belongs to. Once all the\noffspring are created, where \"all\" means the same number as was deleted\nduring the selection process, the new generation of agents is then\nreleased back into the scape, or applied again to the problem. Then,\nthe evolutionary cycle repeats.","ref":"Bardo.PopulationManager.PopulationManager.html"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.agent_terminated/1","doc":"The agent_terminated accepts the requests sent by the agents\nwhich terminate after finishing with their evaluations. The function\nspecializes in the \"competition\" selection algorithm, which is a\ngenerational selection algorithm. As a generation selection\nalgorithm, it waits until the entire population has finished being\nevaluated, and only then selects the fit from the unfit, and creates\nthe updated population of the next generation. The OpTag can be set\nfrom the outside to shutdown the population_manager by setting it to\ndone. Once an ending condition is reached, either through a\ngeneration limit, an evaluations limit, or fitness goal, the\npopulation_manager exits normally. If the ending condition is not\nreached, the population_manager spawns the new generation of agents\nand awaits again for all the agents in the population to complete\ntheir evaluations. If the OpTag is set to pause, it does not\ngenerate a new population, and instead goes into a waiting mode, and\nawaits to be restarted or terminated.","ref":"Bardo.PopulationManager.PopulationManager.html#agent_terminated/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.calculate_specie_avg_nodes/1","doc":"Calculate the average number of neurons per agent in a specie.","ref":"Bardo.PopulationManager.PopulationManager.html#calculate_specie_avg_nodes/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.calculate_specie_diversity/1","doc":"Calculate the diversity of agents in a specie based on their fingerprints.","ref":"Bardo.PopulationManager.PopulationManager.html#calculate_specie_diversity/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.calculate_specie_fitness/1","doc":"Calculate the fitness statistics for a specie.","ref":"Bardo.PopulationManager.PopulationManager.html#calculate_specie_fitness/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.child_spec/1","doc":"","ref":"Bardo.PopulationManager.PopulationManager.html#child_spec/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.gather_stats/3","doc":"Gather statistics for all species in a population.","ref":"Bardo.PopulationManager.PopulationManager.html#gather_stats/3"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.set_evaluations/4","doc":"The set_evaluations function is called after the agent has completed\nits evaluation run. It calculates the total number of evaluations,\ngathers stats, etc.","ref":"Bardo.PopulationManager.PopulationManager.html#set_evaluations/4"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.set_goal_reached/0","doc":"The set_goal_reached function sets the goal_reached flag of the\npopulation_manager to true.","ref":"Bardo.PopulationManager.PopulationManager.html#set_goal_reached/0"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.set_op_tag/1","doc":"The population_manager process accepts a pause command, which\nif it receives, it then goes into pause mode after all the agents\nhave completed with their evaluations. The process can only go into\npause mode if it is currently in the continue mode (its op_tag is\nset to continue). The population_manager process can accept a\ncontinue command if its current op_tag is set to pause. When it\nreceives a continue command, it summons all the agents in the\npopulation, and continues with its neuroevolution synchronization\nduties.","ref":"Bardo.PopulationManager.PopulationManager.html#set_op_tag/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.start/1","doc":"Spawns a PopulationManager process and calls init to initialize.","ref":"Bardo.PopulationManager.PopulationManager.html#start/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.start_link/1","doc":"Starts a linked GenServer process for the PopulationManager.\nThis function is used by supervision trees.","ref":"Bardo.PopulationManager.PopulationManager.html#start_link/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManager.validation_complete/2","doc":"The validation_complete function is called after the validation test\nrun has completed. It returns the fitness score of the validation test\nagent.","ref":"Bardo.PopulationManager.PopulationManager.html#validation_complete/2"},{"type":"module","title":"Bardo.PopulationManager.PopulationManagerClient","doc":"Client module for interacting with the PopulationManager.","ref":"Bardo.PopulationManager.PopulationManagerClient.html"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerClient.agent_terminated/1","doc":"Notifies the population manager that an agent has terminated.","ref":"Bardo.PopulationManager.PopulationManagerClient.html#agent_terminated/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerClient.new_run/0","doc":"Sends a message to start a new population manager run.","ref":"Bardo.PopulationManager.PopulationManagerClient.html#new_run/0"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerClient.restart_run/0","doc":"Sends a message to restart a population manager run.","ref":"Bardo.PopulationManager.PopulationManagerClient.html#restart_run/0"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerClient.set_evaluations/4","doc":"Sends evaluation data to the population manager.","ref":"Bardo.PopulationManager.PopulationManagerClient.html#set_evaluations/4"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerClient.set_goal_reached/0","doc":"Notifies the population manager that a goal has been reached.","ref":"Bardo.PopulationManager.PopulationManagerClient.html#set_goal_reached/0"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerClient.set_op_tag/1","doc":"Sets the operation tag for the population manager.","ref":"Bardo.PopulationManager.PopulationManagerClient.html#set_op_tag/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerClient.stop/1","doc":"Stops a population manager run with the specified ID.","ref":"Bardo.PopulationManager.PopulationManagerClient.html#stop/1"},{"type":"function","title":"Parameters - Bardo.PopulationManager.PopulationManagerClient.stop/1","doc":"* `population_id` - ID of the population to stop","ref":"Bardo.PopulationManager.PopulationManagerClient.html#stop/1-parameters"},{"type":"function","title":"Returns - Bardo.PopulationManager.PopulationManagerClient.stop/1","doc":"* `:ok` - If the population was stopped successfully\n  * `{:error, :not_found}` - If the population was not found","ref":"Bardo.PopulationManager.PopulationManagerClient.html#stop/1-returns"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerClient.validation_complete/2","doc":"Notifies the population manager that validation is complete with the given fitness.","ref":"Bardo.PopulationManager.PopulationManagerClient.html#validation_complete/2"},{"type":"module","title":"Bardo.PopulationManager.PopulationManagerSupervisor","doc":"Dynamic supervisor for population manager workers.\n\nThis module provides helper functions for starting, stopping and managing\npopulation workers, which handle the evolutionary process for populations\nof neural networks.","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerSupervisor.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#child_spec/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerSupervisor.count_populations/0","doc":"Get the count of running populations.","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#count_populations/0"},{"type":"function","title":"Returns - Bardo.PopulationManager.PopulationManagerSupervisor.count_populations/0","doc":"* `{:ok, count}` - The number of running population workers","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#count_populations/0-returns"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerSupervisor.list_populations/0","doc":"List all running population IDs.","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#list_populations/0"},{"type":"function","title":"Returns - Bardo.PopulationManager.PopulationManagerSupervisor.list_populations/0","doc":"* `{:ok, [atom()]}` - List of running population IDs","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#list_populations/0-returns"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerSupervisor.start_link/1","doc":"Starts the supervisor.","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#start_link/1"},{"type":"function","title":"Parameters - Bardo.PopulationManager.PopulationManagerSupervisor.start_link/1","doc":"* `args` - Optional arguments for the supervisor","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#start_link/1-parameters"},{"type":"function","title":"Returns - Bardo.PopulationManager.PopulationManagerSupervisor.start_link/1","doc":"* `{:ok, pid}` - PID of the started supervisor process","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#start_link/1-returns"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerSupervisor.start_population/2","doc":"Start a new population worker under the dynamic supervisor.","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#start_population/2"},{"type":"function","title":"Parameters - Bardo.PopulationManager.PopulationManagerSupervisor.start_population/2","doc":"* `population_id` - Unique identifier for the population\n  * `params` - Parameters for the population, including experiment ID, size, etc.","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#start_population/2-parameters"},{"type":"function","title":"Returns - Bardo.PopulationManager.PopulationManagerSupervisor.start_population/2","doc":"* `{:ok, pid}` - If the worker was started successfully\n  * `{:error, reason}` - If there was an error starting the worker","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#start_population/2-returns"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerSupervisor.stop_population/1","doc":"Stop a population worker.","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#stop_population/1"},{"type":"function","title":"Parameters - Bardo.PopulationManager.PopulationManagerSupervisor.stop_population/1","doc":"* `population_id` - Unique identifier for the population","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#stop_population/1-parameters"},{"type":"function","title":"Returns - Bardo.PopulationManager.PopulationManagerSupervisor.stop_population/1","doc":"* `:ok` - If the worker was stopped successfully\n  * `{:error, :not_found}` - If the worker was not found","ref":"Bardo.PopulationManager.PopulationManagerSupervisor.html#stop_population/1-returns"},{"type":"module","title":"Bardo.PopulationManager.PopulationManagerWorker","doc":"The PopulationManagerWorker is responsible for spawning the population_manager\nprocess.","ref":"Bardo.PopulationManager.PopulationManagerWorker.html"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerWorker.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.PopulationManager.PopulationManagerWorker.html#child_spec/1"},{"type":"function","title":"Bardo.PopulationManager.PopulationManagerWorker.start_link/0","doc":"The start_link function spawns the PopulationManagerWorker server.","ref":"Bardo.PopulationManager.PopulationManagerWorker.html#start_link/0"},{"type":"module","title":"Bardo.PopulationManager.SpecieIdentifier","doc":"The specie_identifier module is a container for the\nspecie_identifier functions. By keeping all the identifier\nfunctions in this module, it makes it easier for us to later\nadd new ones, and then simply reference them by their name.","ref":"Bardo.PopulationManager.SpecieIdentifier.html"},{"type":"function","title":"Bardo.PopulationManager.SpecieIdentifier.tot_n/1","doc":"Identifies species based on the number of neurons.","ref":"Bardo.PopulationManager.SpecieIdentifier.html#tot_n/1"},{"type":"module","title":"Bardo.PopulationManager.Supervisor","doc":"Supervisor for the PopulationManager system.\n\nThis supervisor manages the population manager and population worker processes,\nwhich are responsible for evolving populations of neural networks for various tasks.","ref":"Bardo.PopulationManager.Supervisor.html"},{"type":"function","title":"Bardo.PopulationManager.Supervisor.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.PopulationManager.Supervisor.html#child_spec/1"},{"type":"function","title":"Bardo.PopulationManager.Supervisor.start_link/1","doc":"Starts the supervisor.","ref":"Bardo.PopulationManager.Supervisor.html#start_link/1"},{"type":"function","title":"Parameters - Bardo.PopulationManager.Supervisor.start_link/1","doc":"* `args` - Optional arguments for the supervisor","ref":"Bardo.PopulationManager.Supervisor.html#start_link/1-parameters"},{"type":"function","title":"Returns - Bardo.PopulationManager.Supervisor.start_link/1","doc":"* `{:ok, pid}` - PID of the started supervisor process","ref":"Bardo.PopulationManager.Supervisor.html#start_link/1-returns"},{"type":"module","title":"Bardo.PopulationManager.TotTopologicalMutations","doc":"Since there are many ways to calculate TotMutations, we create the\ntot_topological_mutations module, which can store the different\nfunctions which can calculate this value.","ref":"Bardo.PopulationManager.TotTopologicalMutations.html"},{"type":"function","title":"Bardo.PopulationManager.TotTopologicalMutations.ncount_exponential/2","doc":"ncount_exponential calculates TotMutations by putting the size of\nthe NN to some power Power.","ref":"Bardo.PopulationManager.TotTopologicalMutations.html#ncount_exponential/2"},{"type":"function","title":"Bardo.PopulationManager.TotTopologicalMutations.ncount_linear/2","doc":"ncount_linear calculates TotMutations by multiplying the size of\nthe NN by the value Multiplier.","ref":"Bardo.PopulationManager.TotTopologicalMutations.html#ncount_linear/2"},{"type":"module","title":"Bardo.Repo","doc":"Bardo's Ecto repository for database access.\n\nThis module provides the Ecto repository for Bardo, enabling\nthe application to interact with the database using Ecto.","ref":"Bardo.Repo.html"},{"type":"function","title":"Bardo.Repo.aggregate/3","doc":"","ref":"Bardo.Repo.html#aggregate/3"},{"type":"function","title":"Bardo.Repo.aggregate/4","doc":"","ref":"Bardo.Repo.html#aggregate/4"},{"type":"function","title":"Bardo.Repo.all/2","doc":"","ref":"Bardo.Repo.html#all/2"},{"type":"function","title":"Bardo.Repo.checked_out?/0","doc":"","ref":"Bardo.Repo.html#checked_out?/0"},{"type":"function","title":"Bardo.Repo.checkout/2","doc":"","ref":"Bardo.Repo.html#checkout/2"},{"type":"function","title":"Bardo.Repo.child_spec/1","doc":"","ref":"Bardo.Repo.html#child_spec/1"},{"type":"function","title":"Bardo.Repo.config/0","doc":"","ref":"Bardo.Repo.html#config/0"},{"type":"function","title":"Bardo.Repo.default_options/1","doc":"","ref":"Bardo.Repo.html#default_options/1"},{"type":"function","title":"Bardo.Repo.delete/2","doc":"","ref":"Bardo.Repo.html#delete/2"},{"type":"function","title":"Bardo.Repo.delete!/2","doc":"","ref":"Bardo.Repo.html#delete!/2"},{"type":"function","title":"Bardo.Repo.delete_all/2","doc":"","ref":"Bardo.Repo.html#delete_all/2"},{"type":"function","title":"Bardo.Repo.disconnect_all/2","doc":"A convenience function for SQL-based repositories that forces all connections in the\npool to disconnect within the given interval.\n\nSee `Ecto.Adapters.SQL.disconnect_all/3` for more information.","ref":"Bardo.Repo.html#disconnect_all/2"},{"type":"function","title":"Bardo.Repo.exists?/2","doc":"","ref":"Bardo.Repo.html#exists?/2"},{"type":"function","title":"Bardo.Repo.explain/3","doc":"A convenience function for SQL-based repositories that executes an EXPLAIN statement or similar\ndepending on the adapter to obtain statistics for the given query.\n\nSee `Ecto.Adapters.SQL.explain/4` for more information.","ref":"Bardo.Repo.html#explain/3"},{"type":"function","title":"Bardo.Repo.get/3","doc":"","ref":"Bardo.Repo.html#get/3"},{"type":"function","title":"Bardo.Repo.get!/3","doc":"","ref":"Bardo.Repo.html#get!/3"},{"type":"function","title":"Bardo.Repo.get_by/3","doc":"","ref":"Bardo.Repo.html#get_by/3"},{"type":"function","title":"Bardo.Repo.get_by!/3","doc":"","ref":"Bardo.Repo.html#get_by!/3"},{"type":"function","title":"Bardo.Repo.get_dynamic_repo/0","doc":"","ref":"Bardo.Repo.html#get_dynamic_repo/0"},{"type":"function","title":"Bardo.Repo.in_transaction?/0","doc":"","ref":"Bardo.Repo.html#in_transaction?/0"},{"type":"function","title":"Bardo.Repo.insert/2","doc":"","ref":"Bardo.Repo.html#insert/2"},{"type":"function","title":"Bardo.Repo.insert!/2","doc":"","ref":"Bardo.Repo.html#insert!/2"},{"type":"function","title":"Bardo.Repo.insert_all/3","doc":"","ref":"Bardo.Repo.html#insert_all/3"},{"type":"function","title":"Bardo.Repo.insert_or_update/2","doc":"","ref":"Bardo.Repo.html#insert_or_update/2"},{"type":"function","title":"Bardo.Repo.insert_or_update!/2","doc":"","ref":"Bardo.Repo.html#insert_or_update!/2"},{"type":"function","title":"Bardo.Repo.load/2","doc":"","ref":"Bardo.Repo.html#load/2"},{"type":"function","title":"Bardo.Repo.one/2","doc":"","ref":"Bardo.Repo.html#one/2"},{"type":"function","title":"Bardo.Repo.one!/2","doc":"","ref":"Bardo.Repo.html#one!/2"},{"type":"function","title":"Bardo.Repo.preload/3","doc":"","ref":"Bardo.Repo.html#preload/3"},{"type":"function","title":"Bardo.Repo.prepare_query/3","doc":"","ref":"Bardo.Repo.html#prepare_query/3"},{"type":"function","title":"Bardo.Repo.put_dynamic_repo/1","doc":"","ref":"Bardo.Repo.html#put_dynamic_repo/1"},{"type":"function","title":"Bardo.Repo.query/3","doc":"A convenience function for SQL-based repositories that executes the given query.\n\nSee `Ecto.Adapters.SQL.query/4` for more information.","ref":"Bardo.Repo.html#query/3"},{"type":"function","title":"Bardo.Repo.query!/3","doc":"A convenience function for SQL-based repositories that executes the given query.\n\nSee `Ecto.Adapters.SQL.query!/4` for more information.","ref":"Bardo.Repo.html#query!/3"},{"type":"function","title":"Bardo.Repo.query_many/3","doc":"A convenience function for SQL-based repositories that executes the given multi-result query.\n\nSee `Ecto.Adapters.SQL.query_many/4` for more information.","ref":"Bardo.Repo.html#query_many/3"},{"type":"function","title":"Bardo.Repo.query_many!/3","doc":"A convenience function for SQL-based repositories that executes the given multi-result query.\n\nSee `Ecto.Adapters.SQL.query_many!/4` for more information.","ref":"Bardo.Repo.html#query_many!/3"},{"type":"function","title":"Bardo.Repo.reload/2","doc":"","ref":"Bardo.Repo.html#reload/2"},{"type":"function","title":"Bardo.Repo.reload!/2","doc":"","ref":"Bardo.Repo.html#reload!/2"},{"type":"function","title":"Bardo.Repo.rollback/1","doc":"","ref":"Bardo.Repo.html#rollback/1"},{"type":"function","title":"Bardo.Repo.start_link/1","doc":"","ref":"Bardo.Repo.html#start_link/1"},{"type":"function","title":"Bardo.Repo.stop/1","doc":"","ref":"Bardo.Repo.html#stop/1"},{"type":"function","title":"Bardo.Repo.stream/2","doc":"","ref":"Bardo.Repo.html#stream/2"},{"type":"function","title":"Bardo.Repo.to_sql/2","doc":"A convenience function for SQL-based repositories that translates the given query to SQL.\n\nSee `Ecto.Adapters.SQL.to_sql/3` for more information.","ref":"Bardo.Repo.html#to_sql/2"},{"type":"function","title":"Bardo.Repo.transaction/2","doc":"","ref":"Bardo.Repo.html#transaction/2"},{"type":"function","title":"Bardo.Repo.update/2","doc":"","ref":"Bardo.Repo.html#update/2"},{"type":"function","title":"Bardo.Repo.update!/2","doc":"","ref":"Bardo.Repo.html#update!/2"},{"type":"function","title":"Bardo.Repo.update_all/3","doc":"","ref":"Bardo.Repo.html#update_all/3"},{"type":"module","title":"Bardo.ScapeManager.Scape","doc":"Scapes are self-contained simulated worlds or virtual environments.\n\nThey can be thought of as a way of interfacing with the problem in question. Scapes are composed\nof two parts: a simulation of an environment or a problem we are applying the neural network to,\nand a function that can keep track of the neural network's performance.\n\nScapes run outside the neural network systems, as independent processes with which the neural networks\ninteract using their sensors and actuators. There are two types of scapes:\n\n1. Private scapes are spawned for each neural network during creation, and destroyed when\n   that neural network is taken offline.\n2. Public scapes are persistent - they exist regardless of the neural networks, and allow \n   multiple neural networks to interact with them at the same time, enabling those networks\n   to interact with each other.\n   \nThis module defines the public scape.","ref":"Bardo.ScapeManager.Scape.html"},{"type":"function","title":"Bardo.ScapeManager.Scape.actuate/4","doc":"Perform various scape functions e.g. move, push, etc. The scape\nAPI is problem dependent. This function provides an interface\nto call various functions defined by the scape in question.","ref":"Bardo.ScapeManager.Scape.html#actuate/4"},{"type":"function","title":"Bardo.ScapeManager.Scape.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.ScapeManager.Scape.html#child_spec/1"},{"type":"function","title":"Bardo.ScapeManager.Scape.enter/2","doc":"Enter public scape.","ref":"Bardo.ScapeManager.Scape.html#enter/2"},{"type":"function","title":"Bardo.ScapeManager.Scape.insert/3","doc":"Insert point at X,Y into tree.","ref":"Bardo.ScapeManager.Scape.html#insert/3"},{"type":"function","title":"Bardo.ScapeManager.Scape.leave/2","doc":"Leave public scape.","ref":"Bardo.ScapeManager.Scape.html#leave/2"},{"type":"function","title":"Bardo.ScapeManager.Scape.move/3","doc":"Move the agent to a different point in the tree.","ref":"Bardo.ScapeManager.Scape.html#move/3"},{"type":"function","title":"Bardo.ScapeManager.Scape.query_area/4","doc":"Query a specific area within the scape.","ref":"Bardo.ScapeManager.Scape.html#query_area/4"},{"type":"function","title":"Bardo.ScapeManager.Scape.sense/3","doc":"Gather sensory inputs from the environment (Public Scape).","ref":"Bardo.ScapeManager.Scape.html#sense/3"},{"type":"function","title":"Bardo.ScapeManager.Scape.start_link/5","doc":"Starts the Scape process.","ref":"Bardo.ScapeManager.Scape.html#start_link/5"},{"type":"function","title":"Bardo.ScapeManager.Scape.whereis/1","doc":"Lookup agent in tree.","ref":"Bardo.ScapeManager.Scape.html#whereis/1"},{"type":"module","title":"Bardo.ScapeManager.ScapeManager","doc":"The ScapeManager is responsible for starting and stopping scapes.\n\nScapes represent environments where agents can interact and operate.","ref":"Bardo.ScapeManager.ScapeManager.html"},{"type":"function","title":"Bardo.ScapeManager.ScapeManager.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.ScapeManager.ScapeManager.html#child_spec/1"},{"type":"function","title":"Bardo.ScapeManager.ScapeManager.start_link/0","doc":"Starts the ScapeManager GenServer with the given parameters and options.","ref":"Bardo.ScapeManager.ScapeManager.html#start_link/0"},{"type":"function","title":"Bardo.ScapeManager.ScapeManager.start_link/1","doc":"","ref":"Bardo.ScapeManager.ScapeManager.html#start_link/1"},{"type":"function","title":"Bardo.ScapeManager.ScapeManager.start_scape/5","doc":"Starts a new scape with the given dimensions and module name.","ref":"Bardo.ScapeManager.ScapeManager.html#start_scape/5"},{"type":"function","title":"Bardo.ScapeManager.ScapeManager.stop_scape/1","doc":"Stops a scape with the given module name.","ref":"Bardo.ScapeManager.ScapeManager.html#stop_scape/1"},{"type":"module","title":"Bardo.ScapeManager.ScapeManagerClient","doc":"Client module for interacting with the ScapeManager and Scape processes.","ref":"Bardo.ScapeManager.ScapeManagerClient.html"},{"type":"function","title":"Bardo.ScapeManager.ScapeManagerClient.actuate/4","doc":"Agent actuates in the scape with the given function and parameters.","ref":"Bardo.ScapeManager.ScapeManagerClient.html#actuate/4"},{"type":"function","title":"Bardo.ScapeManager.ScapeManagerClient.enter/2","doc":"Agent enters the scape with the given parameters.","ref":"Bardo.ScapeManager.ScapeManagerClient.html#enter/2"},{"type":"function","title":"Bardo.ScapeManager.ScapeManagerClient.leave/2","doc":"Agent leaves the scape with the given parameters.","ref":"Bardo.ScapeManager.ScapeManagerClient.html#leave/2"},{"type":"function","title":"Bardo.ScapeManager.ScapeManagerClient.sense/3","doc":"Agent senses the scape through the given sensor.","ref":"Bardo.ScapeManager.ScapeManagerClient.html#sense/3"},{"type":"function","title":"Bardo.ScapeManager.ScapeManagerClient.start_scape/5","doc":"Starts a new scape with the given dimensions and module name.","ref":"Bardo.ScapeManager.ScapeManagerClient.html#start_scape/5"},{"type":"function","title":"Bardo.ScapeManager.ScapeManagerClient.stop_scape/1","doc":"Stops a scape with the given module name.","ref":"Bardo.ScapeManager.ScapeManagerClient.html#stop_scape/1"},{"type":"module","title":"Bardo.ScapeManager.ScapeSupervisor","doc":"Supervisor for Scape processes.\n\nThis supervisor manages individual Scape processes, which represent environments \nwhere agents can interact.","ref":"Bardo.ScapeManager.ScapeSupervisor.html"},{"type":"function","title":"Bardo.ScapeManager.ScapeSupervisor.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.ScapeManager.ScapeSupervisor.html#child_spec/1"},{"type":"function","title":"Bardo.ScapeManager.ScapeSupervisor.start_link/0","doc":"Starts the supervisor.","ref":"Bardo.ScapeManager.ScapeSupervisor.html#start_link/0"},{"type":"function","title":"Bardo.ScapeManager.ScapeSupervisor.start_scape/5","doc":"Starts a new scape process with the given parameters.","ref":"Bardo.ScapeManager.ScapeSupervisor.html#start_scape/5"},{"type":"function","title":"Bardo.ScapeManager.ScapeSupervisor.stop_scape/1","doc":"Stops a scape process with the given PID.","ref":"Bardo.ScapeManager.ScapeSupervisor.html#stop_scape/1"},{"type":"behaviour","title":"Bardo.ScapeManager.Sector","doc":"Sectors are the subcomponents/processes that make up a Scape.\n\nSee the Scape module for a description of what is a Scape.","ref":"Bardo.ScapeManager.Sector.html"},{"type":"callback","title":"Bardo.ScapeManager.Sector.actuate/4","doc":"","ref":"Bardo.ScapeManager.Sector.html#c:actuate/4"},{"type":"function","title":"Bardo.ScapeManager.Sector.actuate/5","doc":"Perform various sector functions e.g. move, push, etc. The sector\nAPI is problem dependent. This function provides an interface\nto call various functions defined by the sector in question.","ref":"Bardo.ScapeManager.Sector.html#actuate/5"},{"type":"function","title":"Bardo.ScapeManager.Sector.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.ScapeManager.Sector.html#child_spec/1"},{"type":"function","title":"Bardo.ScapeManager.Sector.delete/1","doc":"Delete entire table.","ref":"Bardo.ScapeManager.Sector.html#delete/1"},{"type":"function","title":"Bardo.ScapeManager.Sector.delete/2","doc":"Delete object.","ref":"Bardo.ScapeManager.Sector.html#delete/2"},{"type":"function","title":"Bardo.ScapeManager.Sector.enter/3","doc":"Enter sector.","ref":"Bardo.ScapeManager.Sector.html#enter/3"},{"type":"callback","title":"Bardo.ScapeManager.Sector.enter/3","doc":"","ref":"Bardo.ScapeManager.Sector.html#c:enter/3"},{"type":"function","title":"Bardo.ScapeManager.Sector.fetch/1","doc":"Return all objects.","ref":"Bardo.ScapeManager.Sector.html#fetch/1"},{"type":"function","title":"Bardo.ScapeManager.Sector.fetch/2","doc":"Lookup object.","ref":"Bardo.ScapeManager.Sector.html#fetch/2"},{"type":"callback","title":"Bardo.ScapeManager.Sector.init/1","doc":"","ref":"Bardo.ScapeManager.Sector.html#c:init/1"},{"type":"function","title":"Bardo.ScapeManager.Sector.insert/3","doc":"Insert Agent into sector.","ref":"Bardo.ScapeManager.Sector.html#insert/3"},{"type":"callback","title":"Bardo.ScapeManager.Sector.insert/3","doc":"","ref":"Bardo.ScapeManager.Sector.html#c:insert/3"},{"type":"function","title":"Bardo.ScapeManager.Sector.leave/3","doc":"Leave sector.","ref":"Bardo.ScapeManager.Sector.html#leave/3"},{"type":"callback","title":"Bardo.ScapeManager.Sector.leave/3","doc":"","ref":"Bardo.ScapeManager.Sector.html#c:leave/3"},{"type":"type","title":"Bardo.ScapeManager.Sector.mod_name/0","doc":"","ref":"Bardo.ScapeManager.Sector.html#t:mod_name/0"},{"type":"type","title":"Bardo.ScapeManager.Sector.mod_state/0","doc":"","ref":"Bardo.ScapeManager.Sector.html#t:mod_state/0"},{"type":"function","title":"Bardo.ScapeManager.Sector.remove/2","doc":"Remove Agent from sector.","ref":"Bardo.ScapeManager.Sector.html#remove/2"},{"type":"callback","title":"Bardo.ScapeManager.Sector.remove/2","doc":"","ref":"Bardo.ScapeManager.Sector.html#c:remove/2"},{"type":"type","title":"Bardo.ScapeManager.Sector.scape_id/0","doc":"","ref":"Bardo.ScapeManager.Sector.html#t:scape_id/0"},{"type":"function","title":"Bardo.ScapeManager.Sector.sense/4","doc":"Gather sensory inputs from the environment.","ref":"Bardo.ScapeManager.Sector.html#sense/4"},{"type":"callback","title":"Bardo.ScapeManager.Sector.sense/4","doc":"","ref":"Bardo.ScapeManager.Sector.html#c:sense/4"},{"type":"function","title":"Bardo.ScapeManager.Sector.start_link/2","doc":"Starts the Sector process.","ref":"Bardo.ScapeManager.Sector.html#start_link/2"},{"type":"function","title":"Bardo.ScapeManager.Sector.stop/1","doc":"Sends a signal to the Sector process requesting it to stop.","ref":"Bardo.ScapeManager.Sector.html#stop/1"},{"type":"function","title":"Bardo.ScapeManager.Sector.store/2","doc":"Insert object.","ref":"Bardo.ScapeManager.Sector.html#store/2"},{"type":"callback","title":"Bardo.ScapeManager.Sector.terminate/2","doc":"","ref":"Bardo.ScapeManager.Sector.html#c:terminate/2"},{"type":"function","title":"Bardo.ScapeManager.Sector.update_counter/4","doc":"Update counter.","ref":"Bardo.ScapeManager.Sector.html#update_counter/4"},{"type":"module","title":"Bardo.ScapeManager.SectorSupervisor","doc":"Supervisor for Sector processes.\n\nSectors are subdivisions of a Scape that help manage agent interactions\nin a distributed and efficient manner.","ref":"Bardo.ScapeManager.SectorSupervisor.html"},{"type":"function","title":"Bardo.ScapeManager.SectorSupervisor.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.ScapeManager.SectorSupervisor.html#child_spec/1"},{"type":"function","title":"Bardo.ScapeManager.SectorSupervisor.start_link/0","doc":"Starts the supervisor.","ref":"Bardo.ScapeManager.SectorSupervisor.html#start_link/0"},{"type":"function","title":"Bardo.ScapeManager.SectorSupervisor.start_sector/2","doc":"Starts a new sector process with the given module name and ID.","ref":"Bardo.ScapeManager.SectorSupervisor.html#start_sector/2"},{"type":"module","title":"Bardo.ScapeManager.Supervisor","doc":"Top-level supervisor for the ScapeManager subsystem.\n\nThis supervisor manages the ScapeManager, ScapeSupervisor, and SectorSupervisor.","ref":"Bardo.ScapeManager.Supervisor.html"},{"type":"function","title":"Bardo.ScapeManager.Supervisor.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.ScapeManager.Supervisor.html#child_spec/1"},{"type":"function","title":"Bardo.ScapeManager.Supervisor.start_link/0","doc":"Starts the supervisor.","ref":"Bardo.ScapeManager.Supervisor.html#start_link/0"},{"type":"function","title":"Bardo.ScapeManager.Supervisor.start_link/1","doc":"","ref":"Bardo.ScapeManager.Supervisor.html#start_link/1"},{"type":"module","title":"Bardo.Tarball","doc":"Functions for creating and extracting tarballs.\n\nThis module provides functionality for packing and unpacking tarball archives.","ref":"Bardo.Tarball.html"},{"type":"function","title":"Bardo.Tarball.create/2","doc":"Creates a tarball with the specified metadata and files.","ref":"Bardo.Tarball.html#create/2"},{"type":"function","title":"Bardo.Tarball.unpack/2","doc":"Unpacks a tarball and returns its contents.\n\nThe location parameter determines where to unpack the files.\nWhen :memory is specified, no files are created but the contents\nare returned in-memory.","ref":"Bardo.Tarball.html#unpack/2"},{"type":"task","title":"mix run_complex_examples","doc":"Mix task to run complex neuroevolution examples with improved user experience.\n\nThis task provides an interactive way to run and visualize the complex\nexamples included in Bardo, with progress tracking and better feedback.","ref":"Mix.Tasks.RunComplexExamples.html"},{"type":"task","title":"Usage - mix run_complex_examples","doc":"```bash\n# Run with default settings - interactive menu\n$ mix run_complex_examples\n\n# Run a specific example directly\n$ mix run_complex_examples --example flatland\n$ mix run_complex_examples --example fx\n\n# Customize parameters (all optional)\n$ mix run_complex_examples --example flatland --generations 10 --size 5\n```","ref":"Mix.Tasks.RunComplexExamples.html#module-usage"},{"type":"task","title":"Options - mix run_complex_examples","doc":"* `--example` - The example to run (flatland or fx)\n* `--generations` - Number of generations to evolve (default varies by example)\n* `--size` - Population size (default varies by example)\n* `--visualize` - Whether to run visualization after completion (default: true)","ref":"Mix.Tasks.RunComplexExamples.html#module-options"},{"type":"function","title":"Mix.Tasks.RunComplexExamples.run/1","doc":"Callback implementation for  Mix.Task.run/1 .","ref":"Mix.Tasks.RunComplexExamples.html#run/1"},{"type":"task","title":"mix run_examples","doc":"Runs Bardo examples and benchmarks with small parameters for testing.","ref":"Mix.Tasks.RunExamples.html"},{"type":"task","title":"Usage - mix run_examples","doc":"mix run_examples [--xor-only]\n\nOptions:\n  --xor-only: Run only the XOR example","ref":"Mix.Tasks.RunExamples.html#module-usage"},{"type":"task","title":"mix run_examples_refactored","doc":"Runs Bardo examples and benchmarks with an improved organization structure.","ref":"Mix.Tasks.RunExamplesRefactored.html"},{"type":"task","title":"Usage - mix run_examples_refactored","doc":"mix run_examples_refactored [options]\n\nOptions:\n  --category CATEGORY  Run examples from a specific category (simple, benchmarks, applications)\n  --example NAME       Run a specific example by name (xor, dpb, flatland, fx, algo_trading)\n  --quick              Run with smaller parameters for quick testing\n  --verbose            Show detailed output during execution","ref":"Mix.Tasks.RunExamplesRefactored.html#module-usage"},{"type":"task","title":"mix run_xor","doc":"Runs the Bardo XOR example with configurable parameters.","ref":"Mix.Tasks.RunXor.html"},{"type":"task","title":"Usage - mix run_xor","doc":"mix run_xor [--size SIZE] [--generations GEN] [--runs RUNS] [--quiet]\n\nOptions:\n  --size SIZE, -s:        Population size (default: 40)\n  --generations GEN, -g:  Maximum generations (default: 30)\n  --runs RUNS, -r:        Number of runs to perform (default: 1)\n  --quiet, -q:            Don't show progress during evolution","ref":"Mix.Tasks.RunXor.html#module-usage"},{"type":"module","title":"Bardo","doc":"Bardo is a powerful neuroevolution library for Elixir.\n\nIt enables the creation, training, and deployment of neural networks that evolve their\ntopology and parameters over time through evolutionary algorithms. The library is designed\nto be both powerful for experts and approachable for newcomers to neuroevolution.","ref":"Bardo.html"},{"type":"module","title":"Core Features - Bardo","doc":"* **Topology and Weight Evolving Artificial Neural Networks (TWEANNs)**: Neural networks\n  that evolve not just their weights but their entire structure.\n\n* **Distributed Evolution**: Leverages the Erlang VM for efficient parallel training and evaluation.\n\n* **Sensor-Actuator Framework**: Easy integration with custom environments through a\n  standardized interface for inputs and outputs.\n\n* **Multiple Encoding Strategies**: Supports direct, substrate-based, and other encoding schemes.\n\n* **Built-in Examples**: Includes classic benchmarks like pole balancing and complex simulations\n  like predator-prey ecosystems.","ref":"Bardo.html#module-core-features"},{"type":"module","title":"Architecture - Bardo","doc":"Bardo is organized into several key subsystems:\n\n* **ExperimentManager**: Controls the overall experimental process\n* **PopulationManager**: Handles populations of evolving agents\n* **AgentManager**: Manages neural networks and their interactions\n* **ScapeManager**: Provides environments for agents to operate in","ref":"Bardo.html#module-architecture"},{"type":"module","title":"Origins - Bardo","doc":"Bardo is based on the Topology and Parameter Evolving Universal Learning Network\n(DXNN) system originally created by Gene Sher in Erlang. It has been reimplemented\nand extended in Elixir with a focus on usability, performance, and modern design patterns.","ref":"Bardo.html#module-origins"},{"type":"module","title":"Usage - Bardo","doc":"For basic usage, see the `README.md` file. For more detailed examples and tutorials, \nexplore the `docs/` directory in the project repository.","ref":"Bardo.html#module-usage"},{"type":"function","title":"Bardo.hello/0","doc":"A simple function to say hello. Used in tests and examples.","ref":"Bardo.html#hello/0"},{"type":"function","title":"Examples - Bardo.hello/0","doc":"iex> Bardo.hello()\n    :world","ref":"Bardo.html#hello/0-examples"},{"type":"function","title":"Bardo.version/0","doc":"Returns the current library version.","ref":"Bardo.html#version/0"},{"type":"function","title":"Examples - Bardo.version/0","doc":"iex> Bardo.version()\n    \"0.1.0\"","ref":"Bardo.html#version/0-examples"},{"type":"module","title":"Bardo.AgentManager","doc":"Agent Manager module for the Bardo system.\n\nThis module is responsible for managing neural network agents, including their \ncreation, evaluation, and lifecycle management.","ref":"Bardo.AgentManager.html"},{"type":"function","title":"Bardo.AgentManager.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.AgentManager.html#child_spec/1"},{"type":"function","title":"Bardo.AgentManager.create_agent/1","doc":"Create a new agent with the specified parameters.","ref":"Bardo.AgentManager.html#create_agent/1"},{"type":"function","title":"Bardo.AgentManager.evaluate_agent/2","doc":"Evaluate an agent in the specified environment.","ref":"Bardo.AgentManager.html#evaluate_agent/2"},{"type":"function","title":"Bardo.AgentManager.start_link/1","doc":"Start the AgentManager process.","ref":"Bardo.AgentManager.html#start_link/1"},{"type":"module","title":"Bardo.AppConfig","doc":"Configuration management for the Bardo application.","ref":"Bardo.AppConfig.html"},{"type":"function","title":"Bardo.AppConfig.get_all/0","doc":"Get all environment variables from the default keyspace.","ref":"Bardo.AppConfig.html#get_all/0"},{"type":"function","title":"Bardo.AppConfig.get_all/1","doc":"Get all environment variables from a specific keyspace.","ref":"Bardo.AppConfig.html#get_all/1"},{"type":"function","title":"Bardo.AppConfig.get_env/1","doc":"Get environment variable from the default keyspace.","ref":"Bardo.AppConfig.html#get_env/1"},{"type":"function","title":"Bardo.AppConfig.get_env/2","doc":"Get environment variable from a specific keyspace.","ref":"Bardo.AppConfig.html#get_env/2"},{"type":"function","title":"Bardo.AppConfig.get_env/3","doc":"Get environment variable with default value.","ref":"Bardo.AppConfig.html#get_env/3"},{"type":"function","title":"Bardo.AppConfig.set_env/2","doc":"Set environment variable in the default keyspace.","ref":"Bardo.AppConfig.html#set_env/2"},{"type":"function","title":"Bardo.AppConfig.set_env/3","doc":"Set environment variable in a specific keyspace.","ref":"Bardo.AppConfig.html#set_env/3"},{"type":"module","title":"Bardo.Application","doc":"Bardo top level application.\n\nBardo is a distributed topology and weight evolving artificial neural network\noriginally created by Gene Sher. This is an Elixir port of the original Erlang DXNN system.","ref":"Bardo.Application.html"},{"type":"module","title":"Bardo.ExperimentManager","doc":"ExperimentManager for the Bardo system.\n\nHandles the creation and execution of neuroevolution experiments.","ref":"Bardo.ExperimentManager.html"},{"type":"function","title":"Bardo.ExperimentManager.run/0","doc":"Run a neuroevolution experiment with default parameters.","ref":"Bardo.ExperimentManager.html#run/0"},{"type":"function","title":"Bardo.ExperimentManager.run/1","doc":"Run a neuroevolution experiment with custom parameters.","ref":"Bardo.ExperimentManager.html#run/1"},{"type":"module","title":"Bardo.Models","doc":"Models for evolutionary computation data structures.\n\nThis module provides functions for creating and manipulating the \nvarious data structures used in the Bardo system. It includes\nmodel definitions for experiments, populations, species, and\nother components of the evolutionary computation framework.","ref":"Bardo.Models.html"},{"type":"function","title":"Bardo.Models.actuator/1","doc":"Create an actuator model.\n\nTakes a map with actuator configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#actuator/1"},{"type":"function","title":"Bardo.Models.agent/1","doc":"Create an agent model.\n\nTakes a map with agent configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#agent/1"},{"type":"function","title":"Bardo.Models.champion/1","doc":"Create a champion model.\n\nTakes a map with champion data and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#champion/1"},{"type":"function","title":"Bardo.Models.cortex/1","doc":"Create a cortex model.\n\nTakes a map with cortex configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#cortex/1"},{"type":"function","title":"Bardo.Models.delete/2","doc":"Delete a model from storage.","ref":"Bardo.Models.html#delete/2"},{"type":"function","title":"Parameters - Bardo.Models.delete/2","doc":"* `id` - The ID of the model to delete\n  * `type` - The type of the model (e.g. :experiment, :population, etc.)","ref":"Bardo.Models.html#delete/2-parameters"},{"type":"function","title":"Returns - Bardo.Models.delete/2","doc":"* `:ok` - If the model was deleted successfully\n  * `{:error, reason}` - If there was an error deleting the model","ref":"Bardo.Models.html#delete/2-returns"},{"type":"function","title":"Bardo.Models.exists?/2","doc":"Check if a model exists in storage.","ref":"Bardo.Models.html#exists?/2"},{"type":"function","title":"Parameters - Bardo.Models.exists?/2","doc":"* `id` - The ID of the model to check\n  * `type` - The type of the model (e.g. :experiment, :population, etc.)","ref":"Bardo.Models.html#exists?/2-parameters"},{"type":"function","title":"Returns - Bardo.Models.exists?/2","doc":"* `true` - If the model exists\n  * `false` - If the model does not exist","ref":"Bardo.Models.html#exists?/2-returns"},{"type":"function","title":"Bardo.Models.experiment/1","doc":"Create an experiment model.\n\nTakes a map with experiment configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#experiment/1"},{"type":"function","title":"Bardo.Models.fitness/1","doc":"Create a fitness model.\n\nTakes a map with fitness data and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#fitness/1"},{"type":"function","title":"Bardo.Models.genotype/1","doc":"Create a genotype model.\n\nTakes a map with genotype configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#genotype/1"},{"type":"function","title":"Bardo.Models.get/3","doc":"Get a value from a nested map using a path of keys.","ref":"Bardo.Models.html#get/3"},{"type":"function","title":"Parameters - Bardo.Models.get/3","doc":"* `map` - The map to get the value from\n  * `path` - A key or list of keys to traverse\n  * `default` - Optional default value if the path is not found","ref":"Bardo.Models.html#get/3-parameters"},{"type":"function","title":"Returns - Bardo.Models.get/3","doc":"* The value at the path, or the default value if not found","ref":"Bardo.Models.html#get/3-returns"},{"type":"function","title":"Examples - Bardo.Models.get/3","doc":"# Simple key access\n    iex> Models.get(%{a: 1}, :a)\n    1\n    \n    # Nested map access\n    iex> Models.get(%{a: %{b: 2}}, [:a, :b])\n    2\n    \n    # Access with default\n    iex> Models.get(%{a: 1}, :b, :not_found)\n    :not_found","ref":"Bardo.Models.html#get/3-examples"},{"type":"function","title":"Bardo.Models.list/1","doc":"List all models of a given type.","ref":"Bardo.Models.html#list/1"},{"type":"function","title":"Parameters - Bardo.Models.list/1","doc":"* `type` - The type of models to list","ref":"Bardo.Models.html#list/1-parameters"},{"type":"function","title":"Returns - Bardo.Models.list/1","doc":"* `[models]` - List of models, or empty list if none found","ref":"Bardo.Models.html#list/1-returns"},{"type":"function","title":"Bardo.Models.morphology/1","doc":"Create a morphology model.\n\nTakes a map with morphology configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#morphology/1"},{"type":"function","title":"Bardo.Models.neuron/1","doc":"Create a neuron model.\n\nTakes a map with neuron configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#neuron/1"},{"type":"function","title":"Bardo.Models.population/1","doc":"Create a population model.\n\nTakes a map with population configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#population/1"},{"type":"function","title":"Bardo.Models.population_status/1","doc":"Create a population status model.","ref":"Bardo.Models.html#population_status/1"},{"type":"function","title":"Bardo.Models.read/2","doc":"Read a model from storage by ID and type.","ref":"Bardo.Models.html#read/2"},{"type":"function","title":"Parameters - Bardo.Models.read/2","doc":"* `id` - The ID of the model to read\n  * `type` - The type of the model (e.g. :experiment, :population, etc.)","ref":"Bardo.Models.html#read/2-parameters"},{"type":"function","title":"Returns - Bardo.Models.read/2","doc":"* `{:ok, model}` - If the model was found\n  * `{:error, reason}` - If the model was not found or there was an error","ref":"Bardo.Models.html#read/2-returns"},{"type":"function","title":"Bardo.Models.result/1","doc":"Create a result model.\n\nTakes a map with result data and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#result/1"},{"type":"function","title":"Bardo.Models.scape/1","doc":"Create a scape model.\n\nTakes a map with scape configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#scape/1"},{"type":"function","title":"Bardo.Models.sensor/1","doc":"Create a sensor model.\n\nTakes a map with sensor configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#sensor/1"},{"type":"function","title":"Bardo.Models.set/2","doc":"Set a value or values in a model.","ref":"Bardo.Models.html#set/2"},{"type":"function","title":"Parameters - Bardo.Models.set/2","doc":"* `key_value` - A tuple {key, value} or a list of tuples to set\n  * `model` - The model to update","ref":"Bardo.Models.html#set/2-parameters"},{"type":"function","title":"Returns - Bardo.Models.set/2","doc":"* The updated model with the new values","ref":"Bardo.Models.html#set/2-returns"},{"type":"function","title":"Examples - Bardo.Models.set/2","doc":"# Set a single value\n    iex> set({:a, 2}, %{data: %{a: 1}})\n    %{data: %{a: 2}}\n\n    # Set multiple values\n    iex> set([{:a, 2}, {:b, 3}], %{data: %{a: 1}})\n    %{data: %{a: 2, b: 3}}","ref":"Bardo.Models.html#set/2-examples"},{"type":"function","title":"Bardo.Models.specie/1","doc":"Create a specie model.","ref":"Bardo.Models.html#specie/1"},{"type":"function","title":"Bardo.Models.stat/1","doc":"Create a stat model.\n\nTakes a map with statistics data and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#stat/1"},{"type":"function","title":"Bardo.Models.substrate/1","doc":"Create a substrate model.\n\nTakes a map with substrate configuration and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#substrate/1"},{"type":"function","title":"Bardo.Models.topology_summary/1","doc":"Create a topology summary model.\n\nTakes a map with topology data and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#topology_summary/1"},{"type":"function","title":"Bardo.Models.trace/1","doc":"Create a trace model.\n\nTakes a map with trace data and returns a model\nthat can be stored in the database.","ref":"Bardo.Models.html#trace/1"},{"type":"function","title":"Bardo.Models.write/3","doc":"Write a model to storage.","ref":"Bardo.Models.html#write/3"},{"type":"function","title":"Parameters - Bardo.Models.write/3","doc":"* `model` - The model to write\n  * `type` - The type of the model\n  * `id` - The ID of the model","ref":"Bardo.Models.html#write/3-parameters"},{"type":"function","title":"Returns - Bardo.Models.write/3","doc":"* `:ok` - If the model was written successfully\n  * `{:error, reason}` - If there was an error writing the model","ref":"Bardo.Models.html#write/3-returns"},{"type":"module","title":"Bardo.PolisMgr","doc":"Interface module for Polis Manager operations.\n\nThis module acts as a facade for the Polis.Manager implementation,\nproviding compatibility with the complex examples that expect a root-level\nPolisMgr module.","ref":"Bardo.PolisMgr.html"},{"type":"function","title":"Bardo.PolisMgr.evolve_generation/1","doc":"Evolves the next generation for a specific polis instance.","ref":"Bardo.PolisMgr.html#evolve_generation/1"},{"type":"function","title":"Parameters - Bardo.PolisMgr.evolve_generation/1","doc":"* `id` - ID of the polis instance","ref":"Bardo.PolisMgr.html#evolve_generation/1-parameters"},{"type":"function","title":"Returns - Bardo.PolisMgr.evolve_generation/1","doc":"* `{:ok, generation_info}` - Info about the evolved generation\n  * `{:error, reason}` - If there was an error evolving the generation","ref":"Bardo.PolisMgr.html#evolve_generation/1-returns"},{"type":"function","title":"Bardo.PolisMgr.prep/1","doc":"Prepares the system with the provided tarball.","ref":"Bardo.PolisMgr.html#prep/1"},{"type":"function","title":"Bardo.PolisMgr.send_command/2","doc":"Sends a command to a live polis instance.","ref":"Bardo.PolisMgr.html#send_command/2"},{"type":"function","title":"Parameters - Bardo.PolisMgr.send_command/2","doc":"* `id` - ID of the polis instance to send the command to\n  * `command` - The command to send","ref":"Bardo.PolisMgr.html#send_command/2-parameters"},{"type":"function","title":"Returns - Bardo.PolisMgr.send_command/2","doc":"* `{:ok, result}` - Result of the command\n  * `{:error, reason}` - If there was an error executing the command","ref":"Bardo.PolisMgr.html#send_command/2-returns"},{"type":"function","title":"Bardo.PolisMgr.setup/1","doc":"Sets up the neuroevolutionary platform with the given configuration.\n\nThis function configures the environment, sets up populations and scapes\naccording to the provided configuration.","ref":"Bardo.PolisMgr.html#setup/1"},{"type":"function","title":"Parameters - Bardo.PolisMgr.setup/1","doc":"* `config` - Map containing configuration for experiments, populations, and scapes","ref":"Bardo.PolisMgr.html#setup/1-parameters"},{"type":"function","title":"Returns - Bardo.PolisMgr.setup/1","doc":"* `{:ok, term}` - If the setup was successful\n  * `{:error, reason}` - If there was an error during setup","ref":"Bardo.PolisMgr.html#setup/1-returns"},{"type":"function","title":"Bardo.PolisMgr.start_experiment/1","doc":"Starts an experiment with the given ID.","ref":"Bardo.PolisMgr.html#start_experiment/1"},{"type":"function","title":"Parameters - Bardo.PolisMgr.start_experiment/1","doc":"* `experiment_id` - ID of the experiment to start","ref":"Bardo.PolisMgr.html#start_experiment/1-parameters"},{"type":"function","title":"Returns - Bardo.PolisMgr.start_experiment/1","doc":"* `:ok` - If the experiment was started successfully\n  * `{:error, reason}` - If there was an error starting the experiment","ref":"Bardo.PolisMgr.html#start_experiment/1-returns"},{"type":"function","title":"Bardo.PolisMgr.status/1","doc":"Gets the current status of the specified agent.","ref":"Bardo.PolisMgr.html#status/1"},{"type":"function","title":"Parameters - Bardo.PolisMgr.status/1","doc":"* `id` - ID of the agent to check","ref":"Bardo.PolisMgr.html#status/1-parameters"},{"type":"function","title":"Returns - Bardo.PolisMgr.status/1","doc":"* `{:ok, status}` - Status information about the agent\n  * `{:error, reason}` - If there was an error getting the status","ref":"Bardo.PolisMgr.html#status/1-returns"},{"type":"function","title":"Bardo.PolisMgr.stop/0","doc":"Stops the polis manager and cleans up resources.","ref":"Bardo.PolisMgr.html#stop/0"},{"type":"function","title":"Bardo.PolisMgr.stop/1","doc":"Stops a specific polis instance.","ref":"Bardo.PolisMgr.html#stop/1"},{"type":"function","title":"Parameters - Bardo.PolisMgr.stop/1","doc":"* `id` - ID of the polis instance to stop","ref":"Bardo.PolisMgr.html#stop/1-parameters"},{"type":"function","title":"Returns - Bardo.PolisMgr.stop/1","doc":"* `:ok` - If the polis was stopped successfully\n  * `{:error, reason}` - If there was an error stopping the polis","ref":"Bardo.PolisMgr.html#stop/1-returns"},{"type":"function","title":"Bardo.PolisMgr.update_population/2","doc":"Updates the population for a specific polis instance.","ref":"Bardo.PolisMgr.html#update_population/2"},{"type":"function","title":"Parameters - Bardo.PolisMgr.update_population/2","doc":"* `id` - ID of the polis instance\n  * `population` - New population data","ref":"Bardo.PolisMgr.html#update_population/2-parameters"},{"type":"function","title":"Returns - Bardo.PolisMgr.update_population/2","doc":"* `:ok` - If the population was updated successfully\n  * `{:error, reason}` - If there was an error updating the population","ref":"Bardo.PolisMgr.html#update_population/2-returns"},{"type":"behaviour","title":"Bardo.AgentManager.Actuator","doc":"Defines generic actuator behavior.\n\nAn actuator is a process that accepts signals from neurons in the output layer,\norders them into a vector, and then uses this vector to control some function\nthat acts on the environment or the NN itself. An actuator might have incoming\nconnections from multiple neurons, in which case it would wait until all neurons\nhave sent their output signals, accumulate these signals into a vector, and then\nuse this vector as a parameter to its actuation function.\n\nThe order in which the signals are accumulated into a vector is the same order\nas the neuron ids are stored. Once all signals have been gathered, the actuator\nexecutes its function, waits for its fitness score from the scape, sends the\ncortex the sync signal, and then again begins to wait for neural signals.","ref":"Bardo.AgentManager.Actuator.html"},{"type":"callback","title":"Bardo.AgentManager.Actuator.actuate/2","doc":"Callback to actuate based on received signals.","ref":"Bardo.AgentManager.Actuator.html#c:actuate/2"},{"type":"function","title":"Bardo.AgentManager.Actuator.fitness/2","doc":"The fitness score from the scape after the actuator has performed an action.","ref":"Bardo.AgentManager.Actuator.html#fitness/2"},{"type":"function","title":"Bardo.AgentManager.Actuator.forward/3","doc":"Send output from neural network to actuator.\nFor use in tests.","ref":"Bardo.AgentManager.Actuator.html#forward/3"},{"type":"function","title":"Bardo.AgentManager.Actuator.init/1","doc":"Initializes the actuator process.","ref":"Bardo.AgentManager.Actuator.html#init/1"},{"type":"callback","title":"Bardo.AgentManager.Actuator.init/1","doc":"Callback to initialize the actuator module state.","ref":"Bardo.AgentManager.Actuator.html#c:init/1"},{"type":"function","title":"Bardo.AgentManager.Actuator.init_phase2/11","doc":"Initializes the actuator setting it to its initial state.","ref":"Bardo.AgentManager.Actuator.html#init_phase2/11"},{"type":"function","title":"Bardo.AgentManager.Actuator.loop/1","doc":"Main loop to handle initialization message.","ref":"Bardo.AgentManager.Actuator.html#loop/1"},{"type":"function","title":"Bardo.AgentManager.Actuator.loop/6","doc":"Loop that handles actuator operations after initialization.","ref":"Bardo.AgentManager.Actuator.html#loop/6"},{"type":"function","title":"Bardo.AgentManager.Actuator.start/2","doc":"Spawns an Actuator process belonging to the exoself process that spawned it\nand calls init to initialize.","ref":"Bardo.AgentManager.Actuator.html#start/2"},{"type":"function","title":"Bardo.AgentManager.Actuator.stop/2","doc":"Terminates the actuator.","ref":"Bardo.AgentManager.Actuator.html#stop/2"},{"type":"function","title":"Bardo.AgentManager.Actuator.terminate/2","doc":"Terminates the actuator process with the given reason.","ref":"Bardo.AgentManager.Actuator.html#terminate/2"},{"type":"callback","title":"Bardo.AgentManager.Actuator.terminate/2","doc":"Optional callback for cleanup when terminating.","ref":"Bardo.AgentManager.Actuator.html#c:terminate/2"},{"type":"module","title":"Bardo.AgentManager.Cortex","doc":"The Cortex is the central coordination element of a neural network agent.","ref":"Bardo.AgentManager.Cortex.html"},{"type":"module","title":"Overview - Bardo.AgentManager.Cortex","doc":"The Cortex manages the synchronization and communication between all components of\na neural network agent:\n\n* **Sensors**: Receive information from the environment\n* **Neurons**: Process information through activation functions\n* **Actuators**: Act on the environment based on neural outputs\n\nIt orchestrates the sense-think-act cycle by:\n1. Triggering sensors to gather input from the environment\n2. Coordinating the forward propagation of signals through the neural network\n3. Ensuring actuators receive their control signals to interact with the environment\n4. Managing the timing and synchronization of the entire process","ref":"Bardo.AgentManager.Cortex.html#module-overview"},{"type":"module","title":"Key Responsibilities - Bardo.AgentManager.Cortex","doc":"* **Network Coordination**: Ensures all neurons, sensors, and actuators operate in coordination\n* **Cycle Management**: Controls the timing of sensing, processing, and acting phases\n* **Message Routing**: Directs signals between appropriate network components\n* **State Management**: Maintains the state of the neural network across operational cycles","ref":"Bardo.AgentManager.Cortex.html#module-key-responsibilities"},{"type":"module","title":"Implementation Details - Bardo.AgentManager.Cortex","doc":"Each Cortex is implemented as an Erlang process that communicates with other processes\n(sensors, neurons, actuators) through message passing. This leverages the BEAM VM's\nconcurrency model for efficient parallel processing across the neural network.","ref":"Bardo.AgentManager.Cortex.html#module-implementation-details"},{"type":"function","title":"Bardo.AgentManager.Cortex.activate/2","doc":"Activates a neural network with the given inputs.\n\nThis is a simplified implementation for basic examples and testing.","ref":"Bardo.AgentManager.Cortex.html#activate/2"},{"type":"function","title":"Bardo.AgentManager.Cortex.from_genotype/1","doc":"Creates a neural network (cortex) from a genotype.\n\nThis is a simplified implementation for basic examples and testing.\nIt creates an in-memory neural network without spawning processes.","ref":"Bardo.AgentManager.Cortex.html#from_genotype/1"},{"type":"function","title":"Bardo.AgentManager.Cortex.init/1","doc":"Initialize the cortex process.","ref":"Bardo.AgentManager.Cortex.html#init/1"},{"type":"function","title":"Bardo.AgentManager.Cortex.init_phase2/7","doc":"Initializes the cortex.","ref":"Bardo.AgentManager.Cortex.html#init_phase2/7"},{"type":"function","title":"Bardo.AgentManager.Cortex.reactivate/2","doc":"Reactivate the Cortex after it's gone inactive.","ref":"Bardo.AgentManager.Cortex.html#reactivate/2"},{"type":"function","title":"Bardo.AgentManager.Cortex.start/2","doc":"Spawns a Cortex process belonging to the Exoself process that spawned it\nand calls init to initialize.","ref":"Bardo.AgentManager.Cortex.html#start/2"},{"type":"function","title":"Bardo.AgentManager.Cortex.stop/2","doc":"Terminates the cortex.","ref":"Bardo.AgentManager.Cortex.html#stop/2"},{"type":"function","title":"Bardo.AgentManager.Cortex.sync/4","doc":"Sync the Cortex with an actuator, providing fitness and status.\nUsed in the cycle coordination process.","ref":"Bardo.AgentManager.Cortex.html#sync/4"},{"type":"module","title":"Bardo.AgentManager.Neuron","doc":"The neuron is a signal processing element.\n\nIt accepts signals, accumulates them into an ordered vector, then processes this input\nvector to produce an output, and finally passes the output to other elements it is \nconnected to. The neuron never interacts with the environment directly, and even when \nit does receive signals and produces output signals, it does not know whether these \ninput signals are coming from sensors or neurons, or whether it is sending its output \nsignals to other neurons or actuators. \n\nAll the neuron does is have a list of input PIDs from which it expects to receive\nsignals, a list of output PIDs to which the neuron sends its output, a weight list \ncorrelated with the input PIDs, and an activation function it applies to the dot \nproduct of the input vector and its weight vector. The neuron waits until it receives \nall the input signals, and then passes the output onwards.\n\nNOTE: The neuron is the basic processing element, the basic processing node in the \nneural network system. The neurons in this system are more general than those used \nby others. They can easily use various activation functions, and accept and output \nvectors. Because we can use anything for the activation function, including logical \noperators, the neurons are really just processing nodes. In some sense, this system \nis not a Topology and Weight Evolving Artificial Neural Network, but a Topology and \nParameter Evolving Universal Learning Network (TPEULN). Nevertheless, we will continue\nreferring to these processing elements as neurons.","ref":"Bardo.AgentManager.Neuron.html"},{"type":"function","title":"Bardo.AgentManager.Neuron.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.AgentManager.Neuron.html#child_spec/1"},{"type":"function","title":"Bardo.AgentManager.Neuron.forward/3","doc":"The Neuron process waits for vector signals from all the processes\nthat it's connected from, taking the dot product of the input and\nweight vectors, and then adding it to the accumulator. Once all the\nsignals from InputPids are received, the accumulator contains the\ndot product to which the neuron then adds the bias and executes the\nactivation function. After fanning out the output signal, the neuron\nagain returns to waiting for incoming signals.","ref":"Bardo.AgentManager.Neuron.html#forward/3"},{"type":"function","title":"Bardo.AgentManager.Neuron.get_backup/2","doc":"Get backup: neuron sends back to the exoself its last best synaptic\nweight combination, stored as the MInputPids list.","ref":"Bardo.AgentManager.Neuron.html#get_backup/2"},{"type":"function","title":"Bardo.AgentManager.Neuron.init/1","doc":"Initialize the neuron process.","ref":"Bardo.AgentManager.Neuron.html#init/1"},{"type":"function","title":"Bardo.AgentManager.Neuron.init_phase2/12","doc":"Initializes the neuron setting it to its initial state.","ref":"Bardo.AgentManager.Neuron.html#init_phase2/12"},{"type":"function","title":"Bardo.AgentManager.Neuron.loop/1","doc":"Main process loop during initialization.","ref":"Bardo.AgentManager.Neuron.html#loop/1"},{"type":"function","title":"Bardo.AgentManager.Neuron.loop/6","doc":"Main process loop after initialization.","ref":"Bardo.AgentManager.Neuron.html#loop/6"},{"type":"function","title":"Bardo.AgentManager.Neuron.perturb_pf/2","doc":"Perturb plasticity function: perturbs the plasticity function.","ref":"Bardo.AgentManager.Neuron.html#perturb_pf/2"},{"type":"function","title":"Bardo.AgentManager.Neuron.perturb_weights_p/4","doc":"The perturb_weights_p function is the function that actually goes\nthrough each weight block, and perturbs each weight with a\nprobability of MP. If the weight is chosen to be perturbed, the\nperturbation intensity is chosen uniformly between -Spread and\nSpread.","ref":"Bardo.AgentManager.Neuron.html#perturb_weights_p/4"},{"type":"function","title":"Bardo.AgentManager.Neuron.reset_prep/2","doc":"Reset prep: This message is sent after a single evaluation is completed,\nand the exoself wishes to reset all the neurons to their original states,\nwith empty inboxes. Once a neuron receives this message, it goes into a\nreset_prep state, flushes its buffer/inbox, and then awaits for the\n{ExoselfPid, reset} signal. When the neuron receives the {ExoselfPid, reset}\nmessage, it again sends out the default output message to all its recurrent\nconnections (Ids stored in the ro_ids list), and then finally drops back\ninto its main receive loop.","ref":"Bardo.AgentManager.Neuron.html#reset_prep/2"},{"type":"function","title":"Bardo.AgentManager.Neuron.sat/3","doc":"","ref":"Bardo.AgentManager.Neuron.html#sat/3"},{"type":"function","title":"Bardo.AgentManager.Neuron.start/2","doc":"Spawns a Neuron process belonging to the Exoself process that spawned it\nand calls init to initialize.","ref":"Bardo.AgentManager.Neuron.html#start/2"},{"type":"function","title":"Bardo.AgentManager.Neuron.stop/2","doc":"Terminates neuron.","ref":"Bardo.AgentManager.Neuron.html#stop/2"},{"type":"function","title":"Bardo.AgentManager.Neuron.terminate/1","doc":"Terminate the neuron process.","ref":"Bardo.AgentManager.Neuron.html#terminate/1"},{"type":"function","title":"Bardo.AgentManager.Neuron.weight_backup/2","doc":"Weight backup: The signal from the exoself, which tells the neuron\nthat the NN system performs best when this particular neuron is using\nits current synaptic weight combination, and thus it should save this\nsynaptic weight list as MInputPidPs, and that it is the best weight\ncombination achieved thus far. The message is sent if after the weight\nperturbation, the NN's evaluation achieves a higher fitness than when\nthe neurons of this NN used their previous synaptic weights.","ref":"Bardo.AgentManager.Neuron.html#weight_backup/2"},{"type":"function","title":"Bardo.AgentManager.Neuron.weight_perturb/3","doc":"Weight perturb: Uses the Spread value for the purpose of generating\nsynaptic weight perturbations.","ref":"Bardo.AgentManager.Neuron.html#weight_perturb/3"},{"type":"function","title":"Bardo.AgentManager.Neuron.weight_restore/2","doc":"Weight restore: This message is sent from the exoself, and it tells\nthe neuron that it should restore its synaptic weight list to the one\npreviously used, saved as MInputPidPs. This message is usually sent if\nafter the weight perturbation, the NN based agent's evaluation performs\nworse than it did with its previous synaptic weight combinations.","ref":"Bardo.AgentManager.Neuron.html#weight_restore/2"},{"type":"behaviour","title":"Bardo.AgentManager.Sensor","doc":"Defines generic sensor behavior.\n\nA sensor is a process that takes input from the environment, converts it into\na signal, and then forwards this signal to the cortex neurons to which it is connected.","ref":"Bardo.AgentManager.Sensor.html"},{"type":"function","title":"Bardo.AgentManager.Sensor.init/1","doc":"Initializes the sensor process.","ref":"Bardo.AgentManager.Sensor.html#init/1"},{"type":"callback","title":"Bardo.AgentManager.Sensor.init/1","doc":"Callback to initialize the sensor module state.","ref":"Bardo.AgentManager.Sensor.html#c:init/1"},{"type":"function","title":"Bardo.AgentManager.Sensor.init_phase2/11","doc":"Initializes the sensor setting it to its initial state.","ref":"Bardo.AgentManager.Sensor.html#init_phase2/11"},{"type":"function","title":"Bardo.AgentManager.Sensor.percept/2","doc":"Sends a perception from the environment to the sensor.\n\nFor use in tests and simulations.","ref":"Bardo.AgentManager.Sensor.html#percept/2"},{"type":"callback","title":"Bardo.AgentManager.Sensor.percept/2","doc":"Callback to process percept data and generate output signals.","ref":"Bardo.AgentManager.Sensor.html#c:percept/2"},{"type":"callback","title":"Bardo.AgentManager.Sensor.sense/2","doc":"Callback to sense input from the environment.","ref":"Bardo.AgentManager.Sensor.html#c:sense/2"},{"type":"function","title":"Bardo.AgentManager.Sensor.start/2","doc":"Spawns a Sensor process belonging to the exoself process that spawned it\nand calls init to initialize.","ref":"Bardo.AgentManager.Sensor.html#start/2"},{"type":"function","title":"Bardo.AgentManager.Sensor.stop/2","doc":"Terminates the sensor.","ref":"Bardo.AgentManager.Sensor.html#stop/2"},{"type":"function","title":"Bardo.AgentManager.Sensor.sync/2","doc":"Syncs the sensor with the cortex.","ref":"Bardo.AgentManager.Sensor.html#sync/2"},{"type":"callback","title":"Bardo.AgentManager.Sensor.terminate/2","doc":"Optional callback for cleanup when terminating.","ref":"Bardo.AgentManager.Sensor.html#c:terminate/2"},{"type":"module","title":"Bardo.AgentManager.Substrate","doc":"Substrate is the module responsible for managing the connectivity between neurodes\nin a neural network. It enables patterns of connectivity to be established based on\ngeometric coordinates of neurodes, allowing complex neural architectures to be developed.","ref":"Bardo.AgentManager.Substrate.html"},{"type":"function","title":"Bardo.AgentManager.Substrate.set_abcn/3","doc":"Sets the activation bias, and connectivity expression between neurodes.","ref":"Bardo.AgentManager.Substrate.html#set_abcn/3"},{"type":"function","title":"Bardo.AgentManager.Substrate.set_iterative/3","doc":"Sets weight updates iteratively.","ref":"Bardo.AgentManager.Substrate.html#set_iterative/3"},{"type":"function","title":"Bardo.AgentManager.Substrate.set_weight/3","doc":"Sets the synaptic weight between two neurodes.","ref":"Bardo.AgentManager.Substrate.html#set_weight/3"},{"type":"module","title":"Bardo.PopulationManager.GenomeMutator","doc":"The genome_mutator is responsible for mutating genotypes. It uses\nvarious mutation operators to modify a genotype, and return a mutant\nof the genotype. Specifically, the mutation operators\ninclude both topological and parametric mutations. The topological\nmutations mutate the structure of a genotype by adding, or\nremoving, neurons, connections, sensors, and actuators.\nThe parametric mutations mutate the parameters of the genotype, such as\nthe weights and the plasticity parameters. In a multi-objective\noptimization, bias mutation is performed on the bias parameters of\nthe neural network, thus changing the biasing of the NN from one\nobjective to another, while preserving overall proficiency.\n\nTechnically, we do not need every one of these mutation operators; the\nfollowing list will be enough for a highly versatile complexifying\ntopology and weight evolving artificial neural network (TWEANN) system:\nmutate_weights, add_bias, remove_bias, mutate_af, add_neuron, splice\n(just one of them), add_inlink, add_outlink, add_sensorlink,\nadd_actuatorlink, add_sensor, and add_actuator. Note that this\ncombination of MOs can convert any NN topology A into a NN topology B,\ngiven that A is contained (smaller, and simpler in a sense) within B.","ref":"Bardo.PopulationManager.GenomeMutator.html"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.add_bias/1","doc":"The add_bias function is called with the AgentId parameter. The\nfunction first extracts the neuron_ids list from the cortex element\nand chooses a random neuron from the id list. After the neuron is\nread from the database, we check whether input_idps and\ninput_idps_modulation lists already have bias, and we randomly\ngenerate a value 1 or 2. If the value 1 is generated and the\ninput_idps list does not have a bias, it is added. If the value 2 is\ngenerated, and the input_idps_modulation does not have a bias, it is\nadded. Otherwise an error is returned.","ref":"Bardo.PopulationManager.GenomeMutator.html#add_bias/1"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.link_from_element_to_element/3","doc":"The link_from_element_to_element first calculates what type\nof link is going to be established (neuron to neuron, sensor to neuron,\nor neuron to actuator), and then calls the specific linking function\nbased on that.","ref":"Bardo.PopulationManager.GenomeMutator.html#link_from_element_to_element/3"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.link_from_neuron_to_neuron/3","doc":"The link_from_neuron_to_neuron establishes a link from neuron with\nid FromNeuronId, to a neuron with id ToNeuronId. The function then\ncalls link_from_neuron, which establishes the link on the\nFromNeuronId's side. The updated neuron associated with the\nFromNeuronId is then written to database.","ref":"Bardo.PopulationManager.GenomeMutator.html#link_from_neuron_to_neuron/3"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.link_from_sensor_to_neuron/3","doc":"The function link_from_sensor_to_neuron establishes a connection from\nthe sensor with id FromSensorId, and the neuron with id ToNeuronId.","ref":"Bardo.PopulationManager.GenomeMutator.html#link_from_sensor_to_neuron/3"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.mutate/1","doc":"The function mutate first updates the generation of the agent to be\nmutated, then calculates the number of mutation operators to be\napplied to it by executing the tot_topological_mutations:TTMName/2\nfunction, and then finally runs the apply_mutators/2 function, which\nmutates the agent. Once the agent is mutated, the function updates\nits fingerprint by executing genotype:update_finrgerprint/1.","ref":"Bardo.PopulationManager.GenomeMutator.html#mutate/1"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.mutate_af/1","doc":"The mutate_af function chooses a random neuron, and then changes its\ncurrently used activation function into another one available from the\nneural_afs list of the agent's constraint record.","ref":"Bardo.PopulationManager.GenomeMutator.html#mutate_af/1"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.mutate_heredity_type/1","doc":"The mutate_heredity_type function checks if there are any other\nheredity types in the agent's constraint record. If any other than\nthe one currently used by the agent are present, the agent exchanges\nthe heredity type it currently uses to a random one from the remaining\nlist. If no other heredity types are available, the mutation operator\nexits with an error, and the neuroevolutionary system tries another\nmutation operator.","ref":"Bardo.PopulationManager.GenomeMutator.html#mutate_heredity_type/1"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.mutate_tot_topological_mutations/1","doc":"The mutate_tot_topological_mutations function checks if there are\nany other than the currently used tuning tot topological mutation\nfunctions available in the agent's constraint. If there is, then it\nchooses a random one from this list, and sets the agent's\ntot_topological_mutations_f to it. If there are no other functions\nthat can calculate tot topological mutations, then it exits with an\nerror.","ref":"Bardo.PopulationManager.GenomeMutator.html#mutate_tot_topological_mutations/1"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.mutate_tuning_annealing/1","doc":"The mutate_annealing_parameter function checks if there are any\nother than the currently used tuning annealing parameters available\nin the agent's constraint. If there is, then it chooses a random one\nfrom this list, and sets the agent's annealing_parameter to it. If\nthere are no other tuning annealing parameters, then it exits with\nan error.","ref":"Bardo.PopulationManager.GenomeMutator.html#mutate_tuning_annealing/1"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.mutate_tuning_selection/1","doc":"The mutate_tuning_selection function checks if there are any other\nthan the currently used tuning selection functions available in the\nagent's constraint. If there is, then it chooses a random one from\nthis list, and sets the agent's tuning_selection_f to it. If there\nare no other tuning selection functions, then it exits with an error.","ref":"Bardo.PopulationManager.GenomeMutator.html#mutate_tuning_selection/1"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.mutate_weights/1","doc":"The mutate_weights function accepts the AgentId parameter, extracts\nthe NN's cortex, and then chooses a random neuron belonging to the NN\nwith a uniform distribution probability. Then the neuron's input_idps\nlist is extracted, and the function perturb_idps/1 is used to\nperturb/mutate the weights. Once the InputIdPs have been perturbed,\nthe agent's evolutionary history, EvoHist is updated to include the\nsuccessfully applied mutate_weights mutation operator. Then the\nupdated Agent and the updated neuron are written to the database.","ref":"Bardo.PopulationManager.GenomeMutator.html#mutate_weights/1"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.remove_bias/1","doc":"The remove_bias function is called with the AgentId parameter. The\nfunction first extracts the neuron_ids list from the cortex element\nand chooses a random neuron from the id list. After the neuron is\nread from the database, we check whether input_idps and\ninput_idps_modulation lists already have bias, and we randomly\ngenerate a value 1 or 2. If the value 1 is generated and the\ninput_idps list has a bias, it is removed. If the value 2 is\ngenerated, and the input_idps_modulation has a bias, it is removed.\nOtherwise an error is returned.","ref":"Bardo.PopulationManager.GenomeMutator.html#remove_bias/1"},{"type":"function","title":"Bardo.PopulationManager.GenomeMutator.simple_mutate/2","doc":"Applies mutation operators to a genotype based on probabilities.","ref":"Bardo.PopulationManager.GenomeMutator.html#simple_mutate/2"},{"type":"function","title":"Parameters - Bardo.PopulationManager.GenomeMutator.simple_mutate/2","doc":"- `genotype` - The genotype to mutate\n- `opts` - Options controlling mutation probabilities","ref":"Bardo.PopulationManager.GenomeMutator.html#simple_mutate/2-parameters"},{"type":"function","title":"Options - Bardo.PopulationManager.GenomeMutator.simple_mutate/2","doc":"- `:add_neuron_probability` - Probability of adding a neuron (default: 0.1)\n- `:add_link_probability` - Probability of adding a connection (default: 0.2)\n- `:mutate_weights_probability` - Probability of mutating weights (default: 0.8)","ref":"Bardo.PopulationManager.GenomeMutator.html#simple_mutate/2-options"},{"type":"function","title":"Examples - Bardo.PopulationManager.GenomeMutator.simple_mutate/2","doc":"iex> genotype = Bardo.PopulationManager.Genotype.new()\n    iex> mutated = Bardo.PopulationManager.GenomeMutator.simple_mutate(genotype)","ref":"Bardo.PopulationManager.GenomeMutator.html#simple_mutate/2-examples"},{"type":"module","title":"Bardo.PopulationManager.Genotype","doc":"The Genotype module encapsulates the genetic representation of neural networks.","ref":"Bardo.PopulationManager.Genotype.html"},{"type":"module","title":"Overview - Bardo.PopulationManager.Genotype","doc":"In neuroevolution, a genotype serves as the genetic blueprint from which a neural network\n(phenotype) is constructed. The Genotype module provides functions for creating, manipulating,\nand evolving these blueprints.","ref":"Bardo.PopulationManager.Genotype.html#module-overview"},{"type":"module","title":"Key Concepts - Bardo.PopulationManager.Genotype","doc":"","ref":"Bardo.PopulationManager.Genotype.html#module-key-concepts"},{"type":"module","title":"Topology and Weight Evolving Artificial Neural Networks (TWEANNs) - Bardo.PopulationManager.Genotype","doc":"Unlike traditional neural networks with fixed architectures, TWEANNs can evolve their\nentire structure during the evolutionary process:\n\n* New neurons can be added\n* New connections can be formed\n* Existing connections can be modified or removed\n* Neural parameters (weights, biases, activation functions) can change\n\nThis allows the evolutionary process to discover optimal network structures\nwithout the need for manual architecture design or hyperparameter tuning.","ref":"Bardo.PopulationManager.Genotype.html#module-topology-and-weight-evolving-artificial-neural-networks-tweanns"},{"type":"module","title":"Incremental Complexity - Bardo.PopulationManager.Genotype","doc":"The evolutionary process typically begins with minimal seed genotypes and gradually\nincreases complexity as needed to solve the problem:\n\n1. Start with the simplest possible network (often just input-output connections)\n2. Allow mutation operators to add complexity as evolution progresses\n3. Let natural selection favor the most efficient solutions","ref":"Bardo.PopulationManager.Genotype.html#module-incremental-complexity"},{"type":"module","title":"Activation Function Diversity - Bardo.PopulationManager.Genotype","doc":"Bardo supports a variety of activation functions beyond the standard sigmoid/tanh:\n\n* Sine, absolute value, sign function\n* Gaussian, step functions\n* Linear and rectified linear\n* Custom user-defined functions\n\nDifferent activation functions can be used in different parts of the network or\nconstrained to specific subpopulations to explore diverse solution spaces.","ref":"Bardo.PopulationManager.Genotype.html#module-activation-function-diversity"},{"type":"module","title":"Constraints - Bardo.PopulationManager.Genotype","doc":"Evolutionary constraints can be applied to guide the evolutionary process:\n\n* Morphology constraints: Define the available sensors and actuators\n* Activation function constraints: Limit which functions can be used\n* Topological constraints: Restrict certain kinds of connections","ref":"Bardo.PopulationManager.Genotype.html#module-constraints"},{"type":"module","title":"Implementation - Bardo.PopulationManager.Genotype","doc":"The genotype representation uses a structured encoding that tracks:\n\n* Neuron properties (layer, type, activation function, etc.)\n* Connection topology (which neurons connect to which)\n* Connection weights and other parameters\n* Historical markers to aid in crossover operations","ref":"Bardo.PopulationManager.Genotype.html#module-implementation"},{"type":"function","title":"Bardo.PopulationManager.Genotype.add_connection/4","doc":"Adds a connection between two neurons.","ref":"Bardo.PopulationManager.Genotype.html#add_connection/4"},{"type":"function","title":"Parameters - Bardo.PopulationManager.Genotype.add_connection/4","doc":"- `genotype` - The genotype to add the connection to\n- `from_id` - The ID of the source neuron\n- `to_id` - The ID of the target neuron\n- `weight` - The weight of the connection","ref":"Bardo.PopulationManager.Genotype.html#add_connection/4-parameters"},{"type":"function","title":"Examples - Bardo.PopulationManager.Genotype.add_connection/4","doc":"iex> genotype = Bardo.PopulationManager.Genotype.new()\n    iex> genotype = Bardo.PopulationManager.Genotype.add_neuron(genotype, :input, %{id: \"input\"})\n    iex> genotype = Bardo.PopulationManager.Genotype.add_neuron(genotype, :output, %{id: \"output\"})\n    iex> genotype = Bardo.PopulationManager.Genotype.add_connection(genotype, \"input\", \"output\", 0.5)","ref":"Bardo.PopulationManager.Genotype.html#add_connection/4-examples"},{"type":"function","title":"Bardo.PopulationManager.Genotype.add_neuron/3","doc":"Adds a neuron to the genotype.","ref":"Bardo.PopulationManager.Genotype.html#add_neuron/3"},{"type":"function","title":"Parameters - Bardo.PopulationManager.Genotype.add_neuron/3","doc":"- `genotype` - The genotype to add the neuron to\n- `layer` - The layer of the neuron (:input, :hidden, :output, or :bias)\n- `params` - Optional parameters for the neuron","ref":"Bardo.PopulationManager.Genotype.html#add_neuron/3-parameters"},{"type":"function","title":"Examples - Bardo.PopulationManager.Genotype.add_neuron/3","doc":"iex> genotype = Bardo.PopulationManager.Genotype.new()\n    iex> genotype = Bardo.PopulationManager.Genotype.add_neuron(genotype, :input)\n    %{neurons: %{\"neuron_1\" => %{layer: :input, activation_function: :sigmoid}}, ...}","ref":"Bardo.PopulationManager.Genotype.html#add_neuron/3-examples"},{"type":"function","title":"Bardo.PopulationManager.Genotype.clone_agent/1","doc":"The clone_agent accepts AgentId and generates a CloneAgentId. It then\ncalls clone_agent which accepts AgentId, and CloneAgentId, and then\nclones the agent, giving the clone CloneAgentId. The function first\ncreates an ETS table to which it writes the ids of all the elements\nof the genotype, and their corresponding clone ids. Once all ids and\nclone ids have been generated, the function then begins to clone the\nactual elements.","ref":"Bardo.PopulationManager.Genotype.html#clone_agent/1"},{"type":"function","title":"Bardo.PopulationManager.Genotype.construct_agent/3","doc":"The population mgr should have all the information with regards\nto the morphologies and specie constraint under which the agent's\ngenotype should be created. Thus construct_agent/3 is run with\nthe SpecieId to which this NN based system will belong, the AgentId\nthat this NN based intelligent agent will have, and the SpecCon\n(specie constraint) that will define the list of activation functions\nand other parameters from which the seed agent can choose its\nparameters. First the generation is set to 0, since the agent is just\ncreated, then the construct_cortex/3 is ran, which creates the NN and\nreturns its CxId. Once the NN is created and the the cortex's id is\nreturned, we can fill out the information needed by the agent record,\nand write it to the database.","ref":"Bardo.PopulationManager.Genotype.html#construct_agent/3"},{"type":"function","title":"Bardo.PopulationManager.Genotype.construct_neuron/6","doc":"Each neuron record is composed by the construct_neuron function. The\nconstruct_neuron creates the Input list from the tuples\n[{Id, Weights}...] using the vector lengths specified in the InputSpecs\nlist. The create_input_idps function uses create_neural_weights_p to\ngenerate a tuple list with random weights in the range of -0.5 to 0.5,\nand plasticity parameters dependent on the PF function. The activation\nfunction that the neuron uses is chosen randomly from the neural_afs\nlist within the constraint record passed to the construct_neuron\nfunction. construct_neuron uses calculate_roids to extract the list of\nrecursive connection ids from the OutputIds passed to it. Once the\nneuron record is filled in, it is saved to the database.","ref":"Bardo.PopulationManager.Genotype.html#construct_neuron/6"},{"type":"function","title":"Bardo.PopulationManager.Genotype.create_neural_weights_p/3","doc":"Each neuron record is composed by the construct_neuron function.\nThe construct_neuron creates the Input list from the tuples\n[{Id, Weights}...] using the vector lengths specified in the\nInputSpecs list. The create_input_idps function uses\ncreate_neural_weights_p to generate a tuple list with random weights\nin the range of -0.5 to 0.5, and plasticity parameters dependent on\nthe PF function. The activation function that the neuron uses is\nchosen randomly from the neural_afs list within the constraint record\npassed to the construct_neuron function. construct_neuron uses\ncalculate_roids to extract the list of recursive connection ids\nfrom the OutputIds passed to it. Once the neuron record is filled\nin, it is saved to the database.","ref":"Bardo.PopulationManager.Genotype.html#create_neural_weights_p/3"},{"type":"function","title":"Bardo.PopulationManager.Genotype.delete_agent/1","doc":"The delete_agent accepts the id of an agent, and then deletes that\nagent's genotype. This function assumes that the id of the agent will\nbe removed from the specie's agent_ids list, and any other clean up\nprocedures, by the calling function.","ref":"Bardo.PopulationManager.Genotype.html#delete_agent/1"},{"type":"function","title":"Bardo.PopulationManager.Genotype.get_layer_neuron_ids/2","doc":"Gets the IDs of neurons in a specific layer.","ref":"Bardo.PopulationManager.Genotype.html#get_layer_neuron_ids/2"},{"type":"function","title":"Parameters - Bardo.PopulationManager.Genotype.get_layer_neuron_ids/2","doc":"- `genotype` - The genotype to get neurons from\n- `layer` - The layer to get neurons from","ref":"Bardo.PopulationManager.Genotype.html#get_layer_neuron_ids/2-parameters"},{"type":"function","title":"Examples - Bardo.PopulationManager.Genotype.get_layer_neuron_ids/2","doc":"iex> genotype = Bardo.PopulationManager.Genotype.new()\n    iex> genotype = Bardo.PopulationManager.Genotype.add_neuron(genotype, :input, %{id: \"input1\"})\n    iex> genotype = Bardo.PopulationManager.Genotype.add_neuron(genotype, :input, %{id: \"input2\"})\n    iex> Bardo.PopulationManager.Genotype.get_layer_neuron_ids(genotype, :input)\n    [\"input1\", \"input2\"]","ref":"Bardo.PopulationManager.Genotype.html#get_layer_neuron_ids/2-examples"},{"type":"function","title":"Bardo.PopulationManager.Genotype.link_neuron/4","doc":"The link_neuron function links the neuron to another element. For\nexample, to another neuron.","ref":"Bardo.PopulationManager.Genotype.html#link_neuron/4"},{"type":"function","title":"Bardo.PopulationManager.Genotype.new/0","doc":"Creates a new empty genotype.\n\nReturns a map with empty neurons and connections.","ref":"Bardo.PopulationManager.Genotype.html#new/0"},{"type":"function","title":"Examples - Bardo.PopulationManager.Genotype.new/0","doc":"iex> genotype = Bardo.PopulationManager.Genotype.new()\n    %{neurons: %{}, connections: %{}}","ref":"Bardo.PopulationManager.Genotype.html#new/0-examples"},{"type":"function","title":"Bardo.PopulationManager.Genotype.print/1","doc":"Prints out the complete genotype of an agent.","ref":"Bardo.PopulationManager.Genotype.html#print/1"},{"type":"function","title":"Bardo.PopulationManager.Genotype.unique_id/0","doc":"The unique_id creates a unique Id, the\nId is a floating point value. NOT cryptographically strong.","ref":"Bardo.PopulationManager.Genotype.html#unique_id/0"},{"type":"function","title":"Bardo.PopulationManager.Genotype.update_fingerprint/1","doc":"The update_fingerprint calculates the fingerprint of the agent,\nwhere the fingerprint is just a tuple of the various general\nfeatures of the NN based system, a list of features that play some\nrole in distinguishing its genotype's general properties from those\nof other NN systems. The fingerprint here is composed of the\ngeneralized pattern (pattern minus the unique ids), generalized\nevolutionary history (evolutionary history minus the unique ids of\nthe elements), a generalized sensor set, and a generalized actuator\nset.","ref":"Bardo.PopulationManager.Genotype.html#update_fingerprint/1"},{"type":"behaviour","title":"Bardo.PopulationManager.Morphology","doc":"Defines generic morphology behavior.\nThe list of morphologies defines the list of sensors and actuators\navailable to the NNs in a population. Since the morphology defines\nthe sensors and actuators of the NN system, this list effectively\ndefines the problem or simulation to which the evolving population of\nNN systems will be applied, and for what purpose the agents will be\nevolved. The sensors/actuators/scape are a separate part from the NN\nitself, all specified through the morphology module.","ref":"Bardo.PopulationManager.Morphology.html"},{"type":"callback","title":"Bardo.PopulationManager.Morphology.actuators/0","doc":"","ref":"Bardo.PopulationManager.Morphology.html#c:actuators/0"},{"type":"function","title":"Bardo.PopulationManager.Morphology.get_actuators/1","doc":"The get_actuators starts the population off with the NN based\nagents using all available actuators from the start.","ref":"Bardo.PopulationManager.Morphology.html#get_actuators/1"},{"type":"function","title":"Bardo.PopulationManager.Morphology.get_init_actuators/1","doc":"The get_init_actuators starts the population off with the NN based\nagents using just a single actuator, exploring other available\nactuators within the morphology as it evolves.","ref":"Bardo.PopulationManager.Morphology.html#get_init_actuators/1"},{"type":"function","title":"Bardo.PopulationManager.Morphology.get_init_sensors/1","doc":"The get_init_sensors starts the population off with the NN based\nagents using just a single sensor, exploring other available sensors\nwithin the morphology as it evolves.","ref":"Bardo.PopulationManager.Morphology.html#get_init_sensors/1"},{"type":"function","title":"Bardo.PopulationManager.Morphology.get_init_substrate_ceps/2","doc":"The get_init_substrate_ceps starts the population off with the NN based\nagents using just a single substrate_cep, exploring other available\nsubstrate_ceps within the morphology as it evolves.","ref":"Bardo.PopulationManager.Morphology.html#get_init_substrate_ceps/2"},{"type":"function","title":"Bardo.PopulationManager.Morphology.get_init_substrate_cpps/2","doc":"The get_init_substrate_cpps starts the population off with the NN based\nagents using just a single substrate_cpp, exploring other available\nsubstrate_cpps within the morphology as it evolves.","ref":"Bardo.PopulationManager.Morphology.html#get_init_substrate_cpps/2"},{"type":"function","title":"Bardo.PopulationManager.Morphology.get_sensors/1","doc":"The get_sensors starts the population off with the NN based\nagents using all available sensors from the start.","ref":"Bardo.PopulationManager.Morphology.html#get_sensors/1"},{"type":"function","title":"Bardo.PopulationManager.Morphology.get_substrate_ceps/2","doc":"The get_substrate_ceps starts the population off with the NN based\nagents using substrate_ceps determined by the Plasticity.","ref":"Bardo.PopulationManager.Morphology.html#get_substrate_ceps/2"},{"type":"function","title":"Bardo.PopulationManager.Morphology.get_substrate_cpps/2","doc":"The get_substrate_cpps starts the population off with the NN based\nagents using substrate_cpps determined by Dimensions and Plasticity.\nSubstrate CPPs:\nx cartesian: The cartesian cpp simply forwards to the NN the appended\n  coordinates of the two connected neurodes. Because each neurode has\n  a coordinate specified by a list of length: Dimension, the vector\n  specifying the two appended coordinates will have\n  vl = Dimensions * 2. For example: [X1,Y1,Z1,X2,Y2,Z2] will have a\n  vector length of dimension: vl = 3*2 = 6.\nx centripetal_distances: This cpp uses the Cartesian coordinates of\n  the two neurodes to calculate the Cartesian distance of neurode_1\n  to the center of the substrate located at the origin, and the\n  Cartesian distance of neurode_2 to the center of the substrate.\n  It then fans out to the NN the vector of length 2, composed of the\n  two distances.\nx cartesian_distance: This cpp calculates the Cartesian distance\n  between the two neurodes, forwarding the resulting vector of\n  length 1 to the NN.\nx cartesian_CoordDiffs: This cpp calculates the difference between\n  each coordinate element of the two neurodes, and thus for this cpp,\n  the vl = Dimensions.\nx cartesian_GaussedCoordDiffs: Exactly the same as the above cpp, but\n  each of the values is first sent through the Gaussian function\n  before it is entered into the vector.\nx polar: This cpp converts the Cartesian coordinates to polar\n  coordinates. This can only be done if the substrate is 2d.\nx spherical: This cpp converts the Cartesian coordinates to the\n  spherical coordinates. This can only be done if the substrate is 3d.","ref":"Bardo.PopulationManager.Morphology.html#get_substrate_cpps/2"},{"type":"callback","title":"Bardo.PopulationManager.Morphology.sensors/0","doc":"Defines the behavior for morphology modules.","ref":"Bardo.PopulationManager.Morphology.html#c:sensors/0"},{"type":"module","title":"Bardo.PopulationManager.SelectionAlgorithm","doc":"The SelectionAlgorithm module provides different strategies for selecting agents for reproduction.","ref":"Bardo.PopulationManager.SelectionAlgorithm.html"},{"type":"module","title":"Overview - Bardo.PopulationManager.SelectionAlgorithm","doc":"Selection algorithms determine which agents in a population survive and reproduce. \nThese algorithms form the backbone of the evolutionary process by implementing the \nprinciple of \"survival of the fittest.\"","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#module-overview"},{"type":"module","title":"Selection Strategies - Bardo.PopulationManager.SelectionAlgorithm","doc":"Bardo implements several selection strategies, each with different characteristics:","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#module-selection-strategies"},{"type":"module","title":"Hall of Fame Competition - Bardo.PopulationManager.SelectionAlgorithm","doc":"* Maintains an elite subset of the best-performing agents across generations\n* New agents must compete against the hall of fame to be selected\n* Provides protection against evolutionary forgetting and cycling","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#module-hall-of-fame-competition"},{"type":"module","title":"Tournament Selection - Bardo.PopulationManager.SelectionAlgorithm","doc":"* Randomly selects subgroups of agents and chooses the best from each group\n* Selection pressure can be tuned by adjusting tournament size\n* Balances exploration and exploitation effectively","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#module-tournament-selection"},{"type":"module","title":"Truncation Selection - Bardo.PopulationManager.SelectionAlgorithm","doc":"* Simply selects the top N performers from the population\n* Provides high selection pressure for rapid convergence\n* May lead to premature convergence on suboptimal solutions","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#module-truncation-selection"},{"type":"module","title":"Rank-Based Selection - Bardo.PopulationManager.SelectionAlgorithm","doc":"* Selection probability is based on rank rather than absolute fitness\n* Maintains selection pressure even when fitness differences are small\n* Helps prevent premature convergence in some scenarios","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#module-rank-based-selection"},{"type":"module","title":"Fitness Proportionate Selection - Bardo.PopulationManager.SelectionAlgorithm","doc":"* Also known as \"roulette wheel\" selection\n* Selection probability is directly proportional to fitness\n* Simple but can lead to early domination by slightly superior agents","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#module-fitness-proportionate-selection"},{"type":"module","title":"Implementation Notes - Bardo.PopulationManager.SelectionAlgorithm","doc":"* Selection algorithms operate within species to preserve diversity\n* Parameters can adjust selection pressure to balance exploration vs. exploitation\n* Custom selection algorithms can be implemented by adding new functions to this module","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#module-implementation-notes"},{"type":"function","title":"Bardo.PopulationManager.SelectionAlgorithm.choose_winners/6","doc":"Choose winners for the next generation based on fitness scores.","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#choose_winners/6"},{"type":"function","title":"Bardo.PopulationManager.SelectionAlgorithm.hof_competition/3","doc":"Implementation of the 'hof_competition' selection algorithm.","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#hof_competition/3"},{"type":"function","title":"Bardo.PopulationManager.SelectionAlgorithm.hof_efficiency/3","doc":"Implementation of the 'hof_efficiency' selection algorithm.","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#hof_efficiency/3"},{"type":"function","title":"Bardo.PopulationManager.SelectionAlgorithm.hof_random/3","doc":"Implementation of the 'hof_random' selection algorithm.","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#hof_random/3"},{"type":"function","title":"Bardo.PopulationManager.SelectionAlgorithm.hof_rank/3","doc":"Implementation of the 'hof_rank' selection algorithm.","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#hof_rank/3"},{"type":"function","title":"Bardo.PopulationManager.SelectionAlgorithm.hof_top3/3","doc":"Implementation of the 'hof_top3' selection algorithm.","ref":"Bardo.PopulationManager.SelectionAlgorithm.html#hof_top3/3"},{"type":"module","title":"Bardo.Examples.Benchmarks.Dpb","doc":"Double Pole Balancing (DPB) benchmark for neuroevolution algorithms.\n\nThis module provides functionality for running and testing the Double\nPole Balancing benchmark problem, a common benchmark for testing the\nefficacy of neural network controllers evolved through neuroevolution.\n\nThe benchmark consists of balancing a double pole system attached to a cart\nthat can move horizontally back and forth. The cart must balance two poles\nof different lengths by applying a horizontal force to keep them upright.\n\nTwo versions of the benchmark are available:\n\n1. DPB With Damping - Velocities are provided to the agent\n2. DPB Without Damping - A harder task where velocities are not provided\n\nThis module provides functionality for both versions, and includes\nfeatures for:\n\n- Running a complete evolutionary experiment with the DPB benchmark\n- Testing evolved controllers\n- Visualizing the behavior of the controllers","ref":"Bardo.Examples.Benchmarks.Dpb.html"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.configure_with_damping/4","doc":"Creates a configuration for a DPB experiment with damping.","ref":"Bardo.Examples.Benchmarks.Dpb.html#configure_with_damping/4"},{"type":"function","title":"Parameters - Bardo.Examples.Benchmarks.Dpb.configure_with_damping/4","doc":"* `id` - Identifier for this experiment\n  * `population_size` - Number of individuals per generation (default: 100)\n  * `iterations` - Maximum number of generations to evolve (default: 50)\n  * `max_steps` - Maximum simulation steps in fitness evaluation (default: 100000)","ref":"Bardo.Examples.Benchmarks.Dpb.html#configure_with_damping/4-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Benchmarks.Dpb.configure_with_damping/4","doc":"* Map with experiment configuration","ref":"Bardo.Examples.Benchmarks.Dpb.html#configure_with_damping/4-returns"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.configure_without_damping/4","doc":"Creates a configuration for a DPB experiment without damping.","ref":"Bardo.Examples.Benchmarks.Dpb.html#configure_without_damping/4"},{"type":"function","title":"Parameters - Bardo.Examples.Benchmarks.Dpb.configure_without_damping/4","doc":"* `id` - Identifier for this experiment\n  * `population_size` - Number of individuals per generation (default: 100)\n  * `iterations` - Maximum number of generations to evolve (default: 50)\n  * `max_steps` - Maximum simulation steps in fitness evaluation (default: 100000)","ref":"Bardo.Examples.Benchmarks.Dpb.html#configure_without_damping/4-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Benchmarks.Dpb.configure_without_damping/4","doc":"* Map with experiment configuration","ref":"Bardo.Examples.Benchmarks.Dpb.html#configure_without_damping/4-returns"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.run_with_damping/5","doc":"Run the Double Pole Balancing benchmark with damping forces.\n\nThis runs the simpler variant of DPB where velocities are provided to the\nneural network. This variant is helpful for verifying that the system works\nas expected before moving to more difficult versions.","ref":"Bardo.Examples.Benchmarks.Dpb.html#run_with_damping/5"},{"type":"function","title":"Parameters - Bardo.Examples.Benchmarks.Dpb.run_with_damping/5","doc":"* `experiment_id` - Identifier for this experiment\n  * `population_size` - Number of individuals per generation\n  * `generations` - Maximum number of generations to evolve\n  * `max_steps` - Maximum simulation steps in fitness evaluation (default: 1000)\n  * `visualize` - Whether to visualize best agent after evolution (default: false)","ref":"Bardo.Examples.Benchmarks.Dpb.html#run_with_damping/5-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Benchmarks.Dpb.run_with_damping/5","doc":"* `:ok` - Experiment started successfully\n  * `{:error, reason}` - If there was an error starting the experiment","ref":"Bardo.Examples.Benchmarks.Dpb.html#run_with_damping/5-returns"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.run_without_damping/5","doc":"Run the Double Pole Balancing benchmark without damping forces.\n\nThis runs the harder variant of DPB where velocities are not provided to\nthe neural network. The agent must approximate the velocities through the\nuse of recurrent connections.","ref":"Bardo.Examples.Benchmarks.Dpb.html#run_without_damping/5"},{"type":"function","title":"Parameters - Bardo.Examples.Benchmarks.Dpb.run_without_damping/5","doc":"* `experiment_id` - Identifier for this experiment\n  * `population_size` - Number of individuals per generation\n  * `generations` - Maximum number of generations to evolve\n  * `max_steps` - Maximum simulation steps in fitness evaluation (default: 1000)\n  * `visualize` - Whether to visualize best agent after evolution (default: false)","ref":"Bardo.Examples.Benchmarks.Dpb.html#run_without_damping/5-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Benchmarks.Dpb.run_without_damping/5","doc":"* `:ok` - Experiment started successfully\n  * `{:error, reason}` - If there was an error starting the experiment","ref":"Bardo.Examples.Benchmarks.Dpb.html#run_without_damping/5-returns"},{"type":"function","title":"Bardo.Examples.Benchmarks.Dpb.test_best_solution/3","doc":"Test the best solution from an experiment.\n\nThis function loads the best genotype from a completed experiment and tests\nit by running a simulation with the neural network controller.","ref":"Bardo.Examples.Benchmarks.Dpb.html#test_best_solution/3"},{"type":"function","title":"Parameters - Bardo.Examples.Benchmarks.Dpb.test_best_solution/3","doc":"* `experiment_id` - The ID of the experiment to test\n  * `max_steps` - Maximum steps to run the simulation (default: 100000)\n  * `visualize` - Whether to visualize the run (default: false)","ref":"Bardo.Examples.Benchmarks.Dpb.html#test_best_solution/3-parameters"},{"type":"function","title":"Returns - Bardo.Examples.Benchmarks.Dpb.test_best_solution/3","doc":"* Map of test results if successful\n  * `{:error, reason}` - If there was an error during testing\n\nReturns results of the test run.","ref":"Bardo.Examples.Benchmarks.Dpb.html#test_best_solution/3-returns"},{"type":"module","title":"Bardo.Examples.Simple.Xor","doc":"A simple example demonstrating how to evolve a neural network to solve the XOR problem.\n\nThis is a self-contained example that doesn't rely on the full machinery of the\npopulation and experiment managers, making it easier to understand and a good\nstarting point.","ref":"Bardo.Examples.Simple.Xor.html"},{"type":"function","title":"Bardo.Examples.Simple.Xor.run/1","doc":"Run the XOR example.","ref":"Bardo.Examples.Simple.Xor.html#run/1"},{"type":"function","title":"Options - Bardo.Examples.Simple.Xor.run/1","doc":"* `:population_size` - size of the population (default: 100)\n* `:max_generations` - maximum number of generations (default: 50)\n* `:show_progress` - show progress during evolution (default: true)\n* `:verbose` - show detailed information (default: false)","ref":"Bardo.Examples.Simple.Xor.html#run/1-options"},{"type":"function","title":"Examples - Bardo.Examples.Simple.Xor.run/1","doc":"iex> Bardo.Examples.Simple.Xor.run()\n    \n    # With custom parameters\n    iex> Bardo.Examples.Simple.Xor.run(population_size: 150, max_generations: 100)","ref":"Bardo.Examples.Simple.Xor.html#run/1-examples"},{"type":"module","title":"Bardo.DB","doc":"A simple, efficient database for the Bardo neuroevolution system.\n\nUses ETS (Erlang Term Storage) for in-memory storage with periodic backups.\nThis implementation is designed for efficiency and simplicity, making it ideal\nfor use as a library dependency in other projects.","ref":"Bardo.DB.html"},{"type":"function","title":"Bardo.DB.backup/1","doc":"Back up the database to disk.","ref":"Bardo.DB.html#backup/1"},{"type":"function","title":"Parameters - Bardo.DB.backup/1","doc":"* `backup_path` - Directory to store the backup (default: \"backups\")","ref":"Bardo.DB.html#backup/1-parameters"},{"type":"function","title":"Returns - Bardo.DB.backup/1","doc":"* `{:ok, backup_file}` on success\n* `{:error, reason}` on failure","ref":"Bardo.DB.html#backup/1-returns"},{"type":"function","title":"Bardo.DB.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.DB.html#child_spec/1"},{"type":"function","title":"Bardo.DB.delete/2","doc":"Delete a value from the database.","ref":"Bardo.DB.html#delete/2"},{"type":"function","title":"Parameters - Bardo.DB.delete/2","doc":"* `table` - The table to delete from\n* `key` - The key to delete","ref":"Bardo.DB.html#delete/2-parameters"},{"type":"function","title":"Bardo.DB.exists?/2","doc":"Check if a key exists in the database.","ref":"Bardo.DB.html#exists?/2"},{"type":"function","title":"Parameters - Bardo.DB.exists?/2","doc":"* `table` - The table to check\n* `key` - The key to check","ref":"Bardo.DB.html#exists?/2-parameters"},{"type":"function","title":"Returns - Bardo.DB.exists?/2","doc":"* `true` if the key exists\n* `false` if the key doesn't exist","ref":"Bardo.DB.html#exists?/2-returns"},{"type":"function","title":"Bardo.DB.fetch/2","doc":"Fetch a value from the database.","ref":"Bardo.DB.html#fetch/2"},{"type":"function","title":"Parameters - Bardo.DB.fetch/2","doc":"* `table` - The table to fetch from\n* `key` - The key to fetch","ref":"Bardo.DB.html#fetch/2-parameters"},{"type":"function","title":"Returns - Bardo.DB.fetch/2","doc":"* `{:ok, value}` on success\n* `{:error, :not_found}` if the key doesn't exist","ref":"Bardo.DB.html#fetch/2-returns"},{"type":"function","title":"Bardo.DB.list/1","doc":"List all values for a specific table type.","ref":"Bardo.DB.html#list/1"},{"type":"function","title":"Parameters - Bardo.DB.list/1","doc":"* `table` - The table to list values from","ref":"Bardo.DB.html#list/1-parameters"},{"type":"function","title":"Returns - Bardo.DB.list/1","doc":"* `{:ok, [values]}` on success\n* `{:ok, []}` if the table is empty","ref":"Bardo.DB.html#list/1-returns"},{"type":"function","title":"Bardo.DB.read/2","doc":"Read a value from the database using the models format.\n\nThis is a compatibility function for code that uses the Models module.","ref":"Bardo.DB.html#read/2"},{"type":"function","title":"Parameters - Bardo.DB.read/2","doc":"* `id` - The ID to read\n* `table` - The table to read from","ref":"Bardo.DB.html#read/2-parameters"},{"type":"function","title":"Returns - Bardo.DB.read/2","doc":"* The value if found\n* `:not_found` if the key doesn't exist","ref":"Bardo.DB.html#read/2-returns"},{"type":"function","title":"Bardo.DB.restore/1","doc":"Restore the database from a backup file.","ref":"Bardo.DB.html#restore/1"},{"type":"function","title":"Parameters - Bardo.DB.restore/1","doc":"* `backup_file` - Path to the backup file","ref":"Bardo.DB.html#restore/1-parameters"},{"type":"function","title":"Returns - Bardo.DB.restore/1","doc":"* `:ok` on success\n* `{:error, reason}` on failure","ref":"Bardo.DB.html#restore/1-returns"},{"type":"function","title":"Bardo.DB.start_link/1","doc":"Start the database server.","ref":"Bardo.DB.html#start_link/1"},{"type":"function","title":"Options - Bardo.DB.start_link/1","doc":"* `:auto_backup` - Whether to run automatic backups (default: true)\n* `:backup_dir` - Directory to store backups (default: \"backups\")","ref":"Bardo.DB.html#start_link/1-options"},{"type":"function","title":"Bardo.DB.store/3","doc":"Store a value in the database.","ref":"Bardo.DB.html#store/3"},{"type":"function","title":"Parameters - Bardo.DB.store/3","doc":"* `table` - The table to store the value in (e.g., :experiment, :population)\n* `key` - The key to store the value under\n* `value` - The value to store","ref":"Bardo.DB.html#store/3-parameters"},{"type":"function","title":"Bardo.DB.write/2","doc":"Write a value to the database using the models format.\n\nThis is a compatibility function for code that uses the Models module.","ref":"Bardo.DB.html#write/2"},{"type":"function","title":"Parameters - Bardo.DB.write/2","doc":"* `value` - The model value to write\n* `table` - The table to write to","ref":"Bardo.DB.html#write/2-parameters"},{"type":"module","title":"Bardo.DBMock","doc":"Mock implementation of the DB module for testing.","ref":"Bardo.DBMock.html"},{"type":"function","title":"Bardo.DBMock.child_spec/1","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","ref":"Bardo.DBMock.html#child_spec/1"},{"type":"function","title":"Bardo.DBMock.delete/2","doc":"","ref":"Bardo.DBMock.html#delete/2"},{"type":"function","title":"Bardo.DBMock.init/1","doc":"Callback implementation for  GenServer.init/1 .","ref":"Bardo.DBMock.html#init/1"},{"type":"function","title":"Bardo.DBMock.read/2","doc":"","ref":"Bardo.DBMock.html#read/2"},{"type":"function","title":"Bardo.DBMock.start_link/1","doc":"","ref":"Bardo.DBMock.html#start_link/1"},{"type":"function","title":"Bardo.DBMock.write/3","doc":"","ref":"Bardo.DBMock.html#write/3"},{"type":"module","title":"Bardo.Functions","doc":"The Functions module contains the activation functions used by the\nneuron, and other mathematical functions used by the system. Through\nthe Functions module, the activation functions are fully decoupled\nfrom the neurons using them. A neuron can use any activation\nfunction, no matter its form, as long as it returns a properly\nformatted value.\n\nNOTE: While the activation functions are all stored in the Functions module,\nthe aggregation and the plasticity functions are stored in the SignalAggregator\nand Plasticity modules respectively.","ref":"Bardo.Functions.html"},{"type":"function","title":"Bardo.Functions.absolute/1","doc":"","ref":"Bardo.Functions.html#absolute/1"},{"type":"function","title":"Bardo.Functions.avg/1","doc":"The avg/1 function accepts a list for a parameter, and then returns\nthe average of the list to the caller.","ref":"Bardo.Functions.html#avg/1"},{"type":"function","title":"Bardo.Functions.bin/1","doc":"The bin/1 function converts val into a binary value, 1 if val > 0,\nand 0 if val <= 0.","ref":"Bardo.Functions.html#bin/1"},{"type":"function","title":"Bardo.Functions.cartesian2polar/1","doc":"","ref":"Bardo.Functions.html#cartesian2polar/1"},{"type":"function","title":"Bardo.Functions.cartesian2spherical/1","doc":"","ref":"Bardo.Functions.html#cartesian2spherical/1"},{"type":"function","title":"Bardo.Functions.cartesian/2","doc":"","ref":"Bardo.Functions.html#cartesian/2"},{"type":"function","title":"Bardo.Functions.cartesian/3","doc":"","ref":"Bardo.Functions.html#cartesian/3"},{"type":"function","title":"Bardo.Functions.cartesian_coord_diffs/2","doc":"","ref":"Bardo.Functions.html#cartesian_coord_diffs/2"},{"type":"function","title":"Bardo.Functions.cartesian_coord_diffs/3","doc":"","ref":"Bardo.Functions.html#cartesian_coord_diffs/3"},{"type":"function","title":"Bardo.Functions.cartesian_distance/2","doc":"","ref":"Bardo.Functions.html#cartesian_distance/2"},{"type":"function","title":"Bardo.Functions.cartesian_distance/3","doc":"","ref":"Bardo.Functions.html#cartesian_distance/3"},{"type":"function","title":"Bardo.Functions.cartesian_gaussed_coord_diffs1/3","doc":"","ref":"Bardo.Functions.html#cartesian_gaussed_coord_diffs1/3"},{"type":"function","title":"Bardo.Functions.cartesian_gaussed_coord_diffs/2","doc":"","ref":"Bardo.Functions.html#cartesian_gaussed_coord_diffs/2"},{"type":"function","title":"Bardo.Functions.cartesian_gaussed_coord_diffs/3","doc":"","ref":"Bardo.Functions.html#cartesian_gaussed_coord_diffs/3"},{"type":"function","title":"Bardo.Functions.centripital_distances/2","doc":"","ref":"Bardo.Functions.html#centripital_distances/2"},{"type":"function","title":"Bardo.Functions.centripital_distances/3","doc":"","ref":"Bardo.Functions.html#centripital_distances/3"},{"type":"function","title":"Bardo.Functions.cos/1","doc":"","ref":"Bardo.Functions.html#cos/1"},{"type":"function","title":"Bardo.Functions.distance/2","doc":"","ref":"Bardo.Functions.html#distance/2"},{"type":"function","title":"Bardo.Functions.distance/3","doc":"","ref":"Bardo.Functions.html#distance/3"},{"type":"function","title":"Bardo.Functions.gaussian/1","doc":"","ref":"Bardo.Functions.html#gaussian/1"},{"type":"function","title":"Bardo.Functions.gaussian/2","doc":"","ref":"Bardo.Functions.html#gaussian/2"},{"type":"function","title":"Bardo.Functions.iow/3","doc":"","ref":"Bardo.Functions.html#iow/3"},{"type":"function","title":"Bardo.Functions.linear/1","doc":"","ref":"Bardo.Functions.html#linear/1"},{"type":"function","title":"Bardo.Functions.log/1","doc":"","ref":"Bardo.Functions.html#log/1"},{"type":"function","title":"Bardo.Functions.multiquadric/1","doc":"","ref":"Bardo.Functions.html#multiquadric/1"},{"type":"function","title":"Bardo.Functions.normalize/1","doc":"","ref":"Bardo.Functions.html#normalize/1"},{"type":"function","title":"Bardo.Functions.polar2cartesian/1","doc":"","ref":"Bardo.Functions.html#polar2cartesian/1"},{"type":"function","title":"Bardo.Functions.polar/2","doc":"","ref":"Bardo.Functions.html#polar/2"},{"type":"function","title":"Bardo.Functions.polar/3","doc":"","ref":"Bardo.Functions.html#polar/3"},{"type":"function","title":"Bardo.Functions.quadratic/1","doc":"","ref":"Bardo.Functions.html#quadratic/1"},{"type":"function","title":"Bardo.Functions.relu/1","doc":"","ref":"Bardo.Functions.html#relu/1"},{"type":"function","title":"Bardo.Functions.sat/3","doc":"The sat/3 function is similar to saturation/2 function, but here the\nmax and min can be different, and are specified by the caller.","ref":"Bardo.Functions.html#sat/3"},{"type":"function","title":"Bardo.Functions.sat_dzone/5","doc":"The sat_dzone/5 function is similar to the sat/3 function, but here,\nif val is between dzmin and dzmax, it is zeroed.","ref":"Bardo.Functions.html#sat_dzone/5"},{"type":"function","title":"Bardo.Functions.saturation/1","doc":"The function saturation/1 accepts a value val, and returns the same if\nits magnitude is below 1000. Otherwise it returns -1000 or 1000, if\nit's less than or greater than -1000 or 1000 respectively. Thus val\nsaturates at -1000 and 1000.","ref":"Bardo.Functions.html#saturation/1"},{"type":"function","title":"Bardo.Functions.saturation/2","doc":"The saturation/2 function is similar to saturation/1, but here the\nspread (symmetric max and min values) is specified by the caller.","ref":"Bardo.Functions.html#saturation/2"},{"type":"function","title":"Bardo.Functions.scale/3","doc":"The scale/3 function accepts a list of values, and scales them to be\nbetween the specified min and max values.","ref":"Bardo.Functions.html#scale/3"},{"type":"function","title":"Bardo.Functions.sgn/1","doc":"","ref":"Bardo.Functions.html#sgn/1"},{"type":"function","title":"Bardo.Functions.sigmoid1/1","doc":"","ref":"Bardo.Functions.html#sigmoid1/1"},{"type":"function","title":"Bardo.Functions.sigmoid/1","doc":"","ref":"Bardo.Functions.html#sigmoid/1"},{"type":"function","title":"Bardo.Functions.sin/1","doc":"","ref":"Bardo.Functions.html#sin/1"},{"type":"function","title":"Bardo.Functions.spherical2cartesian/1","doc":"","ref":"Bardo.Functions.html#spherical2cartesian/1"},{"type":"function","title":"Bardo.Functions.spherical/2","doc":"","ref":"Bardo.Functions.html#spherical/2"},{"type":"function","title":"Bardo.Functions.spherical/3","doc":"","ref":"Bardo.Functions.html#spherical/3"},{"type":"function","title":"Bardo.Functions.sqrt/1","doc":"","ref":"Bardo.Functions.html#sqrt/1"},{"type":"function","title":"Bardo.Functions.std/1","doc":"The std/1 function accepts a list for a parameter, and then returns to\nthe caller the standard deviation of the list.","ref":"Bardo.Functions.html#std/1"},{"type":"function","title":"Bardo.Functions.std/3","doc":"","ref":"Bardo.Functions.html#std/3"},{"type":"function","title":"Bardo.Functions.tanh/1","doc":"","ref":"Bardo.Functions.html#tanh/1"},{"type":"function","title":"Bardo.Functions.to_cartesian/1","doc":"","ref":"Bardo.Functions.html#to_cartesian/1"},{"type":"function","title":"Bardo.Functions.trinary/1","doc":"The trinary/1 function converts val into a trinary value.","ref":"Bardo.Functions.html#trinary/1"},{"type":"function","title":"Bardo.Functions.vector_difference/2","doc":"","ref":"Bardo.Functions.html#vector_difference/2"},{"type":"function","title":"Bardo.Functions.vector_difference/3","doc":"","ref":"Bardo.Functions.html#vector_difference/3"},{"type":"module","title":"Bardo.Logger","doc":"Custom logging functionality for the Bardo system.\n\nProvides structured logging capabilities and integration with the standard\nElixir Logger. Also includes filters for specialized log handling.","ref":"Bardo.Logger.html"},{"type":"function","title":"Bardo.Logger.alert/1","doc":"Log an alert message.","ref":"Bardo.Logger.html#alert/1"},{"type":"function","title":"Bardo.Logger.critical/1","doc":"Log a critical message.","ref":"Bardo.Logger.html#critical/1"},{"type":"function","title":"Bardo.Logger.debug/1","doc":"Log a debug message.","ref":"Bardo.Logger.html#debug/1"},{"type":"function","title":"Bardo.Logger.emergency/1","doc":"Log an emergency message.","ref":"Bardo.Logger.html#emergency/1"},{"type":"function","title":"Bardo.Logger.error/1","doc":"Log an error message.","ref":"Bardo.Logger.html#error/1"},{"type":"function","title":"Bardo.Logger.info/1","doc":"Log an info message.","ref":"Bardo.Logger.html#info/1"},{"type":"type","title":"Bardo.Logger.log_body/0","doc":"A structured log entry with component information.","ref":"Bardo.Logger.html#t:log_body/0"},{"type":"function","title":"Bardo.Logger.notice/1","doc":"Log a notice message.","ref":"Bardo.Logger.html#notice/1"},{"type":"function","title":"Bardo.Logger.scape_filter/2","doc":"Filter to only show logs from scape modules.","ref":"Bardo.Logger.html#scape_filter/2"},{"type":"function","title":"Bardo.Logger.status_filter/2","doc":"Filter to only show status messages or error results.","ref":"Bardo.Logger.html#status_filter/2"},{"type":"function","title":"Bardo.Logger.warning/1","doc":"Log a warning message.","ref":"Bardo.Logger.html#warning/1"},{"type":"module","title":"Bardo.Utils","doc":"Utility functions for the Bardo system.","ref":"Bardo.Utils.html"},{"type":"function","title":"Bardo.Utils.get_module/1","doc":"Return correct module syntax based on SDK environment configuration.","ref":"Bardo.Utils.html#get_module/1"},{"type":"function","title":"Bardo.Utils.random_seed/0","doc":"Seed PRNG for the current process.\n\nUses exs1024s (not cryptographically strong, but fast).","ref":"Bardo.Utils.html#random_seed/0"},{"type":"function","title":"Bardo.Utils.random_string/1","doc":"Generate a random string of the specified length.","ref":"Bardo.Utils.html#random_string/1"},{"type":"function","title":"Parameters - Bardo.Utils.random_string/1","doc":"* `length` - The length of the random string to generate","ref":"Bardo.Utils.html#random_string/1-parameters"},{"type":"function","title":"Returns - Bardo.Utils.random_string/1","doc":"* A random string of the specified length","ref":"Bardo.Utils.html#random_string/1-returns"},{"type":"function","title":"Bardo.Utils.safe_binary_to_term/1","doc":"Safely convert binary to Erlang term.","ref":"Bardo.Utils.html#safe_binary_to_term/1"},{"type":"function","title":"Bardo.Utils.safe_serialize_erlang/1","doc":"Safely serialize Erlang term to binary.","ref":"Bardo.Utils.html#safe_serialize_erlang/1"},{"type":"function","title":"Bardo.Utils.sat/2","doc":"Saturate a value between a minimum and maximum limit.","ref":"Bardo.Utils.html#sat/2"},{"type":"function","title":"Examples - Bardo.Utils.sat/2","doc":"iex> Bardo.Utils.sat(1.5, 1.0)\n    1.0\n    \n    iex> Bardo.Utils.sat(-1.5, 1.0) \n    -1.0\n    \n    iex> Bardo.Utils.sat(0.5, 1.0)\n    0.5","ref":"Bardo.Utils.html#sat/2-examples"},{"type":"function","title":"Bardo.Utils.system_metrics/0","doc":"Return system metrics.","ref":"Bardo.Utils.html#system_metrics/0"},{"type":"function","title":"Bardo.Utils.vec1_dominates_vec2/3","doc":"Checks if vector A dominates vector B with a minimum improvement percentage.\n\nReturns true if all elements in A are significantly better than in B.","ref":"Bardo.Utils.html#vec1_dominates_vec2/3"},{"type":"function","title":"Bardo.Utils.vec1_dominates_vec2/4","doc":"Calculate vector difference with minimum improvement percentage (MIP).","ref":"Bardo.Utils.html#vec1_dominates_vec2/4"},{"type":"extras","title":"Bardo","doc":"# Bardo\n\nBardo is a focused neuroevolution library for Elixir that evolves neural networks through evolutionary algorithms. Built on the Erlang VM, it leverages concurrent processes for efficient neural network simulation and evolution.","ref":"readme.html"},{"type":"extras","title":"Features - Bardo","doc":"- **Topology and Parameter Evolving Neural Networks (TWEANN)**: Neural networks evolve their structure and weights over time\n- **Efficient ETS-based Storage**: Simple and fast in-memory storage with periodic backups\n- **Modular Sensor/Actuator Framework**: Easily connect networks to different environments\n- **Built-in Evolutionary Algorithms**: Includes selection algorithms and mutation operators\n- **Substrate Encoding**: Hypercube-based encoding for efficient pattern recognition\n- **Example Environments**: XOR, Double Pole Balancing, Flatland, and Simple FX simulations","ref":"readme.html#features"},{"type":"extras","title":"Installation - Bardo","doc":"Add `bardo` to your list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:bardo, \"~> 0.1.0\"}\n  ]\nend\n```\n\nThen run:\n\n```shell\nmix deps.get\n```\n\nStart the Bardo processes in your application's supervision tree or startup code:\n\n```elixir\n# In your application.ex\ndef start(_type, _args) do\n  children = [\n    # ...your other children\n    {Bardo, []}\n  ]\n\n  Supervisor.start_link(children, strategy: :one_for_one)\nend\n```\n\nOr start it manually in your code:\n\n```elixir\nBardo.start()\n```","ref":"readme.html#installation"},{"type":"extras","title":"Documentation - Bardo","doc":"Comprehensive documentation is available:\n\n- [Quick Start Guide](docs/quickstart.md) - Get up and running quickly\n- [Library Tutorial](docs/library_tutorial.md) - Using Bardo in your own applications\n- [API Reference](docs/api_reference.md) - Detailed API documentation\n- [Examples](docs/examples.md) - Example usages\n- [Extending Bardo](docs/extending.md) - Creating custom components\n- [Advanced Topics](docs/advanced.md) - Advanced features and techniques","ref":"readme.html#documentation"},{"type":"extras","title":"Quick Start - Bardo","doc":"","ref":"readme.html#quick-start"},{"type":"extras","title":"XOR Example - Bardo","doc":"The simplest way to get started is to run the XOR example:\n\n```elixir\n# Start IEx with Bardo\niex -S mix\n\n# Run the XOR example\niex> Bardo.Examples.Simple.Xor.run()\n```","ref":"readme.html#xor-example"},{"type":"extras","title":"Creating Your Own Experiment - Bardo","doc":"To set up your own neuroevolution experiment:\n\n```elixir\n# Create a new experiment\nexperiment = Bardo.ExperimentManager.new_experiment(\"my_experiment\")\n\n# Configure it\nBardo.ExperimentManager.configure(experiment, %{\n  population_size: 100,\n  max_generations: 200,\n  mutation_rate: 0.3\n})\n\n# Define a fitness function\ndefmodule MyFitness do\n  def evaluate(agent) do\n    # Your fitness calculation here\n    # Returns a numeric score\n  end\nend\n\n# Start the experiment with your fitness function\nBardo.ExperimentManager.start(experiment, &MyFitness.evaluate/1)\n\n# Check progress\nBardo.ExperimentManager.status(experiment)\n\n# Get the best solution\nbest_agent = Bardo.ExperimentManager.get_best_solution(experiment)\n```","ref":"readme.html#creating-your-own-experiment"},{"type":"extras","title":"Core Examples - Bardo","doc":"Bardo includes several examples to demonstrate different aspects of neuroevolution:","ref":"readme.html#core-examples"},{"type":"extras","title":"1. XOR - Bardo","doc":"A simple example that evolves a neural network to solve the XOR problem.\n\n```elixir\nBardo.Examples.Simple.Xor.run(population_size: 100, max_generations: 50)\n```","ref":"readme.html#1-xor"},{"type":"extras","title":"2. Double Pole Balancing - Bardo","doc":"A classic control problem where a neural network learns to balance two poles on a cart.\n\n```elixir\niex> Bardo.Examples.Benchmarks.Dpb.run_with_damping(:dpb_example, 50, 20, 10000)\n```","ref":"readme.html#2-double-pole-balancing"},{"type":"extras","title":"3. Flatland - Bardo","doc":"A predator-prey simulation in a 2D world where agents co-evolve.\n\n```elixir\niex> Bardo.Examples.Applications.Flatland.run(:flatland_example, 10, 10, 20, 500, 10)\n```","ref":"readme.html#3-flatland"},{"type":"extras","title":"4. Simple FX - Bardo","doc":"A basic forex trading simulation to demonstrate time series prediction.\n\n```elixir\n# Standard FX example\niex> Bardo.Examples.Applications.Fx.run(:fx_example, 50, 1000, 20)\n```","ref":"readme.html#4-simple-fx"},{"type":"extras","title":"Core Concepts - Bardo","doc":"","ref":"readme.html#core-concepts"},{"type":"extras","title":"Genotypes - Bardo","doc":"Genetic representations of neural networks:\n\n```elixir\n# Create a new genotype\ngenotype = Bardo.PopulationManager.Genotype.new()\n\n# Add neurons\ngenotype = Bardo.PopulationManager.Genotype.add_neuron(genotype, :hidden)\n\n# Add connections between neurons\ngenotype = Bardo.PopulationManager.Genotype.add_connection(genotype, input_id, output_id, weight)\n\n# Mutate the genotype\nmutated_genotype = Bardo.PopulationManager.GenomeMutator.mutate(genotype)\n```","ref":"readme.html#genotypes"},{"type":"extras","title":"Neural Networks - Bardo","doc":"Working with the neural networks created from genotypes:\n\n```elixir\n# Convert genotype to neural network\nnn = Bardo.AgentManager.Cortex.from_genotype(genotype)\n\n# Activate the network with inputs\noutputs = Bardo.AgentManager.Cortex.activate(nn, [1.0, 0.0])\n```","ref":"readme.html#neural-networks"},{"type":"extras","title":"Sensors and Actuators - Bardo","doc":"Interface between neural networks and their environment:\n\n```elixir\n# Add a sensor to a neural network\nnn = Bardo.AgentManager.Cortex.add_sensor(nn, MyApp.Sensors.Vision)\n\n# Add an actuator to a neural network\nnn = Bardo.AgentManager.Cortex.add_actuator(nn, MyApp.Actuators.Motor)\n```","ref":"readme.html#sensors-and-actuators"},{"type":"extras","title":"Architecture - Bardo","doc":"Bardo is organized into several key modules:\n\n- **ExperimentManager**: Controls the overall experiment process\n- **PopulationManager**: Handles populations of evolving agents\n- **AgentManager**: Manages the neural networks and their interactions\n- **ScapeManager**: Provides environments for agents to operate in","ref":"readme.html#architecture"},{"type":"extras","title":"Custom Environments - Bardo","doc":"To create your own environment, you'll need to define custom sensors and actuators:\n\n```elixir\ndefmodule MyEnvironment.Sensor do\n  @behaviour Bardo.AgentManager.Sensor\n  \n  # Implementation of the Sensor behaviour\n  def sense(state) do\n    # Convert environment state to neural network inputs\n  end\nend\n\ndefmodule MyEnvironment.Actuator do\n  @behaviour Bardo.AgentManager.Actuator\n  \n  # Implementation of the Actuator behaviour\n  def act(outputs, state) do\n    # Convert neural network outputs to actions\n    # Return updated state\n  end\nend\n```\n\nThen create a morphology that defines the neural network structure:\n\n```elixir\ndefmodule MyEnvironment.Morphology do\n  @behaviour Bardo.Morphology\n  \n  # Implementation of the Morphology behaviour\n  def sensor_spec do\n    # Define sensor inputs\n  end\n  \n  def actuator_spec do\n    # Define actuator outputs\n  end\nend\n```","ref":"readme.html#custom-environments"},{"type":"extras","title":"Testing - Bardo","doc":"To run the tests:\n\n```bash\nmix test\n```","ref":"readme.html#testing"},{"type":"extras","title":"License - Bardo","doc":"Distributed under the Apache License 2.0. See `LICENSE` for more information.","ref":"readme.html#license"},{"type":"extras","title":"Acknowledgements - Bardo","doc":"Based on concepts from the [Handbook of Neuroevolution Through Erlang](http://www.amazon.com/Handbook-Neuroevolution-Through-Erlang-Gene/dp/1461444624) by Gene Sher.","ref":"readme.html#acknowledgements"},{"type":"extras","title":"Using Bardo as a Library","doc":"# Using Bardo as a Library\n\nThis tutorial provides a step-by-step guide to using Bardo as a library in your own Elixir applications.","ref":"library_tutorial.html"},{"type":"extras","title":"1. Setting Up Your Project - Using Bardo as a Library","doc":"First, add Bardo as a dependency in your `mix.exs` file:\n\n```elixir\ndef deps do\n  [\n    {:bardo, \"~> 0.1.0\"}\n  ]\nend\n```\n\nThen, fetch the dependencies:\n\n```shell\nmix deps.get\n```","ref":"library_tutorial.html#1-setting-up-your-project"},{"type":"extras","title":"2. Creating a Simple XOR Solver - Using Bardo as a Library","doc":"Let's create a simple application that uses Bardo to evolve a neural network that solves the XOR problem.","ref":"library_tutorial.html#2-creating-a-simple-xor-solver"},{"type":"extras","title":"2.1 Define Your Application - Using Bardo as a Library","doc":"Create a new module in your project:\n\n```elixir\ndefmodule MyApp.XorSolver do\n  @moduledoc \"\"\"\n  A module that uses Bardo to evolve a neural network solving the XOR problem.\n  \"\"\"\n  \n  @doc \"\"\"\n  Evolves a neural network to solve XOR and returns the champion.\n  \"\"\"\n  def run do\n    # Start Bardo subsystems\n    Bardo.start()\n    \n    # Create a unique experiment ID\n    experiment_id = \"xor_#{:os.system_time(:millisecond)}\"\n    \n    # Create the experiment\n    {:ok, _pid} = Bardo.ExperimentManager.new_experiment(experiment_id)\n    \n    # Configure the experiment\n    :ok = Bardo.ExperimentManager.configure(experiment_id, %{\n      population_size: 100,\n      max_generations: 50,\n      mutation_rate: 0.3,\n      fitness_goal: 3.9  # Stop when we reach this fitness (max is 4.0)\n    })\n    \n    # Start the evolution with our fitness function\n    :ok = Bardo.ExperimentManager.start_evaluation(experiment_id, &evaluate_xor/1)\n    \n    # Wait for the experiment to complete\n    {:ok, experiment} = wait_for_completion(experiment_id)\n    \n    # Get the best solution\n    {:ok, champion} = Bardo.ExperimentManager.get_best_solution(experiment_id)\n    \n    # Test the champion\n    test_champion(champion)\n    \n    # Return the champion genotype\n    champion\n  end\n  \n  @doc \"\"\"\n  Evaluates a genotype on the XOR problem.\n  \"\"\"\n  def evaluate_xor(genotype) do\n    # Convert genotype to neural network\n    nn = Bardo.AgentManager.Cortex.from_genotype(genotype)\n    \n    # The XOR inputs and expected outputs\n    test_cases = [\n      {[0.0, 0.0], 0.0},\n      {[0.0, 1.0], 1.0},\n      {[1.0, 0.0], 1.0},\n      {[1.0, 1.0], 0.0}\n    ]\n    \n    # Test each case and calculate fitness\n    fitness = Enum.reduce(test_cases, 0, fn {inputs, expected}, acc ->\n      # Get the actual output\n      result = Bardo.AgentManager.Cortex.activate(nn, inputs)\n      output = List.first(result)\n      \n      # Calculate fitness component (1.0 - error)\n      # The closer to expected, the higher the fitness\n      fitness_component = 1.0 - abs(expected - output)\n      \n      # Add to total fitness\n      acc + fitness_component\n    end)\n    \n    fitness\n  end\n  \n  @doc \"\"\"\n  Tests a champion genotype on the XOR problem.\n  \"\"\"\n  def test_champion(genotype) do\n    nn = Bardo.AgentManager.Cortex.from_genotype(genotype)\n    \n    test_cases = [\n      {[0.0, 0.0], 0.0},\n      {[0.0, 1.0], 1.0},\n      {[1.0, 0.0], 1.0},\n      {[1.0, 1.0], 0.0}\n    ]\n    \n    IO.puts(\"\\nTesting champion on XOR problem:\")\n    Enum.each(test_cases, fn {inputs, expected} ->\n      result = Bardo.AgentManager.Cortex.activate(nn, inputs)\n      output = List.first(result)\n      IO.puts(\"Input: #{inspect(inputs)} => Output: #{Float.round(output, 4)} (Expected: #{expected})\")\n    end)\n  end\n  \n  @doc \"\"\"\n  Waits for an experiment to complete.\n  \"\"\"\n  def wait_for_completion(experiment_id, max_attempts \\\\ 100) do\n    if max_attempts <= 0 do\n      {:error, :timeout}\n    else\n      case Bardo.ExperimentManager.status(experiment_id) do\n        {:complete, experiment} ->\n          {:ok, experiment}\n        \n        {:in_progress, _} ->\n          :timer.sleep(100)\n          wait_for_completion(experiment_id, max_attempts - 1)\n        \n        other ->\n          {:error, other}\n      end\n    end\n  end\nend\n```","ref":"library_tutorial.html#2-1-define-your-application"},{"type":"extras","title":"2.2 Running Your Application - Using Bardo as a Library","doc":"Now you can run your XOR solver from an IEx session:\n\n```elixir\niex> MyApp.XorSolver.run()\n```","ref":"library_tutorial.html#2-2-running-your-application"},{"type":"extras","title":"3. Creating a Custom Environment - Using Bardo as a Library","doc":"Let's create a more complex example where we define a custom environment with specific sensors and actuators.","ref":"library_tutorial.html#3-creating-a-custom-environment"},{"type":"extras","title":"3.1 Define a Simple Grid World Environment - Using Bardo as a Library","doc":"```elixir\ndefmodule MyApp.GridWorld do\n  @moduledoc \"\"\"\n  A simple 2D grid world where an agent must navigate to a goal.\n  \"\"\"\n  \n  defmodule Morphology do\n    @behaviour Bardo.Morphology\n    \n    @impl true\n    def sensor_spec do\n      [\n        %{\n          id: :position_sensor,\n          fanout: 2,\n          vl: :float,\n          cortex_id: nil,\n          name: \"Position Sensor\"\n        },\n        %{\n          id: :goal_sensor,\n          fanout: 2,\n          vl: :float,\n          cortex_id: nil,\n          name: \"Goal Sensor\"\n        }\n      ]\n    end\n    \n    @impl true\n    def actuator_spec do\n      [\n        %{\n          id: :movement_actuator,\n          fanin: 4,  # Up, Down, Left, Right\n          vl: :float,\n          cortex_id: nil,\n          name: \"Movement Actuator\"\n        }\n      ]\n    end\n    \n    @impl true\n    def hidden_layer_spec do\n      [\n        %{\n          id: :hidden,\n          size: 6,\n          af: :tanh,\n          input_layer_ids: [:position_sensor, :goal_sensor],\n          output_layer_ids: [:movement_actuator]\n        }\n      ]\n    end\n  end\n  \n  defmodule PositionSensor do\n    @behaviour Bardo.AgentManager.Sensor\n    \n    @impl true\n    def init(id, cortex_pid, vl, fanout) do\n      {:ok, %{\n        id: id,\n        sensor_type: :position,\n        fanout: fanout,\n        cortex_pid: cortex_pid,\n        vl: vl\n      }}\n    end\n    \n    @impl true\n    def sense(state, data) do\n      # Normalize position to range 0.0..1.0\n      {x, y} = data.position\n      {width, height} = data.grid_size\n      \n      signals = [\n        x / width,\n        y / height\n      ]\n      \n      {:ok, signals, state}\n    end\n  end\n  \n  defmodule GoalSensor do\n    @behaviour Bardo.AgentManager.Sensor\n    \n    @impl true\n    def init(id, cortex_pid, vl, fanout) do\n      {:ok, %{\n        id: id,\n        sensor_type: :goal,\n        fanout: fanout,\n        cortex_pid: cortex_pid,\n        vl: vl\n      }}\n    end\n    \n    @impl true\n    def sense(state, data) do\n      # Calculate direction to goal\n      {x, y} = data.position\n      {goal_x, goal_y} = data.goal\n      \n      # Direction vector to goal\n      dx = (goal_x - x) / data.grid_size |> element(0)\n      dy = (goal_y - y) / data.grid_size |> element(1)\n      \n      signals = [dx, dy]\n      \n      {:ok, signals, state}\n    end\n  end\n  \n  defmodule MovementActuator do\n    @behaviour Bardo.AgentManager.Actuator\n    \n    @impl true\n    def init(id, cortex_pid, vl, fanin) do\n      {:ok, %{\n        id: id,\n        actuator_type: :movement,\n        fanin: fanin,\n        cortex_pid: cortex_pid,\n        vl: vl\n      }}\n    end\n    \n    @impl true\n    def actuate(state, {_, signals, _, _, _, _, _}) do\n      # Get movement direction from neural network outputs\n      [up, down, left, right] = signals\n      \n      # Choose the strongest output\n      direction = Enum.zip([:up, :down, :left, :right], [up, down, left, right])\n                  |> Enum.max_by(fn {_, value} -> value end)\n                  |> elem(0)\n      \n      {:ok, direction, state}\n    end\n  end\n  \n  @doc \"\"\"\n  Runs the grid world simulation.\n  \"\"\"\n  def run do\n    # Start Bardo subsystems\n    Bardo.start()\n    \n    # Create a unique experiment ID\n    experiment_id = \"grid_world_#{:os.system_time(:millisecond)}\"\n    \n    # Create the experiment\n    {:ok, _pid} = Bardo.ExperimentManager.new_experiment(experiment_id)\n    \n    # Configure the experiment\n    :ok = Bardo.ExperimentManager.configure(experiment_id, %{\n      population_size: 100,\n      max_generations: 50,\n      mutation_rate: 0.3,\n      fitness_goal: 0.95  # Stop when we reach this fitness (max is 1.0)\n    })\n    \n    # Start the evolution with our fitness function\n    :ok = Bardo.ExperimentManager.start_evaluation(experiment_id, &evaluate_navigation/1)\n    \n    # Wait for the experiment to complete\n    {:ok, _} = wait_for_completion(experiment_id)\n    \n    # Get the best solution\n    {:ok, champion} = Bardo.ExperimentManager.get_best_solution(experiment_id)\n    \n    # Test the champion\n    test_champion(champion)\n    \n    # Return the champion\n    champion\n  end\n  \n  @doc \"\"\"\n  Evaluates a genotype on the grid world navigation task.\n  \"\"\"\n  def evaluate_navigation(genotype) do\n    # World parameters\n    grid_size = {10, 10}\n    goal = {9, 9}\n    max_steps = 50\n    \n    # Convert genotype to neural network\n    nn = Bardo.AgentManager.Cortex.from_genotype(genotype, __MODULE__.Morphology)\n    \n    # Add sensors and actuators\n    nn = Bardo.AgentManager.Cortex.add_sensor(nn, __MODULE__.PositionSensor)\n    nn = Bardo.AgentManager.Cortex.add_sensor(nn, __MODULE__.GoalSensor)\n    nn = Bardo.AgentManager.Cortex.add_actuator(nn, __MODULE__.MovementActuator)\n    \n    # Run simulation\n    simulate_agent(nn, {0, 0}, goal, grid_size, max_steps)\n  end\n  \n  @doc \"\"\"\n  Simulates an agent navigating the grid world.\n  \"\"\"\n  def simulate_agent(nn, position, goal, grid_size, steps_left, path \\\\ []) do\n    if position == goal do\n      # Reached goal, calculate fitness based on path length\n      path_length = length(path)\n      optimal_length = abs(elem(goal, 0) - 0) + abs(elem(goal, 1) - 0)\n      efficiency = optimal_length / path_length\n      \n      # Return fitness (1.0 for optimal path)\n      1.0 * efficiency\n    else\n      if steps_left <= 0 do\n        # Out of steps, calculate fitness based on distance to goal\n        {x, y} = position\n        {goal_x, goal_y} = goal\n        distance = :math.sqrt(:math.pow(goal_x - x, 2) + :math.pow(goal_y - y, 2))\n        max_distance = :math.sqrt(:math.pow(goal_x, 2) + :math.pow(goal_y, 2))\n        \n        # Return fitness (closer to goal is better)\n        1.0 - (distance / max_distance)\n      else\n        # Sense environment\n        sensor_data = %{\n          position: position,\n          goal: goal,\n          grid_size: grid_size\n        }\n        \n        # Get action from neural network\n        action = activate_agent(nn, sensor_data)\n        \n        # Update position based on action\n        new_position = update_position(position, action, grid_size)\n        \n        # Continue simulation\n        simulate_agent(nn, new_position, goal, grid_size, steps_left - 1, [new_position | path])\n      end\n    end\n  end\n  \n  @doc \"\"\"\n  Activates the agent's neural network to get an action.\n  \"\"\"\n  def activate_agent(nn, sensor_data) do\n    # Prepare input for position sensor\n    position_input = %{\n      position: sensor_data.position,\n      grid_size: sensor_data.grid_size\n    }\n    \n    # Prepare input for goal sensor\n    goal_input = %{\n      position: sensor_data.position,\n      goal: sensor_data.goal,\n      grid_size: sensor_data.grid_size\n    }\n    \n    # Activate neural network\n    Bardo.AgentManager.Cortex.activate(nn, %{\n      position_sensor: position_input,\n      goal_sensor: goal_input\n    })\n  end\n  \n  @doc \"\"\"\n  Updates the agent's position based on an action.\n  \"\"\"\n  def update_position({x, y}, action, {width, height}) do\n    case action do\n      :up -> {x, max(0, y - 1)}\n      :down -> {x, min(height - 1, y + 1)}\n      :left -> {max(0, x - 1), y}\n      :right -> {min(width - 1, x + 1), y}\n    end\n  end\n  \n  @doc \"\"\"\n  Tests a champion genotype on the grid world navigation task.\n  \"\"\"\n  def test_champion(genotype) do\n    # World parameters\n    grid_size = {10, 10}\n    goal = {9, 9}\n    max_steps = 50\n    \n    # Convert genotype to neural network\n    nn = Bardo.AgentManager.Cortex.from_genotype(genotype, __MODULE__.Morphology)\n    \n    # Add sensors and actuators\n    nn = Bardo.AgentManager.Cortex.add_sensor(nn, __MODULE__.PositionSensor)\n    nn = Bardo.AgentManager.Cortex.add_sensor(nn, __MODULE__.GoalSensor)\n    nn = Bardo.AgentManager.Cortex.add_actuator(nn, __MODULE__.MovementActuator)\n    \n    # Run simulation with visualization\n    visualize_agent(nn, {0, 0}, goal, grid_size, max_steps)\n  end\n  \n  @doc \"\"\"\n  Visualizes an agent navigating the grid world.\n  \"\"\"\n  def visualize_agent(nn, position, goal, grid_size, steps_left, path \\\\ []) do\n    # Print grid\n    IO.puts(\"\\nGrid World Navigation:\")\n    print_grid(position, goal, grid_size)\n    \n    if position == goal do\n      IO.puts(\"\\nGoal reached in #{length(path)} steps!\")\n      path\n    else\n      if steps_left <= 0 do\n        IO.puts(\"\\nFailed to reach goal within step limit.\")\n        path\n      else\n        # Sense environment\n        sensor_data = %{\n          position: position,\n          goal: goal,\n          grid_size: grid_size\n        }\n        \n        # Get action from neural network\n        action = activate_agent(nn, sensor_data)\n        \n        # Update position based on action\n        new_position = update_position(position, action, grid_size)\n        IO.puts(\"Action: #{action}\")\n        \n        # Continue simulation\n        :timer.sleep(200)  # Slow down visualization\n        visualize_agent(nn, new_position, goal, grid_size, steps_left - 1, [new_position | path])\n      end\n    end\n  end\n  \n  @doc \"\"\"\n  Prints the grid world.\n  \"\"\"\n  def print_grid(agent_pos, goal_pos, {width, height}) do\n    for y <- 0..(height - 1) do\n      line = for x <- 0..(width - 1) do\n        cond do\n          {x, y} == agent_pos -> \"A\"\n          {x, y} == goal_pos -> \"G\"\n          true -> \".\"\n        end\n      end\n      IO.puts(Enum.join(line, \" \"))\n    end\n  end\n  \n  @doc \"\"\"\n  Waits for an experiment to complete.\n  \"\"\"\n  def wait_for_completion(experiment_id, max_attempts \\\\ 100) do\n    if max_attempts <= 0 do\n      {:error, :timeout}\n    else\n      case Bardo.ExperimentManager.status(experiment_id) do\n        {:complete, experiment} ->\n          {:ok, experiment}\n        \n        {:in_progress, _} ->\n          :timer.sleep(100)\n          wait_for_completion(experiment_id, max_attempts - 1)\n        \n        other ->\n          {:error, other}\n      end\n    end\n  end\nend\n```","ref":"library_tutorial.html#3-1-define-a-simple-grid-world-environment"},{"type":"extras","title":"3.2 Running the Grid World Example - Using Bardo as a Library","doc":"Run your grid world navigation example:\n\n```elixir\niex> MyApp.GridWorld.run()\n```","ref":"library_tutorial.html#3-2-running-the-grid-world-example"},{"type":"extras","title":"4. Saving and Loading Models - Using Bardo as a Library","doc":"Once you've evolved a successful neural network, you'll want to save it for later use.\n\n```elixir\ndefmodule MyApp.ModelManager do\n  @moduledoc \"\"\"\n  Utilities for saving and loading evolved models.\n  \"\"\"\n  \n  @doc \"\"\"\n  Saves a champion genotype to file.\n  \"\"\"\n  def save_champion(genotype, filename) do\n    Bardo.Persistence.save(genotype, filename)\n  end\n  \n  @doc \"\"\"\n  Loads a champion genotype from file.\n  \"\"\"\n  def load_champion(filename) do\n    Bardo.Persistence.load(filename)\n  end\n  \n  @doc \"\"\"\n  Creates a neural network from a genotype file.\n  \"\"\"\n  def create_network_from_file(filename, morphology \\\\ nil) do\n    case load_champion(filename) do\n      {:ok, genotype} ->\n        nn = if morphology do\n          Bardo.AgentManager.Cortex.from_genotype(genotype, morphology)\n        else\n          Bardo.AgentManager.Cortex.from_genotype(genotype)\n        end\n        \n        {:ok, nn}\n        \n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n  \n  @doc \"\"\"\n  Runs inference with a saved model.\n  \"\"\"\n  def run_inference(filename, input, morphology \\\\ nil) do\n    case create_network_from_file(filename, morphology) do\n      {:ok, nn} ->\n        result = Bardo.AgentManager.Cortex.activate(nn, input)\n        {:ok, result}\n        \n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\nend\n```","ref":"library_tutorial.html#4-saving-and-loading-models"},{"type":"extras","title":"5. Integration with Phoenix - Using Bardo as a Library","doc":"If you're building a web application with Phoenix, you can use Bardo for tasks like recommendation systems or intelligent agents.\n\nHere's a simple example of a Phoenix controller that uses a pre-trained Bardo model:\n\n```elixir\ndefmodule MyAppWeb.RecommendationController do\n  use MyAppWeb, :controller\n  \n  @model_path \"priv/models/recommendation_model.gen\"\n  \n  def index(conn, %{\"user_id\" => user_id}) do\n    # Get user features\n    user = MyApp.Accounts.get_user!(user_id)\n    user_features = extract_user_features(user)\n    \n    # Get recommendations using Bardo model\n    {:ok, recommendations} = get_recommendations(user_features)\n    \n    # Render recommendations\n    render(conn, \"index.html\", recommendations: recommendations)\n  end\n  \n  defp extract_user_features(user) do\n    # Convert user data to neural network input\n    # ...\n    features\n  end\n  \n  defp get_recommendations(user_features) do\n    case MyApp.ModelManager.run_inference(@model_path, user_features) do\n      {:ok, output} ->\n        # Convert neural network output to product recommendations\n        recommendations = convert_to_recommendations(output)\n        {:ok, recommendations}\n        \n      {:error, reason} ->\n        {:error, reason}\n    end\n  end\n  \n  defp convert_to_recommendations(neural_output) do\n    # Convert neural network output to product IDs\n    # ...\n    recommendations\n  end\nend\n```","ref":"library_tutorial.html#5-integration-with-phoenix"},{"type":"extras","title":"6. Best Practices - Using Bardo as a Library","doc":"When using Bardo in production applications, follow these best practices:\n\n1. **Pre-train your models**: Don't run evolution in production. Pre-train your models and deploy only the inference code.\n\n2. **Error handling**: Always handle errors from Bardo functions, especially when loading models or running inference.\n\n3. **Input validation**: Validate and normalize inputs before passing them to neural networks.\n\n4. **Resource management**: Be mindful of memory usage, especially with large neural networks.\n\n5. **Monitoring**: Add monitoring to track model performance and inference time in production.\n\n6. **Fallbacks**: Have fallback logic when neural networks fail or produce unexpected results.\n\n7. **Version control**: Keep track of your model versions and their corresponding training data.","ref":"library_tutorial.html#6-best-practices"},{"type":"extras","title":"7. Advanced Topics - Using Bardo as a Library","doc":"For more advanced usage of Bardo, consult the following resources:\n\n- [API Reference](api_reference.md): Comprehensive API documentation\n- [Advanced Features](advanced.md): Information on advanced features like substrate encoding\n- [Examples](examples.md): More example implementations","ref":"library_tutorial.html#7-advanced-topics"},{"type":"extras","title":"Bardo Quickstart Guide","doc":"# Bardo Quickstart Guide\n\nThis guide will help you get started with Bardo for your neuroevolution tasks. We'll walk through basic setup, running included examples, and creating a simple XOR experiment.","ref":"quickstart.html"},{"type":"extras","title":"Installation - Bardo Quickstart Guide","doc":"Add Bardo to your mix.exs dependencies:\n\n```elixir\ndef deps do\n  [\n    {:bardo, \"~> 0.1.0\"}\n  ]\nend\n```\n\nThen fetch and compile:\n\n```bash\nmix deps.get\nmix compile\n```","ref":"quickstart.html#installation"},{"type":"extras","title":"Your First Experiment: XOR - Bardo Quickstart Guide","doc":"Let's create a simple experiment to evolve a neural network that can solve the XOR problem.","ref":"quickstart.html#your-first-experiment-xor"},{"type":"extras","title":"1. Create a new project - Bardo Quickstart Guide","doc":"```bash\nmix new xor_example\ncd xor_example\n```","ref":"quickstart.html#1-create-a-new-project"},{"type":"extras","title":"2. Add Bardo to dependencies - Bardo Quickstart Guide","doc":"Add Bardo to `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:bardo, \"~> 0.1.0\"}\n  ]\nend\n```","ref":"quickstart.html#2-add-bardo-to-dependencies"},{"type":"extras","title":"3. Create an XOR experiment module - Bardo Quickstart Guide","doc":"Create a file `lib/xor_experiment.ex`:\n\n```elixir\ndefmodule XorExperiment do\n  @moduledoc \"\"\"\n  A simple example demonstrating how to evolve a neural network to solve the XOR problem.\n  \"\"\"\n  \n  alias Bardo.ExperimentManager\n  alias Bardo.AgentManager.Cortex\n  \n  def run do\n    # Create a new experiment\n    experiment_id = \"xor_experiment_#{:os.system_time(:millisecond)}\"\n    \n    # Configure the experiment\n    config = %{\n      # Population settings\n      population_size: 100,\n      max_generations: 100,\n      species_distance_threshold: 0.5,\n      \n      # Neural network settings\n      activation_function: :sigmoid,\n      weight_range: {-1.0, 1.0},\n      bias_range: {-1.0, 1.0},\n      \n      # Mutation settings\n      mutation_rate: 0.3,\n      add_neuron_probability: 0.1,\n      add_link_probability: 0.2,\n      \n      # Evaluation settings\n      fitness_goal: 3.9 # Perfect solution would be 4.0\n    }\n    \n    IO.puts(\"Starting XOR experiment: #{experiment_id}\")\n    \n    # Create and configure the experiment\n    {:ok, _} = ExperimentManager.new_experiment(experiment_id)\n    :ok = ExperimentManager.configure(experiment_id, config)\n    \n    # Start the experiment with XOR fitness function\n    :ok = ExperimentManager.start_evaluation(experiment_id, &xor_fitness/1)\n    \n    # Wait for completion\n    monitor_progress(experiment_id)\n    \n    # Test the best solution\n    test_best_solution(experiment_id)\n  end\n  \n  # Fitness function for XOR\n  defp xor_fitness(genotype) do\n    # Convert genotype to neural network\n    nn = Cortex.from_genotype(genotype)\n    \n    # Define XOR test cases\n    test_cases = [\n      {[0.0, 0.0], [0.0]},\n      {[0.0, 1.0], [1.0]},\n      {[1.0, 0.0], [1.0]},\n      {[1.0, 1.0], [0.0]}\n    ]\n    \n    # Calculate error for each test case\n    total_error = Enum.reduce(test_cases, 0.0, fn {inputs, expected}, acc ->\n      # Run the neural network\n      outputs = Cortex.activate(nn, inputs)\n      \n      # Calculate error (difference between expected and actual output)\n      error = Enum.zip(outputs, expected)\n              |> Enum.map(fn {output, target} -> abs(output - target) end)\n              |> Enum.sum()\n      \n      # Add to total error\n      acc + error\n    end)\n    \n    # Convert error to fitness (lower error = higher fitness)\n    4.0 - total_error\n  end\n  \n  # Monitor experiment progress\n  defp monitor_progress(experiment_id) do\n    # Poll for status until complete\n    case ExperimentManager.status(experiment_id) do\n      {:completed, _} ->\n        IO.puts(\"Experiment completed!\")\n      \n      {:in_progress, %{generation: gen, best_fitness: fitness}} ->\n        IO.puts(\"Generation: #{gen}, Best Fitness: #{fitness}\")\n        :timer.sleep(500)\n        monitor_progress(experiment_id)\n      \n      {:error, reason} ->\n        IO.puts(\"Error: #{inspect(reason)}\")\n    end\n  end\n  \n  # Test the best solution against XOR test cases\n  defp test_best_solution(experiment_id) do\n    # Get best genotype\n    {:ok, best_genotype} = ExperimentManager.get_best_solution(experiment_id)\n    \n    # Convert to neural network\n    nn = Cortex.from_genotype(best_genotype)\n    \n    # Define test cases\n    test_cases = [\n      {[0.0, 0.0], [0.0]},\n      {[0.0, 1.0], [1.0]},\n      {[1.0, 0.0], [1.0]},\n      {[1.0, 1.0], [0.0]}\n    ]\n    \n    IO.puts(\"\\nTesting best solution:\")\n    \n    # Test each case\n    Enum.each(test_cases, fn {inputs, expected} ->\n      outputs = Cortex.activate(nn, inputs)\n      \n      input_str = inputs |> Enum.map(&Float.to_string/1) |> Enum.join(\", \")\n      output_str = outputs |> Enum.map(&Float.to_string/1) |> Enum.join(\", \")\n      expected_str = expected |> Enum.map(&Float.to_string/1) |> Enum.join(\", \")\n      \n      IO.puts(\"Input: [#{input_str}] => Output: [#{output_str}] (Expected: [#{expected_str}])\")\n    end)\n    \n    # Display network topology\n    IO.puts(\"\\nNeural Network Structure:\")\n    IO.inspect(nn, label: \"Neural Network\")\n  end\nend\n```","ref":"quickstart.html#3-create-an-xor-experiment-module"},{"type":"extras","title":"4. Run the experiment - Bardo Quickstart Guide","doc":"```elixir\n# In IEx\niex -S mix\niex> XorExperiment.run()\n```\n\nYou should see output showing the progress of the evolutionary process, and finally the performance of the best neural network on the XOR problem.","ref":"quickstart.html#4-run-the-experiment"},{"type":"extras","title":"Running Built-in Examples - Bardo Quickstart Guide","doc":"Bardo comes with several built-in examples you can run:","ref":"quickstart.html#running-built-in-examples"},{"type":"extras","title":"Double Pole Balancing - Bardo Quickstart Guide","doc":"```elixir\n# Start IEx\niex -S mix\n\n# Run double pole balancing without damping\niex> Bardo.Examples.Benchmarks.Dpb.run_without_damping()\n\n# Run double pole balancing with damping\niex> Bardo.Examples.Benchmarks.Dpb.run_with_damping()\n```","ref":"quickstart.html#double-pole-balancing"},{"type":"extras","title":"Flatland Predator-Prey Simulation - Bardo Quickstart Guide","doc":"```elixir\n# Start IEx\niex -S mix\n\n# Run the flatland simulation\niex> Bardo.Examples.Applications.Flatland.run()\n```","ref":"quickstart.html#flatland-predator-prey-simulation"},{"type":"extras","title":"Next Steps - Bardo Quickstart Guide","doc":"Now that you've run your first experiment, consider:\n\n1. Exploring the [API documentation](api_reference.md) for details on all available functions\n2. Checking out the [advanced guide](advanced.md) for more complex usage patterns\n3. Looking at the source code of the included examples to understand more complex applications\n\nFor more information, refer to the [complete documentation](https://hexdocs.pm/bardo).","ref":"quickstart.html#next-steps"},{"type":"extras","title":"Bardo API Reference","doc":"# Bardo API Reference\n\nThis document provides comprehensive details on the main public interfaces of Bardo, a neuroevolution library for Elixir. Use this as your primary reference when integrating Bardo into your own applications.","ref":"api_reference.html"},{"type":"extras","title":"Getting Started - Bardo API Reference","doc":"To use Bardo in your project, add it to your mix.exs dependencies:\n\n```elixir\ndef deps do\n  [\n    {:bardo, \"~> 0.1.0\"}\n  ]\nend\n```\n\nThen run:\n\n```shell\nmix deps.get\n```","ref":"api_reference.html#getting-started"},{"type":"extras","title":"Bardo - Bardo API Reference","doc":"The main module provides basic library information and startup functions.\n\n```elixir\n# Start all required Bardo processes\nBardo.start()\n\n# Returns the current library version\nBardo.version()\n```","ref":"api_reference.html#bardo"},{"type":"extras","title":"ExperimentManager - Bardo API Reference","doc":"The `Bardo.ExperimentManager` module handles the creation and management of evolutionary experiments.","ref":"api_reference.html#experimentmanager"},{"type":"extras","title":"Creating and Configuring Experiments - Bardo API Reference","doc":"```elixir\n# Create a new experiment\n{:ok, _} = Bardo.ExperimentManager.new_experiment(experiment_id)\n\n# Configure an experiment with specific parameters\n:ok = Bardo.ExperimentManager.configure(experiment_id, %{\n  population_size: 100,\n  max_generations: 50,\n  mutation_rate: 0.3\n})\n\n# Start evaluation using a fitness function\n:ok = Bardo.ExperimentManager.start_evaluation(experiment_id, &my_fitness_function/1)\n\n# Get the current status of an experiment\n{:in_progress, stats} = Bardo.ExperimentManager.status(experiment_id)\n\n# Get the best solution from an experiment\n{:ok, best_genotype} = Bardo.ExperimentManager.get_best_solution(experiment_id)\n\n# Stop an experiment\n:ok = Bardo.ExperimentManager.stop(experiment_id)\n```","ref":"api_reference.html#creating-and-configuring-experiments"},{"type":"extras","title":"Common Configuration Parameters - Bardo API Reference","doc":"| Parameter | Type | Description | Default |\n|-----------|------|-------------|---------|\n| `population_size` | integer | Number of agents in the population | 50 |\n| `max_generations` | integer | Maximum number of generations | 100 |\n| `mutation_rate` | float | Probability of mutation for each gene | 0.3 |\n| `add_neuron_probability` | float | Probability of adding a neuron | 0.1 |\n| `add_link_probability` | float | Probability of adding a link | 0.2 |\n| `weight_range` | {float, float} | Min/max values for weight initialization | {-1.0, 1.0} |\n| `fitness_goal` | float | Target fitness to end evolution | nil (run to max_generations) |\n| `species_distance_threshold` | float | Threshold for speciation | 0.5 |\n| `activation_function` | atom | Default activation function | :sigmoid |\n| `evaluation_method` | atom | :generational or :steady_state | :generational |","ref":"api_reference.html#common-configuration-parameters"},{"type":"extras","title":"AgentManager - Bardo API Reference","doc":"The `Bardo.AgentManager` module manages neural network agents.","ref":"api_reference.html#agentmanager"},{"type":"extras","title":"Creating and Working with Neural Networks - Bardo API Reference","doc":"```elixir\n# Create a neural network from a genotype\nnn = Bardo.AgentManager.Cortex.from_genotype(genotype)\n\n# Activate a neural network with inputs\noutput = Bardo.AgentManager.Cortex.activate(nn, inputs)\n\n# Add a sensor to a neural network\nnn = Bardo.AgentManager.Cortex.add_sensor(nn, sensor_module, params)\n\n# Add an actuator to a neural network\nnn = Bardo.AgentManager.Cortex.add_actuator(nn, actuator_module, params)\n```","ref":"api_reference.html#creating-and-working-with-neural-networks"},{"type":"extras","title":"Neuron Management - Bardo API Reference","doc":"```elixir\n# Add a neuron to a neural network\nnn = Bardo.AgentManager.Cortex.add_neuron(nn, :hidden, %{\n  activation_function: :sigmoid,\n  bias: 0.0\n})\n\n# Connect neurons\nnn = Bardo.AgentManager.Cortex.connect_neurons(nn, source_id, target_id, weight)\n\n# Set neuron parameters\nnn = Bardo.AgentManager.Cortex.set_neuron_params(nn, neuron_id, %{\n  bias: 1.0,\n  activation_function: :tanh\n})\n```","ref":"api_reference.html#neuron-management"},{"type":"extras","title":"PopulationManager - Bardo API Reference","doc":"The `Bardo.PopulationManager` module manages populations of evolving agents.","ref":"api_reference.html#populationmanager"},{"type":"extras","title":"Genotype Management - Bardo API Reference","doc":"```elixir\n# Create a new genotype\ngenotype = Bardo.PopulationManager.Genotype.new()\n\n# Add a neuron to a genotype\ngenotype = Bardo.PopulationManager.Genotype.add_neuron(genotype, :hidden)\n\n# Add a connection to a genotype\ngenotype = Bardo.PopulationManager.Genotype.add_connection(\n  genotype, \n  source_id, \n  target_id, \n  weight\n)\n```","ref":"api_reference.html#genotype-management"},{"type":"extras","title":"Mutation Operations - Bardo API Reference","doc":"```elixir\n# Mutate a genotype\nmutated_genotype = Bardo.PopulationManager.GenomeMutator.mutate(genotype, %{\n  add_neuron_probability: 0.1,\n  add_link_probability: 0.2,\n  mutate_weights_probability: 0.8\n})\n\n# Apply specific mutation\ngenotype = Bardo.PopulationManager.GenomeMutator.mutate_weights(genotype)\ngenotype = Bardo.PopulationManager.GenomeMutator.add_neuron(genotype)\ngenotype = Bardo.PopulationManager.GenomeMutator.add_link(genotype)\n```","ref":"api_reference.html#mutation-operations"},{"type":"extras","title":"Selection Algorithms - Bardo API Reference","doc":"```elixir\n# Select agents for reproduction\nselected = Bardo.PopulationManager.SelectionAlgorithm.select(\n  population, \n  selection_method, \n  selection_params\n)\n```","ref":"api_reference.html#selection-algorithms"},{"type":"extras","title":"ScapeManager - Bardo API Reference","doc":"The `Bardo.ScapeManager` module manages environments that agents interact with.\n\n```elixir\n# Create a new scape\n{:ok, scape_id} = Bardo.ScapeManager.new_scape(scape_type, params)\n\n# Enter an agent into a scape\n:ok = Bardo.ScapeManager.enter(scape_id, agent_id, params)\n\n# Sense from the environment\n{:ok, sensory_data} = Bardo.ScapeManager.sense(scape_id, agent_id, sensor_params)\n\n# Act on the environment\n:ok = Bardo.ScapeManager.actuate(scape_id, agent_id, actuator_params)\n\n# Leave a scape\n:ok = Bardo.ScapeManager.leave(scape_id, agent_id)\n```","ref":"api_reference.html#scapemanager"},{"type":"extras","title":"Creating Custom Components - Bardo API Reference","doc":"","ref":"api_reference.html#creating-custom-components"},{"type":"extras","title":"Custom Sensor - Bardo API Reference","doc":"```elixir\ndefmodule MySensor do\n  @behaviour Bardo.AgentManager.Sensor\n  \n  @impl true\n  def init(params) do\n    # Initialize sensor state\n    {:ok, params}\n  end\n  \n  @impl true\n  def sense(state, environment) do\n    # Process environment to produce sensory signals\n    sensory_data = process_environment(environment)\n    \n    # Return sensory data and updated state\n    {:ok, sensory_data, state}\n  end\n  \n  defp process_environment(environment) do\n    # Custom logic to extract sensory information\n    # ...\n    [0.5, 0.2, 0.7]  # Example return value\n  end\nend\n```","ref":"api_reference.html#custom-sensor"},{"type":"extras","title":"Custom Actuator - Bardo API Reference","doc":"```elixir\ndefmodule MyActuator do\n  @behaviour Bardo.AgentManager.Actuator\n  \n  @impl true\n  def init(params) do\n    # Initialize actuator state\n    {:ok, params}\n  end\n  \n  @impl true\n  def actuate(state, environment, output_vector) do\n    # Process neural network output to affect environment\n    new_environment = apply_outputs(environment, output_vector)\n    \n    # Return updated environment and state\n    {:ok, new_environment, state}\n  end\n  \n  defp apply_outputs(environment, output_vector) do\n    # Custom logic to apply neural outputs to environment\n    # ...\n    updated_environment\n  end\nend\n```","ref":"api_reference.html#custom-actuator"},{"type":"extras","title":"Custom Fitness Function - Bardo API Reference","doc":"```elixir\ndef my_fitness_function(genotype) do\n  # Convert genotype to neural network\n  nn = Bardo.AgentManager.Cortex.from_genotype(genotype)\n  \n  # Evaluate performance on some task\n  performance = evaluate_performance(nn)\n  \n  # Return fitness score (higher is better)\n  performance\nend\n\ndefp evaluate_performance(nn) do\n  # Custom evaluation logic\n  # ...\n  fitness_score\nend\n```","ref":"api_reference.html#custom-fitness-function"},{"type":"extras","title":"Substrate Encoding - Bardo API Reference","doc":"Bardo supports several types of substrate encoding for neural networks:\n\n```elixir\n# Configure hypercube substrate encoding\nBardo.ExperimentManager.configure(experiment_id, %{\n  substrate: %{\n    type: :hypercube,\n    dimensions: 3,\n    resolution: 5\n  }\n})\n\n# Configure hyperplane substrate encoding\nBardo.ExperimentManager.configure(experiment_id, %{\n  substrate: %{\n    type: :hyperplane,\n    input_dimensions: 2,\n    output_dimensions: 1,\n    hidden_layers: 1\n  }\n})\n```","ref":"api_reference.html#substrate-encoding"},{"type":"extras","title":"Utility Functions - Bardo API Reference","doc":"```elixir\n# Save a genotype to file\nBardo.Utils.save_genotype(genotype, \"models/best_genotype.gen\")\n\n# Load a genotype from file\nloaded_genotype = Bardo.Utils.load_genotype(\"models/best_genotype.gen\")\n\n# Analyze neural network complexity\nstats = Bardo.Utils.analyze_network(nn)\n\n# Calculate compatibility distance between genotypes\ndistance = Bardo.PopulationManager.SpecieIdentifier.compatibility_distance(\n  genotype1, \n  genotype2\n)\n```","ref":"api_reference.html#utility-functions"},{"type":"extras","title":"Event Handling - Bardo API Reference","doc":"```elixir\n# Subscribe to experiment events\nBardo.EventManager.subscribe(experiment_id, :generation_complete)\n\n# Handle events\ndef handle_info({:generation_complete, experiment_id, stats}, state) do\n  # Process generation statistics\n  # ...\n  {:noreply, state}\nend\n```","ref":"api_reference.html#event-handling"},{"type":"extras","title":"Visualization - Bardo API Reference","doc":"```elixir\n# Generate visualization data\nviz_data = Bardo.Visualization.generate_network_visualization(nn)\n\n# Plot fitness over generations\nBardo.Visualization.plot_fitness(experiment_id)\n\n# Plot species over generations\nBardo.Visualization.plot_species(experiment_id)\n\n# Plot complexity over generations\nBardo.Visualization.plot_complexity(experiment_id)\n```","ref":"api_reference.html#visualization"},{"type":"extras","title":"Bardo Examples","doc":"# Bardo Examples\n\nThis document provides detailed information on the example applications and benchmarks included with Bardo.","ref":"examples.html"},{"type":"extras","title":"Benchmarks - Bardo Examples","doc":"","ref":"examples.html#benchmarks"},{"type":"extras","title":"Double Pole Balancing (DPB) - Bardo Examples","doc":"A classic control problem where a neural network learns to balance two poles of different lengths on a cart.\n\n#### Overview\n\nIn this problem, we try to balance two poles of different lengths simultaneously on a cart. The cart can move left and right along a track, and the neural network must apply the correct forces to keep both poles balanced.\n\n- One pole is 0.1 meters long\n- The other pole is 1.0 meter long \n- The closer the lengths of the two poles are, the more difficult the problem becomes\n\n#### Running the Example\n\n```elixir\n# Run with default settings\nBardo.Examples.Benchmarks.Dpb.run()\n\n# Run with custom settings\nBardo.Examples.Benchmarks.Dpb.run(%{\n  population_size: 100,\n  max_generations: 200,\n  use_damping: true  # Enables damping to discourage rapid cart movements\n})\n```\n\n#### What to Expect\n\n- With standard settings, a solution typically emerges after ~2,300 evaluations\n- The neural network learns to make small, precise movements to balance both poles\n- You can observe the evolution progress through the console output or visualizations\n\n#### Implementation Details\n\nThe DPB example provides two variants:\n- Without damping: Allows fast cart movements as long as poles stay balanced\n- With damping: Penalizes high velocity and rapid changes, encouraging smoother control\n\nThe neural network receives these inputs:\n- Cart position and velocity \n- First pole angle and angular velocity\n- Second pole angle and angular velocity\n\nIt produces a single output:\n- Force value (in Newtons) to apply to the cart, saturated at 10N magnitude","ref":"examples.html#double-pole-balancing-dpb"},{"type":"extras","title":"Applications - Bardo Examples","doc":"","ref":"examples.html#applications"},{"type":"extras","title":"Flatland (Predator vs Prey Simulation) - Bardo Examples","doc":"A more complex simulation where predator and prey agents co-evolve in a 2D world.\n\n#### Overview\n\nFlatland creates a simulated 2D environment where:\n- Predator agents (red) try to catch and consume prey agents (blue)\n- Prey agents try to survive by avoiding predators and consuming plants (green)\n- Both species evolve more sophisticated strategies over time\n\nThis example demonstrates:\n- Co-evolution of competing species\n- Complex emergent behaviors\n- Steady-state evolution (ongoing birth and death rather than distinct generations)\n\n#### Running the Example\n\n```elixir\n# Run with default settings\nBardo.Examples.Applications.Flatland.run()\n\n# Run with custom settings\nBardo.Examples.Applications.Flatland.run(%{\n  predator_population_size: 10,\n  prey_population_size: 20,\n  plant_quantity: 40,\n  max_evaluations: 10000\n})\n```\n\n#### What to Expect\n\nYou'll observe fascinating co-evolutionary dynamics:\n- Initially random behavior becomes increasingly strategic\n- Predators may evolve trapping or ambush tactics\n- Prey develop evasion strategies and efficient foraging\n- The population dynamics reach different equilibria depending on which species evolves effective strategies first\n\n#### Implementation Details\n\nEach agent has:\n- Distance scanners (sensors that detect objects at different angles)\n- Color scanners (sensors that identify object types by color)\n- Two-wheel drive actuators (for movement control)\n\nThe evolutionary progress can be tracked through:\n- Average fitness over time\n- Neural network complexity\n- Population diversity\n- Population turnover (death rates)","ref":"examples.html#flatland-predator-vs-prey-simulation"},{"type":"extras","title":"Custom Example Development - Bardo Examples","doc":"To create your own example using Bardo:\n\n1. Define your environment and interaction rules\n2. Create custom sensors and actuators\n3. Set up the evolution parameters\n4. Configure fitness functions\n\nSee the [advanced guide](advanced.md) for detailed instructions on developing custom examples.","ref":"examples.html#custom-example-development"},{"type":"extras","title":"Extending Bardo","doc":"# Extending Bardo\n\nThis guide shows how to extend Bardo with custom components for your specific needs.","ref":"extending.html"},{"type":"extras","title":"Custom Sensors - Extending Bardo","doc":"Sensors are the interface between the environment and your neural network's inputs. They convert external data into neural signals.","ref":"extending.html#custom-sensors"},{"type":"extras","title":"Implementing a Custom Sensor - Extending Bardo","doc":"To create a custom sensor, implement the `Bardo.AgentManager.Sensor` behaviour:\n\n```elixir\ndefmodule MyApp.CustomSensor do\n  @behaviour Bardo.AgentManager.Sensor\n  \n  @impl true\n  def init(id, cortex_pid, vl, fanout) do\n    # Initialize sensor state\n    {:ok, %{\n      id: id,\n      sensor_type: :custom,\n      fanout: fanout,\n      cortex_pid: cortex_pid,\n      vl: vl,\n      # Any additional state you need\n      custom_state: %{}\n    }}\n  end\n  \n  @impl true\n  def sense(state, data) do\n    # Process incoming data into neural signals\n    signals = process_data(data, state.fanout)\n    \n    # Return signals and updated state\n    {:ok, signals, state}\n  end\n  \n  defp process_data(data, fanout) do\n    # Custom data processing logic\n    # Must return a list of values with length equal to fanout\n    List.duplicate(0.0, fanout)\n  end\nend\n```","ref":"extending.html#implementing-a-custom-sensor"},{"type":"extras","title":"Common Sensor Types - Extending Bardo","doc":"#### Vector Sensor\n\nA simple sensor that passes numeric vectors directly to the neural network:\n\n```elixir\ndefmodule MyApp.VectorSensor do\n  @behaviour Bardo.AgentManager.Sensor\n  \n  @impl true\n  def init(id, cortex_pid, vl, fanout) do\n    {:ok, %{\n      id: id,\n      sensor_type: :vector,\n      fanout: fanout,\n      cortex_pid: cortex_pid,\n      vl: vl\n    }}\n  end\n  \n  @impl true\n  def sense(state, data) do\n    # Ensure data is a list with the right length\n    signals = cond do\n      is_list(data) and length(data) == state.fanout ->\n        data\n        \n      is_list(data) and length(data)  \n        # Pad with zeros if too short\n        data ++ List.duplicate(0.0, state.fanout - length(data))\n        \n      is_list(data) and length(data) > state.fanout ->\n        # Truncate if too long\n        Enum.take(data, state.fanout)\n        \n      true ->\n        # Default if data is not a list\n        List.duplicate(0.0, state.fanout)\n    end\n    \n    {:ok, signals, state}\n  end\nend\n```\n\n#### Image Sensor\n\nA sensor for processing image data:\n\n```elixir\ndefmodule MyApp.ImageSensor do\n  @behaviour Bardo.AgentManager.Sensor\n  \n  @impl true\n  def init(id, cortex_pid, vl, fanout) do\n    {:ok, %{\n      id: id,\n      sensor_type: :image,\n      fanout: fanout,\n      cortex_pid: cortex_pid,\n      vl: vl,\n      # Configuration for image processing\n      image_size: {28, 28}  # Default to MNIST size\n    }}\n  end\n  \n  @impl true\n  def sense(state, image_data) do\n    # Process image data\n    signals = process_image(image_data, state.image_size, state.fanout)\n    \n    {:ok, signals, state}\n  end\n  \n  defp process_image(image_data, {width, height}, fanout) do\n    # Resize and normalize image\n    resized = resize_image(image_data, width, height)\n    \n    # Convert to grayscale values between 0.0 and 1.0\n    pixels = normalize_pixels(resized)\n    \n    # Ensure we have exactly fanout elements\n    cond do\n      length(pixels) == fanout -> pixels\n      length(pixels)   pixels ++ List.duplicate(0.0, fanout - length(pixels))\n      length(pixels) > fanout -> Enum.take(pixels, fanout)\n    end\n  end\n  \n  defp resize_image(image_data, width, height) do\n    # Image resizing implementation\n    # This would typically use a library like Image\n    # ...\n    \n    # Return resized image\n    resized_image\n  end\n  \n  defp normalize_pixels(image) do\n    # Convert image pixels to values between 0.0 and 1.0\n    # ...\n    \n    # Return normalized pixels\n    normalized_pixels\n  end\nend\n```","ref":"extending.html#common-sensor-types"},{"type":"extras","title":"Custom Actuators - Extending Bardo","doc":"Actuators convert the neural network's outputs into actions in the environment.","ref":"extending.html#custom-actuators"},{"type":"extras","title":"Implementing a Custom Actuator - Extending Bardo","doc":"To create a custom actuator, implement the `Bardo.AgentManager.Actuator` behaviour:\n\n```elixir\ndefmodule MyApp.CustomActuator do\n  @behaviour Bardo.AgentManager.Actuator\n  \n  @impl true\n  def init(id, cortex_pid, vl, fanin) do\n    # Initialize actuator state\n    {:ok, %{\n      id: id,\n      actuator_type: :custom,\n      fanin: fanin,\n      cortex_pid: cortex_pid,\n      vl: vl,\n      # Any additional state you need\n      custom_state: %{}\n    }}\n  end\n  \n  @impl true\n  def actuate(state, {agent_id, signals, _params, _vl, scape, actuator_id, _mod_state}) do\n    # Process neural signals into actions\n    action = process_signals(signals)\n    \n    # Return action and updated state\n    {:ok, action, state}\n  end\n  \n  defp process_signals(signals) do\n    # Custom signal processing logic\n    # Convert neural outputs to meaningful actions\n    \n    # Example: find the index of the highest value (winner-takes-all)\n    {index, _value} = Enum.with_index(signals)\n                      |> Enum.max_by(fn {value, _index} -> value end)\n    \n    # Return action based on index\n    index\n  end\nend\n```","ref":"extending.html#implementing-a-custom-actuator"},{"type":"extras","title":"Common Actuator Types - Extending Bardo","doc":"#### Discrete Action Actuator\n\nAn actuator that selects one discrete action from a set of possibilities:\n\n```elixir\ndefmodule MyApp.DiscreteActionActuator do\n  @behaviour Bardo.AgentManager.Actuator\n  \n  @impl true\n  def init(id, cortex_pid, vl, fanin) do\n    {:ok, %{\n      id: id,\n      actuator_type: :discrete_action,\n      fanin: fanin,\n      cortex_pid: cortex_pid,\n      vl: vl,\n      actions: [:action1, :action2, :action3, :action4]  # Default actions\n    }}\n  end\n  \n  @impl true\n  def actuate(state, {_agent_id, signals, _params, _vl, _scape, _actuator_id, _mod_state}) do\n    # Find the strongest output\n    {max_index, _} = Enum.with_index(signals)\n                    |> Enum.max_by(fn {value, _index} -> value end)\n    \n    # Convert to action\n    action = Enum.at(state.actions, max_index, List.last(state.actions))\n    \n    {:ok, action, state}\n  end\nend\n```\n\n#### Continuous Control Actuator\n\nAn actuator for continuous control tasks:\n\n```elixir\ndefmodule MyApp.ContinuousControlActuator do\n  @behaviour Bardo.AgentManager.Actuator\n  \n  @impl true\n  def init(id, cortex_pid, vl, fanin) do\n    {:ok, %{\n      id: id,\n      actuator_type: :continuous_control,\n      fanin: fanin,\n      cortex_pid: cortex_pid,\n      vl: vl,\n      # Output scaling\n      min_values: List.duplicate(-1.0, fanin),\n      max_values: List.duplicate(1.0, fanin)\n    }}\n  end\n  \n  @impl true\n  def actuate(state, {_agent_id, signals, _params, _vl, _scape, _actuator_id, _mod_state}) do\n    # Scale outputs to the desired ranges\n    scaled_outputs = Enum.zip([signals, state.min_values, state.max_values])\n                    |> Enum.map(fn {signal, min_val, max_val} ->\n                      min_val + (signal * (max_val - min_val))\n                    end)\n    \n    {:ok, scaled_outputs, state}\n  end\nend\n```","ref":"extending.html#common-actuator-types"},{"type":"extras","title":"Custom Morphologies - Extending Bardo","doc":"Morphologies define the structure of your neural networks, including inputs, outputs, and hidden layers.","ref":"extending.html#custom-morphologies"},{"type":"extras","title":"Implementing a Custom Morphology - Extending Bardo","doc":"To create a custom morphology, implement the `Bardo.Morphology` behaviour:\n\n```elixir\ndefmodule MyApp.CustomMorphology do\n  @behaviour Bardo.Morphology\n  \n  @impl true\n  def sensor_spec do\n    [\n      %{\n        id: :input_sensor,\n        fanout: 4,  # 4 inputs\n        vl: :float,\n        cortex_id: nil,  # Will be filled in at runtime\n        name: \"Input Sensor\"\n      }\n    ]\n  end\n  \n  @impl true\n  def actuator_spec do\n    [\n      %{\n        id: :output_actuator,\n        fanin: 2,  # 2 outputs\n        vl: :float,\n        cortex_id: nil,  # Will be filled in at runtime\n        name: \"Output Actuator\"\n      }\n    ]\n  end\n  \n  @impl true\n  def hidden_layer_spec do\n    [\n      %{\n        id: :hidden1,\n        size: 6,  # 6 neurons in the first hidden layer\n        af: :sigmoid,  # Activation function\n        input_layer_ids: [:input_sensor],  # Connected to inputs\n        output_layer_ids: [:hidden2]  # Connected to next hidden layer\n      },\n      %{\n        id: :hidden2,\n        size: 4,  # 4 neurons in the second hidden layer\n        af: :tanh,  # Different activation function\n        input_layer_ids: [:hidden1],  # Connected to previous hidden layer\n        output_layer_ids: [:output_actuator]  # Connected to outputs\n      }\n    ]\n  end\nend\n```","ref":"extending.html#implementing-a-custom-morphology"},{"type":"extras","title":"Morphology Patterns - Extending Bardo","doc":"#### Feed-Forward Network\n\nA basic feed-forward network:\n\n```elixir\ndefmodule MyApp.FeedForwardMorphology do\n  @behaviour Bardo.Morphology\n  \n  @impl true\n  def sensor_spec do\n    [\n      %{\n        id: :input,\n        fanout: 10,  # 10 inputs\n        vl: :float,\n        cortex_id: nil,\n        name: \"Input Layer\"\n      }\n    ]\n  end\n  \n  @impl true\n  def actuator_spec do\n    [\n      %{\n        id: :output,\n        fanin: 3,  # 3 outputs\n        vl: :float,\n        cortex_id: nil,\n        name: \"Output Layer\"\n      }\n    ]\n  end\n  \n  @impl true\n  def hidden_layer_spec do\n    [\n      %{\n        id: :hidden,\n        size: 8,  # 8 neurons in hidden layer\n        af: :sigmoid,\n        input_layer_ids: [:input],\n        output_layer_ids: [:output]\n      }\n    ]\n  end\nend\n```\n\n#### Deep Network\n\nA deeper network with multiple hidden layers:\n\n```elixir\ndefmodule MyApp.DeepNetworkMorphology do\n  @behaviour Bardo.Morphology\n  \n  @impl true\n  def sensor_spec do\n    [\n      %{\n        id: :input,\n        fanout: 28 * 28,  # For MNIST images\n        vl: :float,\n        cortex_id: nil,\n        name: \"Image Input\"\n      }\n    ]\n  end\n  \n  @impl true\n  def actuator_spec do\n    [\n      %{\n        id: :output,\n        fanin: 10,  # 10 digits (0-9)\n        vl: :float,\n        cortex_id: nil,\n        name: \"Digit Output\"\n      }\n    ]\n  end\n  \n  @impl true\n  def hidden_layer_spec do\n    [\n      %{\n        id: :hidden1,\n        size: 128,\n        af: :relu,\n        input_layer_ids: [:input],\n        output_layer_ids: [:hidden2]\n      },\n      %{\n        id: :hidden2,\n        size: 64,\n        af: :relu,\n        input_layer_ids: [:hidden1],\n        output_layer_ids: [:hidden3]\n      },\n      %{\n        id: :hidden3,\n        size: 32,\n        af: :relu,\n        input_layer_ids: [:hidden2],\n        output_layer_ids: [:output]\n      }\n    ]\n  end\nend\n```\n\n#### Recurrent Network\n\nA recurrent network with feedback connections:\n\n```elixir\ndefmodule MyApp.RecurrentNetworkMorphology do\n  @behaviour Bardo.Morphology\n  \n  @impl true\n  def sensor_spec do\n    [\n      %{\n        id: :input,\n        fanout: 5,\n        vl: :float,\n        cortex_id: nil,\n        name: \"Sequence Input\"\n      }\n    ]\n  end\n  \n  @impl true\n  def actuator_spec do\n    [\n      %{\n        id: :output,\n        fanin: 5,\n        vl: :float,\n        cortex_id: nil,\n        name: \"Sequence Output\"\n      }\n    ]\n  end\n  \n  @impl true\n  def hidden_layer_spec do\n    [\n      %{\n        id: :recurrent,\n        size: 10,\n        af: :tanh,\n        input_layer_ids: [:input, :recurrent], # Self-connection\n        output_layer_ids: [:output, :recurrent] # Self-connection\n      }\n    ]\n  end\nend\n```","ref":"extending.html#morphology-patterns"},{"type":"extras","title":"Custom Fitness Functions - Extending Bardo","doc":"Fitness functions evaluate the performance of evolved neural networks.","ref":"extending.html#custom-fitness-functions"},{"type":"extras","title":"Basic Fitness Function - Extending Bardo","doc":"```elixir\ndef my_fitness_function(genotype) do\n  # Convert genotype to neural network\n  nn = Bardo.AgentManager.Cortex.from_genotype(genotype)\n  \n  # Test cases\n  test_cases = [\n    {inputs1, expected1},\n    {inputs2, expected2},\n    # More test cases...\n  ]\n  \n  # Evaluate on all test cases\n  total_fitness = Enum.reduce(test_cases, 0, fn {inputs, expected}, acc ->\n    # Get actual output\n    actual = Bardo.AgentManager.Cortex.activate(nn, inputs)\n    \n    # Calculate error\n    error = calculate_error(actual, expected)\n    \n    # Convert error to fitness (higher is better)\n    fitness = 1.0 / (1.0 + error)\n    \n    # Add to total\n    acc + fitness\n  end)\n  \n  # Return average fitness\n  total_fitness / length(test_cases)\nend\n\ndefp calculate_error(actual, expected) do\n  # Mean squared error\n  Enum.zip(actual, expected)\n  |> Enum.map(fn {a, e} -> :math.pow(a - e, 2) end)\n  |> Enum.sum()\n  |> Kernel./(length(actual))\nend\n```","ref":"extending.html#basic-fitness-function"},{"type":"extras","title":"Simulation-Based Fitness Function - Extending Bardo","doc":"For more complex tasks, evaluate agents in a simulated environment:\n\n```elixir\ndef simulation_fitness_function(genotype) do\n  # Convert genotype to neural network\n  nn = Bardo.AgentManager.Cortex.from_genotype(genotype)\n  \n  # Setup simulation environment\n  env = initialize_environment()\n  \n  # Run simulation for fixed number of steps\n  {final_env, reward_history} = run_simulation(nn, env, 1000)\n  \n  # Calculate fitness from rewards\n  total_reward = Enum.sum(reward_history)\n  \n  # Return fitness\n  total_reward\nend\n\ndefp initialize_environment do\n  # Setup initial environment state\n  # ...\n  \n  env\nend\n\ndefp run_simulation(nn, env, steps) do\n  run_simulation_loop(nn, env, steps, [], 0)\nend\n\ndefp run_simulation_loop(_nn, env, 0, rewards, _step) do\n  # Simulation complete\n  {env, rewards}\nend\n\ndefp run_simulation_loop(nn, env, steps_left, rewards, step) do\n  # Get observations from environment\n  observations = get_observations(env)\n  \n  # Get action from neural network\n  action = Bardo.AgentManager.Cortex.activate(nn, observations)\n  \n  # Apply action to environment\n  {new_env, reward, done} = apply_action(env, action)\n  \n  if done do\n    # Simulation ended early\n    {new_env, [reward | rewards]}\n  else\n    # Continue simulation\n    run_simulation_loop(nn, new_env, steps_left - 1, [reward | rewards], step + 1)\n  end\nend\n\ndefp get_observations(env) do\n  # Extract observations from environment\n  # ...\n  \n  observations\nend\n\ndefp apply_action(env, action) do\n  # Apply action to environment and get reward\n  # ...\n  \n  {updated_env, reward, done}\nend\n```","ref":"extending.html#simulation-based-fitness-function"},{"type":"extras","title":"Custom Selection Algorithms - Extending Bardo","doc":"Selection algorithms determine which genotypes get to reproduce.","ref":"extending.html#custom-selection-algorithms"},{"type":"extras","title":"Implementing a Custom Selection Algorithm - Extending Bardo","doc":"```elixir\ndefmodule MyApp.CustomSelectionAlgorithm do\n  @behaviour Bardo.PopulationManager.SelectionAlgorithm\n  \n  @impl true\n  def select(population, options) do\n    # Sort population by fitness (assuming higher is better)\n    sorted = Enum.sort_by(population, fn {_genotype, fitness} -> fitness end, &>=/2)\n    \n    # Get population size\n    pop_size = length(population)\n    \n    # Get selection parameters with defaults\n    elite_count = Map.get(options, :elite_count, 2)\n    tournament_size = Map.get(options, :tournament_size, 3)\n    tournament_count = pop_size - elite_count\n    \n    # Directly select elites\n    elites = Enum.take(sorted, elite_count)\n    \n    # Select the rest through tournament selection\n    tournament_selected = Enum.map(1..tournament_count, fn _ ->\n      # Randomly select candidates for tournament\n      candidates = Enum.take_random(population, tournament_size)\n      \n      # Return the best candidate\n      Enum.max_by(candidates, fn {_genotype, fitness} -> fitness end)\n    end)\n    \n    # Combine elites and tournament selections\n    elites ++ tournament_selected\n  end\nend\n```","ref":"extending.html#implementing-a-custom-selection-algorithm"},{"type":"extras","title":"Custom Plasticity Rules - Extending Bardo","doc":"Plasticity rules define how neural connections change during the lifetime of a network.","ref":"extending.html#custom-plasticity-rules"},{"type":"extras","title":"Implementing a Custom Plasticity Rule - Extending Bardo","doc":"```elixir\ndefmodule MyApp.CustomPlasticityRule do\n  @behaviour Bardo.Plasticity\n  \n  @impl true\n  def apply_rule(weight, pre_activation, post_activation, parameters) do\n    # Get learning rate\n    learning_rate = Map.get(parameters, :learning_rate, 0.01)\n    \n    # Simple Hebbian learning rule: \"Neurons that fire together, wire together\"\n    delta = learning_rate * pre_activation * post_activation\n    \n    # Update weight\n    new_weight = weight + delta\n    \n    # Clamp weight to valid range\n    clamped = max(-1.0, min(1.0, new_weight))\n    \n    clamped\n  end\nend\n```","ref":"extending.html#implementing-a-custom-plasticity-rule"},{"type":"extras","title":"Extending the UI/Visualization - Extending Bardo","doc":"If you're building a visualization for your Bardo experiments, you can add custom components.","ref":"extending.html#extending-the-ui-visualization"},{"type":"extras","title":"Network Visualization - Extending Bardo","doc":"```elixir\ndefmodule MyApp.NetworkVisualizer do\n  @doc \"\"\"\n  Converts a neural network to a visualization format.\n  \"\"\"\n  def visualize(nn) do\n    # Extract neurons and connections\n    neurons = extract_neurons(nn)\n    connections = extract_connections(nn)\n    \n    # Format for visualization library\n    %{\n      nodes: format_nodes(neurons),\n      edges: format_edges(connections)\n    }\n  end\n  \n  defp extract_neurons(nn) do\n    # Extract neuron data from neural network\n    # ...\n    \n    neurons\n  end\n  \n  defp extract_connections(nn) do\n    # Extract connection data from neural network\n    # ...\n    \n    connections\n  end\n  \n  defp format_nodes(neurons) do\n    # Format neurons for visualization\n    Enum.map(neurons, fn neuron ->\n      %{\n        id: neuron.id,\n        label: \"Neuron #{neuron.id}\",\n        type: neuron.type,\n        activation: neuron.activation_function\n      }\n    end)\n  end\n  \n  defp format_edges(connections) do\n    # Format connections for visualization\n    Enum.map(connections, fn connection ->\n      %{\n        source: connection.source_id,\n        target: connection.target_id,\n        weight: connection.weight\n      }\n    end)\n  end\nend\n```","ref":"extending.html#network-visualization"},{"type":"extras","title":"Fitness Chart - Extending Bardo","doc":"```elixir\ndefmodule MyApp.FitnessChart do\n  @doc \"\"\"\n  Formats fitness history data for charting.\n  \"\"\"\n  def format_fitness_history(experiment_id) do\n    # Get experiment data\n    {:ok, experiment} = Bardo.ExperimentManager.get_experiment(experiment_id)\n    \n    # Extract fitness history\n    fitness_history = experiment.fitness_history\n    \n    # Format for charting\n    %{\n      labels: Enum.map(0..(length(fitness_history) - 1), &Integer.to_string/1),\n      datasets: [\n        %{\n          label: \"Best Fitness\",\n          data: fitness_history,\n          borderColor: \"rgba(75, 192, 192, 1)\",\n          backgroundColor: \"rgba(75, 192, 192, 0.2)\"\n        }\n      ]\n    }\n  end\nend\n```","ref":"extending.html#fitness-chart"},{"type":"extras","title":"Integrating with External Systems - Extending Bardo","doc":"","ref":"extending.html#integrating-with-external-systems"},{"type":"extras","title":"Custom Data Loaders - Extending Bardo","doc":"```elixir\ndefmodule MyApp.DataLoader do\n  @doc \"\"\"\n  Loads training data from external sources.\n  \"\"\"\n  def load_training_data(source) do\n    case source do\n      {:csv, filename} ->\n        load_from_csv(filename)\n        \n      {:database, query} ->\n        load_from_database(query)\n        \n      {:api, url} ->\n        load_from_api(url)\n        \n      _ ->\n        {:error, :unknown_source}\n    end\n  end\n  \n  defp load_from_csv(filename) do\n    # Parse CSV file\n    # ...\n    \n    {:ok, data}\n  end\n  \n  defp load_from_database(query) do\n    # Execute database query\n    # ...\n    \n    {:ok, data}\n  end\n  \n  defp load_from_api(url) do\n    # Make API request\n    # ...\n    \n    {:ok, data}\n  end\nend\n```","ref":"extending.html#custom-data-loaders"},{"type":"extras","title":"External Model Exporters - Extending Bardo","doc":"```elixir\ndefmodule MyApp.ModelExporter do\n  @doc \"\"\"\n  Exports Bardo models to different formats.\n  \"\"\"\n  def export_model(genotype, format, filename) do\n    case format do\n      :onnx ->\n        export_to_onnx(genotype, filename)\n        \n      :tensorflow ->\n        export_to_tensorflow(genotype, filename)\n        \n      :json ->\n        export_to_json(genotype, filename)\n        \n      _ ->\n        {:error, :unknown_format}\n    end\n  end\n  \n  defp export_to_onnx(genotype, filename) do\n    # Convert to ONNX format\n    # ...\n    \n    {:ok, filename}\n  end\n  \n  defp export_to_tensorflow(genotype, filename) do\n    # Convert to TensorFlow format\n    # ...\n    \n    {:ok, filename}\n  end\n  \n  defp export_to_json(genotype, filename) do\n    # Convert to JSON\n    json = Jason.encode!(genotype)\n    \n    # Write to file\n    File.write(filename, json)\n  end\nend\n```","ref":"extending.html#external-model-exporters"},{"type":"extras","title":"Distributed Computing Extensions - Extending Bardo","doc":"","ref":"extending.html#distributed-computing-extensions"},{"type":"extras","title":"Custom Node Manager - Extending Bardo","doc":"```elixir\ndefmodule MyApp.DistributedNodeManager do\n  @doc \"\"\"\n  Manages a cluster of Bardo nodes.\n  \"\"\"\n  def start_cluster(node_count) do\n    # Start distributed nodes\n    nodes = start_nodes(node_count)\n    \n    # Connect nodes\n    connect_nodes(nodes)\n    \n    # Return node list\n    {:ok, nodes}\n  end\n  \n  defp start_nodes(count) do\n    # Start Erlang nodes\n    # ...\n    \n    nodes\n  end\n  \n  defp connect_nodes(nodes) do\n    # Connect nodes to form a cluster\n    # ...\n    \n    :ok\n  end\n  \n  @doc \"\"\"\n  Distributes genotypes across nodes for parallel evaluation.\n  \"\"\"\n  def distribute_evaluation(genotypes, fitness_function, nodes) do\n    # Split genotypes among nodes\n    chunks = Enum.chunk_every(genotypes, div(length(genotypes), length(nodes)) + 1)\n    \n    # Send chunks to nodes for evaluation\n    results = Enum.zip(chunks, nodes)\n              |> Enum.map(fn {chunk, node} ->\n                Task.async(fn ->\n                  :rpc.call(node, Bardo.PopulationManager, :evaluate_genotypes, [chunk, fitness_function])\n                end)\n              end)\n              |> Enum.map(&Task.await(&1, :infinity))\n    \n    # Combine results\n    List.flatten(results)\n  end\nend\n```","ref":"extending.html#custom-node-manager"},{"type":"extras","title":"Performance Optimizations - Extending Bardo","doc":"","ref":"extending.html#performance-optimizations"},{"type":"extras","title":"Custom Cache Strategy - Extending Bardo","doc":"```elixir\ndefmodule MyApp.EvaluationCache do\n  @doc \"\"\"\n  Initializes an evaluation cache.\n  \"\"\"\n  def init do\n    # Create ETS table for caching\n    :ets.new(:evaluation_cache, [:set, :public, :named_table])\n    :ok\n  end\n  \n  @doc \"\"\"\n  Gets or computes fitness for a genotype.\n  \"\"\"\n  def get_or_compute(genotype, fitness_function) do\n    # Generate cache key\n    key = :erlang.phash2(genotype)\n    \n    # Try to get from cache\n    case :ets.lookup(:evaluation_cache, key) do\n      [{^key, fitness}] ->\n        # Cache hit\n        fitness\n        \n      [] ->\n        # Cache miss, compute fitness\n        fitness = fitness_function.(genotype)\n        \n        # Store in cache\n        :ets.insert(:evaluation_cache, {key, fitness})\n        \n        fitness\n    end\n  end\n  \n  @doc \"\"\"\n  Clears the evaluation cache.\n  \"\"\"\n  def clear do\n    :ets.delete_all_objects(:evaluation_cache)\n    :ok\n  end\nend\n```","ref":"extending.html#custom-cache-strategy"},{"type":"extras","title":"Real-world Extensions - Extending Bardo","doc":"","ref":"extending.html#real-world-extensions"},{"type":"extras","title":"Financial Market Integration - Extending Bardo","doc":"```elixir\ndefmodule MyApp.MarketIntegration do\n  @doc \"\"\"\n  Creates a Bardo sensor for financial market data.\n  \"\"\"\n  def create_market_sensor(market, timeframe) do\n    # Define sensor module\n    defmodule MarketSensor do\n      @behaviour Bardo.AgentManager.Sensor\n      \n      @impl true\n      def init(id, cortex_pid, vl, fanout) do\n        {:ok, %{\n          id: id,\n          sensor_type: :market,\n          fanout: fanout,\n          cortex_pid: cortex_pid,\n          vl: vl,\n          market: market,\n          timeframe: timeframe,\n          indicators: [:price, :volume, :rsi, :macd]\n        }}\n      end\n      \n      @impl true\n      def sense(state, data) do\n        # Get market data\n        market_data = get_market_data(state.market, state.timeframe, data.timestamp)\n        \n        # Calculate technical indicators\n        indicators = calculate_indicators(market_data, state.indicators)\n        \n        # Format as neural inputs\n        signals = format_indicators(indicators, state.fanout)\n        \n        {:ok, signals, state}\n      end\n      \n      defp get_market_data(market, timeframe, timestamp) do\n        # Fetch market data from API or database\n        # ...\n        \n        market_data\n      end\n      \n      defp calculate_indicators(market_data, indicators) do\n        # Calculate technical indicators\n        # ...\n        \n        calculated_indicators\n      end\n      \n      defp format_indicators(indicators, fanout) do\n        # Format indicators as neural inputs\n        # ...\n        \n        formatted_indicators\n      end\n    end\n    \n    # Return sensor module\n    MarketSensor\n  end\nend\n```","ref":"extending.html#financial-market-integration"},{"type":"extras","title":"Integration with Machine Learning Frameworks - Extending Bardo","doc":"","ref":"extending.html#integration-with-machine-learning-frameworks"},{"type":"extras","title":"TensorFlow Integration - Extending Bardo","doc":"```elixir\ndefmodule MyApp.TensorFlowIntegration do\n  @doc \"\"\"\n  Converts a Bardo neural network to a TensorFlow model.\n  \"\"\"\n  def convert_to_tensorflow(nn) do\n    # Extract network structure\n    structure = extract_network_structure(nn)\n    \n    # Convert to TensorFlow model\n    tf_model = build_tensorflow_model(structure)\n    \n    {:ok, tf_model}\n  end\n  \n  defp extract_network_structure(nn) do\n    # Extract layers, neurons, and connections\n    # ...\n    \n    structure\n  end\n  \n  defp build_tensorflow_model(structure) do\n    # Build TensorFlow model using Python interop\n    # ...\n    \n    tf_model\n  end\n  \n  @doc \"\"\"\n  Runs inference using TensorFlow.\n  \"\"\"\n  def run_inference(tf_model, inputs) do\n    # Run inference in TensorFlow\n    # ...\n    \n    {:ok, outputs}\n  end\nend\n```","ref":"extending.html#tensorflow-integration"},{"type":"extras","title":"Advanced Bardo Usage","doc":"# Advanced Bardo Usage\n\nThis guide covers advanced topics and techniques for working with Bardo.","ref":"advanced.html"},{"type":"extras","title":"Custom Fitness Functions - Advanced Bardo Usage","doc":"A fitness function evaluates how well a neural network performs at a given task. Here's how to create your own:\n\n```elixir\ndefmodule MyApp.FitnessFunctions do\n  def xor_fitness(genotype) do\n    # Create neural network from genotype\n    nn = Bardo.AgentManager.Cortex.from_genotype(genotype)\n    \n    # Test cases for XOR\n    test_cases = [\n      {[0.0, 0.0], [0.0]},\n      {[0.0, 1.0], [1.0]},\n      {[1.0, 0.0], [1.0]},\n      {[1.0, 1.0], [0.0]}\n    ]\n    \n    # Calculate error across all test cases\n    total_error = Enum.reduce(test_cases, 0, fn {inputs, expected}, acc ->\n      outputs = Bardo.AgentManager.Cortex.activate(nn, inputs)\n      error = Enum.sum(Enum.map(Enum.zip(outputs, expected), fn {o, e} -> abs(o - e) end))\n      acc + error\n    end)\n    \n    # Convert error to fitness (lower error = higher fitness)\n    fitness = 4 - total_error\n    \n    # Return fitness score\n    fitness\n  end\nend\n```\n\nWhen creating fitness functions, consider:\n- Normalization: Keep fitness values in a consistent range\n- Granularity: Provide enough differentiation between solutions\n- Guidance: Shape the fitness landscape to guide evolution toward desired behaviors","ref":"advanced.html#custom-fitness-functions"},{"type":"extras","title":"Developing Custom Sensors - Advanced Bardo Usage","doc":"Sensors provide input to neural networks. To create a custom sensor:\n\n```elixir\ndefmodule MyApp.Sensors.TemperatureSensor do\n  @behaviour Bardo.AgentManager.Sensor\n  \n  @impl true\n  def init(params) do\n    # Initialize sensor with given parameters\n    {:ok, params}\n  end\n  \n  @impl true\n  def sense(state, world_state) do\n    # Extract temperature from world state\n    temperature = world_state.temperature\n    \n    # Normalize temperature to range [0,1]\n    normalized_temp = (temperature - state.min_temp) / (state.max_temp - state.min_temp)\n    \n    # Return sensor reading\n    {:ok, [normalized_temp], state}\n  end\nend\n```\n\nWhen designing sensors:\n- Normalize inputs to a standard range (typically [-1, 1] or [0, 1])\n- Consider sensor placement and field of view\n- Determine appropriate sensor resolution and update frequency","ref":"advanced.html#developing-custom-sensors"},{"type":"extras","title":"Developing Custom Actuators - Advanced Bardo Usage","doc":"Actuators allow neural networks to interact with their environment:\n\n```elixir\ndefmodule MyApp.Actuators.JointActuator do\n  @behaviour Bardo.AgentManager.Actuator\n  \n  @impl true\n  def init(params) do\n    # Initialize actuator with given parameters\n    {:ok, params}\n  end\n  \n  @impl true\n  def actuate(state, world_state, output_vector) do\n    # Extract joint angle from neural network output\n    [joint_angle] = output_vector\n    \n    # Scale from [-1,1] to actual joint limits\n    scaled_angle = state.min_angle + (joint_angle + 1) * (state.max_angle - state.min_angle) / 2\n    \n    # Apply to world state\n    new_world_state = put_in(world_state.joint_positions[state.joint_id], scaled_angle)\n    \n    # Return new world state\n    {:ok, new_world_state, state}\n  end\nend\n```","ref":"advanced.html#developing-custom-actuators"},{"type":"extras","title":"Advanced Mutation Operators - Advanced Bardo Usage","doc":"Bardo comes with standard mutation operators, but you can create custom ones:\n\n```elixir\ndefmodule MyApp.CustomMutator do\n  def mutate_weights_with_noise(genotype, config) do\n    noise_scale = config[:noise_scale] || 0.1\n    \n    # Apply Gaussian noise to all weights\n    updated_weights = Enum.map(genotype.weights, fn {id, weight} ->\n      noise = :rand.normal() * noise_scale\n      {id, weight + noise}\n    end)\n    \n    # Return updated genotype\n    %{genotype | weights: Map.new(updated_weights)}\n  end\nend\n```\n\nTo use custom mutation operators:\n\n```elixir\n# Configure experiment with custom mutation operator\nBardo.ExperimentManager.configure(experiment, %{\n  population_size: 50,\n  mutation_operators: [\n    {MyApp.CustomMutator, :mutate_weights_with_noise, [%{noise_scale: 0.05}], 0.3}\n  ]\n})\n```","ref":"advanced.html#advanced-mutation-operators"},{"type":"extras","title":"Distributed Training - Advanced Bardo Usage","doc":"Bardo can distribute evolutionary computations across multiple Erlang nodes:\n\n```elixir\n# Connect to other nodes\nNode.connect(:\"node1@192.168.1.101\")\nNode.connect(:\"node2@192.168.1.102\")\n\n# Configure experiment with distributed settings\nBardo.ExperimentManager.configure(experiment, %{\n  distributed: true,\n  nodes: [node(), :\"node1@192.168.1.101\", :\"node2@192.168.1.102\"],\n  population_per_node: 20\n})\n```","ref":"advanced.html#distributed-training"},{"type":"extras","title":"Custom Neural Activation Functions - Advanced Bardo Usage","doc":"By default, Bardo uses sigmoid activation functions, but you can define others:\n\n```elixir\ndefmodule MyApp.ActivationFunctions do\n  def relu(x) do\n    max(0, x)\n  end\n  \n  def leaky_relu(x) do\n    if x > 0, do: x, else: 0.01 * x\n  end\n  \n  def tanh(x) do\n    :math.tanh(x)\n  end\nend\n\n# Use custom activation function when creating a neuron\nBardo.PopulationManager.Genotype.add_neuron(genotype, :hidden, %{\n  activation_function: {MyApp.ActivationFunctions, :tanh}\n})\n```","ref":"advanced.html#custom-neural-activation-functions"},{"type":"extras","title":"Custom Substrate Encodings - Advanced Bardo Usage","doc":"For complex problems, you may want to use indirect encodings (where genotype doesn't directly specify each connection):\n\n```elixir\n# Configure hypercube substrate encoding\nBardo.ExperimentManager.configure(experiment, %{\n  substrate: %{\n    type: :hypercube,\n    dimensions: 3,\n    resolution: 5,\n    connectivity_function: {MyApp.Substrate, :connectivity_function}\n  }\n})\n```","ref":"advanced.html#custom-substrate-encodings"},{"type":"extras","title":"Real-time Visualization - Advanced Bardo Usage","doc":"To visualize evolution progress:\n\n```elixir\n# Start visualization server\nBardo.Visualization.start(%{\n  port: 8080,\n  refresh_rate: 1000,  # ms\n  metrics: [:fitness, :complexity, :diversity]\n})\n\n# Configure experiment to send data to visualization\nBardo.ExperimentManager.configure(experiment, %{\n  visualize: true,\n  visualization_endpoint: \"http://localhost:8080/data\"\n})\n```","ref":"advanced.html#real-time-visualization"},{"type":"extras","title":"Saving and Loading Evolved Networks - Advanced Bardo Usage","doc":"To save your best evolved networks for later use:\n\n```elixir\n# Get best solution from experiment\nbest_solution = Bardo.ExperimentManager.get_best_solution(experiment)\n\n# Save to file\nBardo.Utils.save_genotype(best_solution, \"models/xor_solution.gen\")\n\n# Load from file\nloaded_genotype = Bardo.Utils.load_genotype(\"models/xor_solution.gen\")\n\n# Create neural network from saved genotype\nnn = Bardo.AgentManager.Cortex.from_genotype(loaded_genotype)\n```","ref":"advanced.html#saving-and-loading-evolved-networks"},{"type":"extras","title":"Custom Selection Algorithms - Advanced Bardo Usage","doc":"Bardo supports different selection algorithms for choosing which individuals reproduce:\n\n```elixir\ndefmodule MyApp.SelectionAlgorithms do\n  def tournament_selection(population, tournament_size, elite_count) do\n    # Sort population by fitness\n    sorted_pop = Enum.sort_by(population, fn agent -> agent.fitness end, :desc)\n    \n    # Keep elite individuals\n    {elite, rest} = Enum.split(sorted_pop, elite_count)\n    \n    # Fill remaining slots with tournament selection\n    selected = elite ++ tournament_select(rest, length(sorted_pop) - elite_count, tournament_size)\n    \n    selected\n  end\n  \n  defp tournament_select(population, count, tournament_size) do\n    Enum.map(1..count, fn _ ->\n      # Select random individuals for tournament\n      contestants = Enum.take_random(population, tournament_size)\n      \n      # Return winner (highest fitness)\n      Enum.max_by(contestants, fn agent -> agent.fitness end)\n    end)\n  end\nend\n\n# Configure experiment with custom selection algorithm\nBardo.ExperimentManager.configure(experiment, %{\n  selection_algorithm: {MyApp.SelectionAlgorithms, :tournament_selection, [5, 2]}\n})\n```","ref":"advanced.html#custom-selection-algorithms"},{"type":"extras","title":"Speciation and Diversity Preservation - Advanced Bardo Usage","doc":"To maintain genetic diversity during evolution:\n\n```elixir\n# Configure experiment with speciation\nBardo.ExperimentManager.configure(experiment, %{\n  enable_speciation: true,\n  species_distance_threshold: 0.3,\n  species_compatibility_function: {Bardo.PopulationManager.SpecieIdentifier, :compatibility_distance},\n  species_elitism: true,\n  minimum_species_size: 5\n})\n```","ref":"advanced.html#speciation-and-diversity-preservation"},{"type":"extras","title":"Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"# Substrate Encoding for Neural Networks in Algorithmic Trading","ref":"substrate_encoding.html"},{"type":"extras","title":"Introduction - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"Substrate encoding is a powerful neural network encoding technique that provides significant advantages for trading applications. This document explains how substrate encoding works in Bardo's algorithmic trading framework and how to use it effectively.","ref":"substrate_encoding.html#introduction"},{"type":"extras","title":"What is Substrate Encoding? - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"Substrate encoding (also known as Hypercube-based Neuroevolution of Augmenting Topologies or HyperNEAT) is a technique that encodes neural networks with a geometric interpretation of the problem domain. Rather than directly evolving connection weights in a fixed topology, substrate encoding evolves patterns of connectivity between neurons placed in a geometric space.","ref":"substrate_encoding.html#what-is-substrate-encoding"},{"type":"extras","title":"Why Use Substrate Encoding for Trading? - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"Traditional neural networks for trading face several challenges:\n\n1. **Time series complexity**: Market data contains complex temporal patterns\n2. **Multi-scale patterns**: Important patterns exist at different timeframes\n3. **Sparse relationships**: Only certain combinations of inputs matter\n4. **Overfitting**: It's easy to fit to noise rather than signal\n\nSubstrate encoding helps address these challenges by:\n\n1. **Geometric interpretation**: Maps market data to a coordinate space\n2. **Regular patterns**: Captures geometric regularities in data\n3. **Efficient representation**: Compresses complex patterns into fewer parameters\n4. **Built-in regularization**: Provides natural constraints on model complexity","ref":"substrate_encoding.html#why-use-substrate-encoding-for-trading"},{"type":"extras","title":"How Substrate Encoding Works in Bardo - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"In Bardo's algorithmic trading system, substrate encoding maps market data into a 3D coordinate space:\n\n- **X-axis (time)**: From recent to older candles\n- **Y-axis (price)**: From high to low price levels\n- **Z-axis (data type)**: Different types of data (OHLC, volume, indicators)\n\n![Substrate Encoding](../erlang/docs/substrate_encoding.png)","ref":"substrate_encoding.html#how-substrate-encoding-works-in-bardo"},{"type":"extras","title":"Key Components - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"1. **Input Encoding**: Market data is converted into a 3D grid\n2. **Neuron Placement**: Neurons are placed at specific coordinates\n3. **Connectivity Patterns**: Connections are established based on geometric rules\n4. **Weight Assignment**: Connection weights are derived from patterns","ref":"substrate_encoding.html#key-components"},{"type":"extras","title":"Implementation Details - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"","ref":"substrate_encoding.html#implementation-details"},{"type":"extras","title":"1. Creating a Substrate-Encoded Genotype - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"The first step is to create a genotype that uses substrate encoding:\n\n```elixir\ngenotype = Bardo.Examples.Applications.AlgoTrading.SubstrateEncoding.create_substrate_genotype(%{\n  input_time_points: 60,    # 60 time periods of data\n  input_price_levels: 20,   # 20 price levels\n  input_data_types: 10,     # 10 different data types\n  hidden_layers: 2,         # 2 hidden layers\n  hidden_neurons_per_layer: 20, # 20 neurons per hidden layer\n  output_neurons: 3         # 3 outputs (direction, size, risk)\n})\n```\n\nThis function:\n- Creates input neurons arranged in a 3D grid\n- Adds hidden layers with neurons in geometric patterns\n- Adds output neurons at appropriate coordinates\n- Establishes initial connectivity based on geometric rules","ref":"substrate_encoding.html#1-creating-a-substrate-encoded-genotype"},{"type":"extras","title":"2. Converting Market Data to Substrate Format - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"When processing market data, you need to convert it to the substrate format:\n\n```elixir\ngrid = Bardo.Examples.Applications.AlgoTrading.SubstrateEncoding.convert_price_data_to_substrate(\n  price_data,    # List of price candles\n  indicators,    # Map of technical indicators\n  60, 20, 10     # Dimensions matching the genotype\n)\n```\n\nThis function:\n- Maps price data into a 3D grid representation\n- Places different data types along the Z-axis\n- Uses activation functions to represent price levels\n- Normalizes all values to appropriate ranges","ref":"substrate_encoding.html#2-converting-market-data-to-substrate-format"},{"type":"extras","title":"3. Activating the Neural Network - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"Before activating the neural network, the grid needs to be flattened to match the input neurons:\n\n```elixir\ninputs = Bardo.Examples.Applications.AlgoTrading.SubstrateEncoding.flatten_substrate_grid(\n  grid, genotype\n)\n\n# Activate the neural network with the inputs\n{:ok, outputs} = Bardo.AgentManager.Cortex.activate(cortex, inputs)\n```\n\nThe flattening process:\n- Maps each point in the 3D grid to the corresponding input neuron\n- Matches coordinates in the grid to substrate coordinates of neurons\n- Creates a map of neuron IDs to input values","ref":"substrate_encoding.html#3-activating-the-neural-network"},{"type":"extras","title":"Evolutionary Process with Substrate Encoding - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"When evolving substrate-encoded networks:\n\n1. **Initialization**: Start with a population of substrate-encoded networks\n2. **Evaluation**: Test networks on the trading simulator\n3. **Selection**: Select the best-performing networks\n4. **Mutation**: Modify connectivity patterns and weights\n5. **Reproduction**: Create the next generation\n6. **Repeat**: Continue until convergence or generation limit\n\nThe key advantage is that mutations affect connectivity patterns rather than individual weights, allowing for more effective exploration of the solution space.","ref":"substrate_encoding.html#evolutionary-process-with-substrate-encoding"},{"type":"extras","title":"Practical Example: Forex Trading - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"Here's a complete example of using substrate encoding for forex trading:\n\n```elixir\n# Configure experiment with substrate encoding\nconfig = %{\n  market: :forex,\n  symbol: \"EURUSD\",\n  timeframe: 15,\n  population_size: 100,\n  generations: 100,\n  use_substrate: true,  # Enable substrate encoding\n  input_time_points: 60,\n  input_price_levels: 20,\n  input_data_types: 10\n}\n\n# Run the experiment\nBardo.Examples.Applications.AlgoTrading.run(:substrate_experiment, config)\n\n# Test the best agent\nBardo.Examples.Applications.AlgoTrading.test_best_agent(:substrate_experiment)\n\n# Get the best agent for deployment\n{:ok, best_agent} = Bardo.Examples.Applications.AlgoTrading.DistributedTraining.get_best_agent(:substrate_experiment)\n\n# Deploy to live trading\n{:ok, agent_id} = Bardo.Examples.Applications.AlgoTrading.LiveAgent.start_link(\n  :live_agent,\n  best_agent,\n  broker_module,\n  broker_config,\n  [substrate_encoding: true]  # Important to use substrate encoding for live data too\n)\n```","ref":"substrate_encoding.html#practical-example-forex-trading"},{"type":"extras","title":"Advanced Customization - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"You can customize substrate encoding for specific trading applications:","ref":"substrate_encoding.html#advanced-customization"},{"type":"extras","title":"Custom Coordinate Mappings - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"```elixir\n# Use a different coordinate system\ncustom_mapping = fn price_data, indicators, dims ->\n  # Custom mapping logic...\n  grid\nend\n\n# Use the custom mapping in your configuration\nconfig = %{\n  # ...\n  use_substrate: true,\n  substrate_mapping: custom_mapping\n}\n```","ref":"substrate_encoding.html#custom-coordinate-mappings"},{"type":"extras","title":"Different Activation Functions - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"```elixir\n# Create substrate with different activation functions\ngenotype = Bardo.Examples.Applications.AlgoTrading.SubstrateEncoding.create_substrate_genotype(%{\n  # ...\n  activation_functions: %{\n    input: :tanh,\n    hidden: :relu,\n    output: :sigmoid\n  }\n})\n```","ref":"substrate_encoding.html#different-activation-functions"},{"type":"extras","title":"Irregular Neuron Distributions - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"```elixir\n# Create substrate with custom neuron placement\ngenotype = Bardo.Examples.Applications.AlgoTrading.SubstrateEncoding.create_substrate_genotype(%{\n  # ...\n  neuron_placement: :concentrated,  # More neurons in recent timeframes\n  concentration_factor: 2.0         # How concentrated neurons are\n})\n```","ref":"substrate_encoding.html#irregular-neuron-distributions"},{"type":"extras","title":"Performance Considerations - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"Substrate encoding has some implications for performance:\n\n- **Training time**: Typically requires more generations than direct encoding\n- **Evaluation efficiency**: Faster evaluation due to more regular structure\n- **Memory usage**: Can be higher due to the geometric representation\n- **Runtime performance**: Usually comparable to standard neural networks\n\nFor best results:\n\n1. Use distributed training for larger population sizes\n2. Start with smaller networks and gradually increase complexity\n3. Tune mutation rates for substrate-specific operations\n4. Consider population diversity to avoid premature convergence","ref":"substrate_encoding.html#performance-considerations"},{"type":"extras","title":"Conclusion - Substrate Encoding for Neural Networks in Algorithmic Trading","doc":"Substrate encoding is a powerful technique for algorithmic trading that leverages geometric patterns in market data. By using this approach, you can create trading systems that are more robust, adaptable, and capable of capturing complex market dynamics.\n\nFor more information, see the [Algorithmic Trading Guide](algo_trading_guide.md) and [Example Configurations](example_configs/substrate_forex.exs).","ref":"substrate_encoding.html#conclusion"},{"type":"extras","title":"Bardo Release Notes","doc":"# Bardo Release Notes","ref":"release.html"},{"type":"extras","title":"Version 0.1.0 - Bardo Release Notes","doc":"This is the initial release of Bardo, a focused neuroevolution library for Elixir.","ref":"release.html#version-0-1-0"},{"type":"extras","title":"Key Features - Bardo Release Notes","doc":"- **Topology and Parameter Evolving Neural Networks (TWEANN)**: Bardo evolves both the structure and weights of neural networks over time.\n- **Efficient ETS-based Storage**: Simple and fast in-memory storage with periodic backups.\n- **Modular Sensor/Actuator Framework**: Easily connect networks to different environments.\n- **Built-in Evolutionary Algorithms**: Includes selection algorithms and mutation operators.\n- **Substrate Encoding**: Hypercube-based encoding for efficient pattern recognition.\n- **Example Environments**:\n  - XOR: Simple logical problem\n  - Double Pole Balancing: Classic control benchmark\n  - Flatland: Predator-prey simulation\n  - FX: Basic forex trading simulation","ref":"release.html#key-features"},{"type":"extras","title":"Changes in This Release - Bardo Release Notes","doc":"- Initial public release with Apache License 2.0\n- Removed experimental HTM (Hierarchical Temporal Memory) implementation\n- Updated documentation for hex.pm publication\n- Full test coverage across core functionality","ref":"release.html#changes-in-this-release"},{"type":"extras","title":"Known Issues - Bardo Release Notes","doc":"- There are some compiler warnings that need to be addressed in future releases\n- Some API functions need better documentation\n- Certain modules implement behaviours incorrectly (especially in example code)","ref":"release.html#known-issues"},{"type":"extras","title":"Future Roadmap - Bardo Release Notes","doc":"- Improve documentation and examples\n- Reduce compiler warnings\n- Add more comprehensive API reference\n- Create additional demo applications\n- Improve performance for large-scale simulations","ref":"release.html#future-roadmap"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.38.0"}}